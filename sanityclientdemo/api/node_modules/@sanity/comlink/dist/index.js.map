{"version":3,"file":"index.js","sources":["../src/common.ts","../src/constants.ts","../src/request.ts","../src/channel.ts","../src/controller.ts","../src/node.ts"],"sourcesContent":["import {bufferCount, concatMap, defer, filter, fromEvent, map, pipe, take} from 'rxjs'\nimport {fromEventObservable} from 'xstate'\nimport type {ListenInput, ProtocolMessage} from './types'\n\nexport const listenInputFromContext =\n  (\n    config: (\n      | {\n          include: string | string[]\n          exclude?: string | string[]\n        }\n      | {\n          include?: string | string[]\n          exclude: string | string[]\n        }\n    ) & {\n      matches?: boolean\n      count?: number\n      responseType?: string\n    },\n  ) =>\n  <\n    T extends {\n      domain: string\n      connectTo: string\n      name: string\n      target: MessageEventSource | undefined\n    },\n  >({\n    context,\n  }: {\n    context: T\n  }): ListenInput => {\n    const {count, include, exclude, responseType = 'message.received'} = config\n    return {\n      count,\n      domain: context.domain,\n      from: context.connectTo,\n      include: include ? (Array.isArray(include) ? include : [include]) : [],\n      exclude: exclude ? (Array.isArray(exclude) ? exclude : [exclude]) : [],\n      responseType,\n      target: context.target,\n      to: context.name,\n    }\n  }\n\nexport const listenFilter =\n  (input: ListenInput) =>\n  (event: MessageEvent<ProtocolMessage>): boolean => {\n    const {data} = event\n    return (\n      (input.include.length ? input.include.includes(data.type) : true) &&\n      (input.exclude.length ? !input.exclude.includes(data.type) : true) &&\n      data.domain === input.domain &&\n      data.from === input.from &&\n      data.to === input.to &&\n      (!input.target || event.source === input.target)\n    )\n  }\n\nexport const eventToMessage =\n  <T>(type: T) =>\n  (event: MessageEvent<ProtocolMessage>): {type: T; message: MessageEvent<ProtocolMessage>} => ({\n    type,\n    message: event,\n  })\n\nexport const messageEvents$ = defer(() =>\n  fromEvent<MessageEvent<ProtocolMessage>>(window, 'message'),\n)\n\n/**\n * @public\n */\nexport const createListenLogic = (\n  compatMap?: (event: MessageEvent<ProtocolMessage>) => MessageEvent<ProtocolMessage>,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n) =>\n  fromEventObservable(({input}: {input: ListenInput}) => {\n    return messageEvents$.pipe(\n      compatMap ? map(compatMap) : pipe(),\n      filter(listenFilter(input)),\n      map(eventToMessage(input.responseType)),\n      input.count\n        ? pipe(\n            bufferCount(input.count),\n            concatMap((arr) => arr),\n            take(input.count),\n          )\n        : pipe(),\n    )\n  })\n","import type {MessageType} from './types'\n\n/** @internal */\nexport const DOMAIN = 'sanity/comlink'\n\n/** @internal */\nexport const RESPONSE_TIMEOUT = 10000\n\n/** @internal */\nexport const HEARTBEAT_INTERVAL = 1000\n\n/** @internal */\nexport const HANDSHAKE_INTERVAL = 500\n\n/**\n * @public\n */\nexport const MSG_RESPONSE = 'comlink/response'\n\n/**\n * @public\n */\nexport const MSG_HEARTBEAT = 'comlink/heartbeat'\n\n/** @internal */\nexport const MSG_DISCONNECT = 'comlink/disconnect'\n\n/** @internal */\nexport const MSG_HANDSHAKE_SYN = 'comlink/handshake/syn'\n\n/** @internal */\nexport const MSG_HANDSHAKE_SYN_ACK = 'comlink/handshake/syn-ack'\n\n/** @internal */\nexport const MSG_HANDSHAKE_ACK = 'comlink/handshake/ack'\n\n/** @internal */\nexport const HANDSHAKE_MSG_TYPES = [\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HANDSHAKE_ACK,\n] satisfies MessageType[]\n\n/** @internal */\nexport const INTERNAL_MSG_TYPES = [\n  MSG_RESPONSE,\n  MSG_DISCONNECT,\n  MSG_HEARTBEAT,\n  ...HANDSHAKE_MSG_TYPES,\n] satisfies MessageType[]\n","import {EMPTY, filter, fromEvent, map, take, takeUntil, type Observable} from 'rxjs'\nimport {v4 as uuid} from 'uuid'\nimport {\n  assign,\n  fromEventObservable,\n  sendTo,\n  setup,\n  type ActorRefFrom,\n  type AnyActorRef,\n} from 'xstate'\nimport {MSG_RESPONSE, RESPONSE_TIMEOUT} from './constants'\nimport type {Message, MessageData, MessageType, ProtocolMessage, ResponseMessage} from './types'\n\nconst throwOnEvent =\n  <T>(message?: string) =>\n  (source: Observable<T>) =>\n    source.pipe(\n      take(1),\n      map(() => {\n        throw new Error(message)\n      }),\n    )\n\n/**\n * @public\n */\nexport interface RequestMachineContext<S extends Message> {\n  connectionId: string\n  data: MessageData | undefined\n  domain: string\n  expectResponse: boolean\n  from: string\n  id: string\n  parentRef: AnyActorRef\n  resolvable: PromiseWithResolvers<S['response']> | undefined\n  response: S['response'] | null\n  responseTo: string | undefined\n  signal: AbortSignal | undefined\n  sources: Set<MessageEventSource>\n  targetOrigin: string\n  to: string\n  type: MessageType\n}\n\n/**\n * @public\n */\nexport type RequestActorRef<S extends Message> = ActorRefFrom<\n  ReturnType<typeof createRequestMachine<S>>\n>\n\n/**\n * @public\n */\nexport const createRequestMachine = <\n  S extends Message,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n>() => {\n  return setup({\n    types: {} as {\n      children: {\n        'listen for response': 'listen'\n      }\n      context: RequestMachineContext<S>\n      // @todo Should response types be specified?\n      events: {type: 'message'; data: ProtocolMessage<ResponseMessage>} | {type: 'abort'}\n      emitted:\n        | {type: 'request.failed'; requestId: string}\n        | {type: 'request.aborted'; requestId: string}\n        | {\n            type: 'request.success'\n            requestId: string\n            response: MessageData | null\n            responseTo: string | undefined\n          }\n      input: {\n        connectionId: string\n        data?: S['data']\n        domain: string\n        expectResponse?: boolean\n        from: string\n        parentRef: AnyActorRef\n        resolvable?: PromiseWithResolvers<S['response']>\n        responseTo?: string\n        signal?: AbortSignal\n        sources: Set<MessageEventSource> | MessageEventSource\n        targetOrigin: string\n        to: string\n        type: S['type']\n      }\n      output: {\n        requestId: string\n        response: S['response'] | null\n        responseTo: string | undefined\n      }\n    },\n    actors: {\n      listen: fromEventObservable(\n        ({\n          input,\n        }: {\n          input: {\n            requestId: string\n            sources: Set<MessageEventSource>\n            signal?: AbortSignal\n          }\n        }) => {\n          const abortSignal$ = input.signal\n            ? fromEvent(input.signal, 'abort').pipe(\n                throwOnEvent(`Request ${input.requestId} aborted`),\n              )\n            : EMPTY\n\n          const messageFilter = (event: MessageEvent<ProtocolMessage<ResponseMessage>>) =>\n            event.data?.type === MSG_RESPONSE &&\n            event.data?.responseTo === input.requestId &&\n            !!event.source &&\n            input.sources.has(event.source)\n\n          return fromEvent<MessageEvent<ProtocolMessage<ResponseMessage>>>(window, 'message').pipe(\n            filter(messageFilter),\n            take(input.sources.size),\n            takeUntil(abortSignal$),\n          )\n        },\n      ),\n    },\n    actions: {\n      'send message': ({context}, params: {message: ProtocolMessage}) => {\n        const {sources, targetOrigin} = context\n        const {message} = params\n\n        sources.forEach((source) => {\n          source.postMessage(message, {targetOrigin})\n        })\n      },\n      'on success': sendTo(\n        ({context}) => context.parentRef,\n        ({context, self}) => {\n          if (context.response) {\n            context.resolvable?.resolve(context.response)\n          }\n          return {\n            type: 'request.success',\n            requestId: self.id,\n            response: context.response,\n            responseTo: context.responseTo,\n          }\n        },\n      ),\n      'on fail': sendTo(\n        ({context}) => context.parentRef,\n        ({context, self}) => {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `Received no response to message '${context.type}' on client '${context.from}' (ID: '${context.id}').`,\n          )\n          context.resolvable?.reject(new Error('No response received'))\n          return {type: 'request.failed', requestId: self.id}\n        },\n      ),\n      'on abort': sendTo(\n        ({context}) => context.parentRef,\n        ({context, self}) => {\n          context.resolvable?.reject(new Error('Request aborted'))\n          return {type: 'request.aborted', requestId: self.id}\n        },\n      ),\n    },\n    guards: {\n      expectsResponse: ({context}) => context.expectResponse,\n    },\n    delays: {\n      initialTimeout: 0,\n      responseTimeout: RESPONSE_TIMEOUT,\n    },\n  }).createMachine({\n    /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAOlwgBswBiAD1gBd0GwT0AzFgJ2QNwdzoKAFVyowAewCuDItTRY8hUuSoBtAAwBdRKAAOE2P1wT8ukLUQBGAEwBWEgBYAnK+eOAzB7sB2DzY8rABoQAE9rDQc3V0cNTw8fAA4NHwBfVJCFHAJiElgwfAgCKGpNHSQQAyMBU3NLBDsrDxI7DTaAjQA2OOcNDxDwhHsNJx9Ou0TOq2cJxP9HdMyMbOU8gqL8ErUrcv1DY1qK+sbm1vaPLp6+gcRnGydo9wDGycWQLKVc9AB3dGNN6jiWCwdAwMrmKoHMxHRCJRKOEiJHwuZKBZwXKzBMKIGyYkhtAkXOweTqOHw2RJvD45Ug-P4CAH0JgsNicMA8LhwAz4fKicTSWTyZafWm-f5QcEVSE1aGgepwhFIlF9aYYrGDC4+JzEppjGzOUkeGbpDIgfASCBwczU5QQ-YyuqIAC0nRuCBd+IJXu9KSpwppZEoYDt1RMsosiEcNjdVjiJEeGisiSTHkcVgWpptuXyhWKIahjqGzi1BqRJINnVcdkcbuTLS9VYC8ISfsUAbp4vzDphCHJIyjBvJNlxNmRNexQ3sJGH43GPj8jWJrZWuXYfyoEC7YcLsbrgRsjkcvkmdgNbopVhIPhVfnsh8ClMz-tWsCkmEwcHgUvt257u8v+6Hse4xnhOdZnImVidPqCRNB4JqpEAA */\n    context: ({input}) => {\n      return {\n        connectionId: input.connectionId,\n        data: input.data,\n        domain: input.domain,\n        expectResponse: input.expectResponse ?? false,\n        from: input.from,\n        id: `msg-${uuid()}`,\n        parentRef: input.parentRef,\n        resolvable: input.resolvable,\n        response: null,\n        responseTo: input.responseTo,\n        signal: input.signal,\n        sources: input.sources instanceof Set ? input.sources : new Set([input.sources]),\n        targetOrigin: input.targetOrigin,\n        to: input.to,\n        type: input.type,\n      }\n    },\n    initial: 'idle',\n    on: {\n      abort: '.aborted',\n    },\n    states: {\n      idle: {\n        after: {\n          initialTimeout: [\n            {\n              target: 'sending',\n            },\n          ],\n        },\n      },\n      sending: {\n        entry: {\n          type: 'send message',\n          params: ({context}) => {\n            const {connectionId, data, domain, from, id, responseTo, to, type} = context\n            const message = {\n              connectionId,\n              data,\n              domain,\n              from,\n              id,\n              to,\n              type,\n              responseTo,\n            }\n            return {message}\n          },\n        },\n        always: [\n          {\n            guard: 'expectsResponse',\n            target: 'awaiting',\n          },\n          'success',\n        ],\n      },\n      awaiting: {\n        invoke: {\n          id: 'listen for response',\n          src: 'listen',\n          input: ({context}) => ({\n            requestId: context.id,\n            sources: context.sources,\n            signal: context.signal,\n          }),\n          onError: 'aborted',\n        },\n        after: {\n          responseTimeout: 'failed',\n        },\n        on: {\n          message: {\n            actions: assign({\n              response: ({event}) => event.data.data,\n              responseTo: ({event}) => event.data.responseTo,\n            }),\n            target: 'success',\n          },\n        },\n      },\n      failed: {\n        type: 'final',\n        entry: 'on fail',\n      },\n      success: {\n        type: 'final',\n        entry: 'on success',\n      },\n      aborted: {\n        type: 'final',\n        entry: 'on abort',\n      },\n    },\n    output: ({context, self}) => {\n      const output = {\n        requestId: self.id,\n        response: context.response,\n        responseTo: context.responseTo,\n      }\n      return output\n    },\n  })\n}\n\n// export const delayedRequestMachine = requestMachine.provide({\n//   delays: {\n//     initialTimeout: 500,\n//   },\n// })\n","import {v4 as uuid} from 'uuid'\nimport {\n  assertEvent,\n  assign,\n  createActor,\n  enqueueActions,\n  fromCallback,\n  raise,\n  setup,\n  stopChild,\n  type ActorRefFrom,\n  type EventObject,\n} from 'xstate'\nimport {createListenLogic, listenInputFromContext} from './common'\nimport {\n  DOMAIN,\n  HANDSHAKE_INTERVAL,\n  MSG_DISCONNECT,\n  MSG_HANDSHAKE_ACK,\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HEARTBEAT,\n  MSG_RESPONSE,\n} from './constants'\nimport {createRequestMachine, type RequestActorRef} from './request'\nimport type {\n  BufferAddedEmitEvent,\n  BufferFlushedEmitEvent,\n  Message,\n  MessageEmitEvent,\n  ProtocolMessage,\n  RequestData,\n  Status,\n  WithoutResponse,\n} from './types'\n\n/**\n * @public\n */\nexport type ChannelActorLogic<R extends Message, S extends Message> = ReturnType<\n  typeof createChannelMachine<R, S>\n>\n/**\n * @public\n */\nexport type ChannelActor<R extends Message, S extends Message> = ActorRefFrom<\n  ReturnType<typeof createChannelMachine<R, S>>\n>\n\n/**\n * @public\n */\nexport type Channel<R extends Message, S extends Message> = {\n  actor: ChannelActor<R, S>\n  connect: () => void\n  disconnect: () => void\n  id: string\n  name: string\n  machine: ReturnType<typeof createChannelMachine<R, S>>\n  on: <T extends R['type'], U extends Extract<R, {type: T}>>(\n    type: T,\n    handler: (event: U['data']) => Promise<U['response']> | U['response'],\n  ) => () => void\n  onStatus: (handler: (status: Status) => void) => () => void\n  post: (data: WithoutResponse<S>) => void\n  setTarget: (target: MessageEventSource) => void\n  start: () => () => void\n  stop: () => void\n  target: MessageEventSource | undefined\n}\n\n/**\n * @public\n */\nexport interface ChannelInput {\n  connectTo: string\n  domain?: string\n  heartbeat?: boolean\n  name: string\n  id?: string\n  target?: MessageEventSource\n  targetOrigin: string\n}\n\nconst sendBackAtInterval = fromCallback<\n  EventObject,\n  {event: EventObject; immediate?: boolean; interval: number}\n>(({sendBack, input}) => {\n  const send = () => {\n    sendBack(input.event)\n  }\n\n  if (input.immediate) {\n    send()\n  }\n\n  const interval = setInterval(send, input.interval)\n\n  return () => {\n    clearInterval(interval)\n  }\n})\n\n/**\n * @public\n */\nexport const createChannelMachine = <\n  R extends Message, // Receives\n  S extends Message, // Sends\n  V extends WithoutResponse<S> = WithoutResponse<S>,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n>() => {\n  const channelMachine = setup({\n    types: {} as {\n      children: {\n        'listen for handshake': 'listen'\n        'listen for messages': 'listen'\n        'send heartbeat': 'sendBackAtInterval'\n        'send syn': 'sendBackAtInterval'\n      }\n      context: {\n        buffer: Array<V>\n        connectionId: string\n        connectTo: string\n        domain: string\n        heartbeat: boolean\n        id: string\n        name: string\n        requests: Array<RequestActorRef<S>>\n        target: MessageEventSource | undefined\n        targetOrigin: string\n      }\n      emitted:\n        | BufferAddedEmitEvent<V>\n        | BufferFlushedEmitEvent<V>\n        | MessageEmitEvent<R>\n        | (R extends R ? {type: R['type']; message: ProtocolMessage<R>} : never)\n      events:\n        | {type: 'connect'}\n        | {type: 'disconnect'}\n        | {type: 'message.received'; message: MessageEvent<ProtocolMessage<R>>}\n        | {type: 'post'; data: V}\n        | {type: 'response'; respondTo: string; data: Pick<S, 'response'>}\n        | {type: 'request.aborted'; requestId: string}\n        | {type: 'request.failed'; requestId: string}\n        | {\n            type: 'request.success'\n            requestId: string\n            response: S['response'] | null\n            responseTo: string | undefined\n          }\n        | {type: 'request'; data: RequestData<S> | RequestData<S>[]}\n        | {type: 'syn'}\n        | {type: 'target.set'; target: MessageEventSource}\n      input: ChannelInput\n    },\n    actors: {\n      requestMachine: createRequestMachine<S>(),\n      listen: createListenLogic(),\n      sendBackAtInterval,\n    },\n    actions: {\n      'buffer message': enqueueActions(({enqueue}) => {\n        enqueue.assign({\n          buffer: ({event, context}) => {\n            assertEvent(event, 'post')\n            return [...context.buffer, event.data]\n          },\n        })\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'post')\n          return {\n            type: '_buffer.added',\n            message: event.data,\n          } satisfies BufferAddedEmitEvent<V>\n        })\n      }),\n      'create request': assign({\n        requests: ({context, event, self, spawn}) => {\n          assertEvent(event, 'request')\n          const arr = Array.isArray(event.data) ? event.data : [event.data]\n          const requests = arr.map((request) => {\n            const id = `req-${uuid()}`\n            return spawn('requestMachine', {\n              id,\n              input: {\n                connectionId: context.connectionId,\n                data: request.data,\n                domain: context.domain,\n                expectResponse: request.expectResponse,\n                from: context.name,\n                parentRef: self,\n                responseTo: request.responseTo,\n                sources: context.target!,\n                targetOrigin: context.targetOrigin,\n                to: context.connectTo,\n                type: request.type,\n              },\n            })\n          })\n          return [...context.requests, ...requests]\n        },\n      }),\n      'emit received message': enqueueActions(({enqueue}) => {\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'message.received')\n          return {\n            type: '_message',\n            message: event.message.data,\n          } satisfies MessageEmitEvent<R>\n        })\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'message.received')\n          const emit = {\n            type: event.message.data.type,\n            message: event.message.data,\n          }\n          return emit\n        })\n      }),\n      'flush buffer': enqueueActions(({enqueue}) => {\n        enqueue.raise(({context}) => ({\n          type: 'request',\n          data: context.buffer.map(({data, type}) => ({data, type})),\n        }))\n        enqueue.emit(({context}) => {\n          return {\n            type: '_buffer.flushed',\n            messages: context.buffer,\n          } satisfies BufferFlushedEmitEvent<V>\n        })\n        enqueue.assign({\n          buffer: [],\n        })\n      }),\n      'post': raise(({event}) => {\n        assertEvent(event, 'post')\n        return {\n          type: 'request' as const,\n          data: {\n            data: event.data.data,\n            expectResponse: true,\n            type: event.data.type,\n          },\n        }\n      }),\n      'remove request': enqueueActions(({context, enqueue, event}) => {\n        assertEvent(event, ['request.success', 'request.failed', 'request.aborted'])\n        stopChild(event.requestId)\n        enqueue.assign({requests: context.requests.filter(({id}) => id !== event.requestId)})\n      }),\n      'respond': raise(({event}) => {\n        assertEvent(event, 'response')\n        return {\n          type: 'request' as const,\n          data: {\n            data: event.data,\n            type: MSG_RESPONSE,\n            responseTo: event.respondTo,\n          },\n        }\n      }),\n      'send handshake ack': raise({\n        type: 'request',\n        data: {type: MSG_HANDSHAKE_ACK},\n      }),\n      'send disconnect': raise(() => {\n        return {\n          type: 'request' as const,\n          data: {type: MSG_DISCONNECT},\n        }\n      }),\n      'send handshake syn': raise({\n        type: 'request',\n        data: {type: MSG_HANDSHAKE_SYN},\n      }),\n      'set target': assign({\n        target: ({event}) => {\n          assertEvent(event, 'target.set')\n          return event.target\n        },\n      }),\n    },\n    guards: {\n      'has target': ({context}) => !!context.target,\n      'should send heartbeats': ({context}) => context.heartbeat,\n    },\n  }).createMachine({\n    /** @xstate-layout N4IgpgJg5mDOIC5QGMAWBDAdpsAbAxAC7oBOMhAdLGIQNoAMAuoqAA4D2sAloV+5ixAAPRAHZRAJgoAWABz0ArHICMy2QGZZCgJwAaEAE9EE+tIrb6ANgkLl46fTuj1AXxf60WHARJgAjgCucJSwAcjIcLAMzEggHNy8-IIiCKLS2hQS6qb2yurisrL6RgjK9LIyCuqq0g7WstZuHhjYePi+gcEUAGboXLiQ0YLxPHwCsSmiCgoykpayDtqS6trqxYjKEk0gnq24FFwQA-jI-DjIdEzDnKNJExuOZpZ12eq29OrSCuupypYUojUaTKCnm5Wk2123gORzA+HilxibBuiXGoBSGnUAIU4gU9FWamUtR+lmUM1EllBEkslMUEnpkJa0JaEFgGAA1lxMFB8LADJghrERqjkhtshk3mTtNo5OpqpYfqCKhTptoqpY1WUtu4dky8BQWWz0Jzue1-EFYIjrgkxqLSupqRRPpoPqJtLI0hIioZENJJE7NnJ8ZYHVk1YyvPrDRyuTyEYLkTa7uixVlMh81KGFhS1j6EPkZlpVjTphr8mkI3sDVhWTHTQBbSLoGAUXwRLgAN0GVyFKNt91KimUFEKXvKC2s9R+6X+jipnzJeSqEJ1UKjNaNJp5EC4sFOrQuCbifeTwg2cgoym0RPxDtqkj0eaB9Ao8zSolMEivZVcq71+33c5CEgeFOCtXskzRM8EDxKRpmkSw3QJbQsmpH5tHmV8JHSbJpDsakV2aSMALOMALhAjoLXAxNbiglI-SxWw1Vw0QNDw0Qfg9KQ7EJSxHHxApK2hQCyOAiAzVgDhMGoI9hX7FMEHSF8cWkelpHURCbBsb481xAEgT9BQJCmWQsiE-URPI8TG1gWBmzAVsyLATtuyRY9ILtWoKmlL82Kqd0tAVJ91LMHFZDKIkVlkNVZHMkiDzE-Adz3UjDx7GiRQHCKnheD53k+HSSkDDIwpBVTqQwuKKEssSDTAUhCAAI3qyg0DIrd8Fkk86MQUMnVM+RynoegTDJH48hGp0vR-FDRqqKqasgOqGua9AQjATAd1NSiul6fpXOtWi7Wy19cslD4vnG7IX3oVjVDUVYEJQqrksW8SdstLqPKy0wKgG1RhtMWogqKhoMjkWp6XxUyFBe3c3tAz70vco6fq+V8PTkGUFzdQqNnELEM2yClrwwzQ4ZShKQJqr7UYU98AS0W9pT4z5pHG0yXwMkNNTyGk3B1TB2AgOBBDXXBDsyhSFG9EovQqN5i1JeRcKqw4Bkl+ToMx8x0j+EaqQ9XMSkBURMgMkEwQWKro2NWNNdPFJAzN0lJGM4slDxhBEJfXyplBd03wW1KxIdnrBxBh4JAyW75C8rJpmDqmIGWkgmpasPjqUcaHooMLHA0uU1UkJOgKW1B6rT1bWor5At0zgcTAkK7hrz1irB0D8cW0UvRPLyv07WqgNq2qAG+l9SnXUz0UOXD5xuMs3Y4+DVJBX7UiKrV6Q8gcfoJO54rFefLLqfJYX1WKYNLxL4NO1NwgA */\n    id: 'channel',\n    context: ({input}) => ({\n      id: input.id || `${input.name}-${uuid()}`,\n      buffer: [],\n      connectionId: `cnx-${uuid()}`,\n      connectTo: input.connectTo,\n      domain: input.domain ?? DOMAIN,\n      heartbeat: input.heartbeat ?? false,\n      name: input.name,\n      requests: [],\n      target: input.target,\n      targetOrigin: input.targetOrigin,\n    }),\n    on: {\n      'target.set': {\n        actions: 'set target',\n      },\n      'request.success': {\n        actions: 'remove request',\n      },\n      'request.failed': {\n        actions: 'remove request',\n      },\n    },\n    initial: 'idle',\n    states: {\n      idle: {\n        on: {\n          connect: {\n            target: 'handshaking',\n            guard: 'has target',\n          },\n          post: {\n            actions: 'buffer message',\n          },\n        },\n      },\n      handshaking: {\n        id: 'handshaking',\n        invoke: [\n          {\n            id: 'send syn',\n            src: 'sendBackAtInterval',\n            input: () => ({\n              event: {type: 'syn'},\n              interval: HANDSHAKE_INTERVAL,\n              immediate: true,\n            }),\n          },\n          {\n            id: 'listen for handshake',\n            src: 'listen',\n            input: (input) =>\n              listenInputFromContext({\n                include: MSG_HANDSHAKE_SYN_ACK,\n                count: 1,\n              })(input),\n            /* Below would maybe be more readable than transitioning to\n          'connected' on 'message', and 'ack' on exit but having onDone when\n          using passing invocations currently breaks XState Editor */\n            // onDone: {\n            //   target: 'connected',\n            //   actions: 'ack',\n            // },\n          },\n        ],\n        on: {\n          'syn': {\n            actions: 'send handshake syn',\n          },\n          'request': {\n            actions: 'create request',\n          },\n          'post': {\n            actions: 'buffer message',\n          },\n          'message.received': {\n            target: 'connected',\n          },\n          'disconnect': {\n            target: 'disconnected',\n          },\n        },\n        exit: 'send handshake ack',\n      },\n      connected: {\n        entry: 'flush buffer',\n        invoke: {\n          id: 'listen for messages',\n          src: 'listen',\n          input: listenInputFromContext({\n            exclude: [MSG_RESPONSE, MSG_HEARTBEAT],\n          }),\n        },\n        on: {\n          'post': {\n            actions: 'post',\n          },\n          'request': {\n            actions: 'create request',\n          },\n          'response': {\n            actions: 'respond',\n          },\n          'message.received': {\n            actions: 'emit received message',\n          },\n          'disconnect': {\n            target: 'disconnected',\n          },\n        },\n        initial: 'heartbeat',\n        states: {\n          heartbeat: {\n            initial: 'checking',\n            states: {\n              checking: {\n                always: {\n                  guard: 'should send heartbeats',\n                  target: 'sending',\n                },\n              },\n              sending: {\n                on: {\n                  'request.failed': {\n                    target: '#handshaking',\n                  },\n                },\n                invoke: {\n                  id: 'send heartbeat',\n                  src: 'sendBackAtInterval',\n                  input: () => ({\n                    event: {type: 'post', data: {type: MSG_HEARTBEAT, data: undefined}},\n                    interval: 2000,\n                    immediate: false,\n                  }),\n                },\n              },\n            },\n          },\n        },\n      },\n      disconnected: {\n        id: 'disconnected',\n        entry: 'send disconnect',\n        on: {\n          request: {\n            actions: 'create request',\n          },\n          post: {\n            actions: 'buffer message',\n          },\n          connect: {\n            target: 'handshaking',\n            guard: 'has target',\n          },\n        },\n      },\n    },\n  })\n\n  return channelMachine\n}\n\n/**\n * @public\n */\nexport const createChannel = <R extends Message, S extends Message>(\n  input: ChannelInput,\n  machine: ChannelActorLogic<R, S> = createChannelMachine<R, S>(),\n): Channel<R, S> => {\n  const id = input.id || `${input.name}-${uuid()}`\n  const actor = createActor(machine, {\n    input: {...input, id},\n  })\n\n  const on = <T extends R['type'], U extends Extract<R, {type: T}>>(\n    type: T,\n    handler: (event: U['data']) => Promise<U['response']> | U['response'],\n  ) => {\n    const {unsubscribe} = actor.on(\n      // @ts-expect-error @todo `type` typing\n      type,\n      async (event: {type: T; message: ProtocolMessage<U>}) => {\n        const response = await handler(event.message.data)\n        if (response) {\n          actor.send({type: 'response', respondTo: event.message.id, data: response})\n        }\n      },\n    )\n    return unsubscribe\n  }\n\n  const connect = () => {\n    actor.send({type: 'connect'})\n  }\n\n  const disconnect = () => {\n    actor.send({type: 'disconnect'})\n  }\n\n  const onStatus = (handler: (status: Status) => void) => {\n    const currentSnapshot = actor.getSnapshot()\n    let currentStatus: Status =\n      typeof currentSnapshot.value === 'string'\n        ? currentSnapshot.value\n        : Object.keys(currentSnapshot.value)[0]\n\n    const {unsubscribe} = actor.subscribe((state) => {\n      const status: Status =\n        typeof state.value === 'string' ? state.value : Object.keys(state.value)[0]\n      if (currentStatus !== status) {\n        currentStatus = status\n        handler(status)\n      }\n    })\n    return unsubscribe\n  }\n\n  const setTarget = (target: MessageEventSource) => {\n    actor.send({type: 'target.set', target})\n  }\n\n  const post = (data: WithoutResponse<S>) => {\n    actor.send({type: 'post', data})\n  }\n\n  const stop = () => {\n    actor.stop()\n  }\n\n  const start = () => {\n    actor.start()\n    return stop\n  }\n\n  return {\n    actor,\n    connect,\n    disconnect,\n    id,\n    name: input.name,\n    machine,\n    on,\n    onStatus,\n    post,\n    setTarget,\n    start,\n    stop,\n    get target() {\n      return actor.getSnapshot().context.target\n    },\n  }\n}\n","import {\n  createChannel,\n  createChannelMachine,\n  type Channel,\n  type ChannelActorLogic,\n  type ChannelInput,\n} from './channel'\nimport {type InternalEmitEvent, type Message, type StatusEvent, type WithoutResponse} from './types'\n\n/**\n * @public\n */\nexport type ConnectionInput = Omit<ChannelInput, 'target' | 'targetOrigin'>\n\n/**\n * @public\n */\nexport interface ConnectionInstance<R extends Message, S extends Message> {\n  on: <T extends R['type'], U extends Extract<R, {type: T}>>(\n    type: T,\n    handler: (event: U['data']) => Promise<U['response']> | U['response'],\n  ) => () => void\n  onInternalEvent: <\n    T extends InternalEmitEvent<R, S>['type'],\n    U extends Extract<InternalEmitEvent<R, S>, {type: T}>,\n  >(\n    type: T,\n    handler: (event: U) => void,\n  ) => () => void\n  onStatus: (handler: (event: StatusEvent) => void) => void\n  post: (data: WithoutResponse<S>) => void\n  start: () => () => void\n  stop: () => void\n}\n\n/**\n * @public\n */\nexport interface Controller {\n  addTarget: (target: MessageEventSource) => () => void\n  createConnection: <R extends Message, S extends Message>(\n    input: ConnectionInput,\n    machine?: ChannelActorLogic<R, S>,\n  ) => ConnectionInstance<R, S>\n  destroy: () => void\n}\n\ninterface Connection<\n  R extends Message = Message,\n  S extends Message = Message,\n  T extends InternalEmitEvent<R, S>['type'] = InternalEmitEvent<R, S>['type'],\n> {\n  input: ConnectionInput\n  channels: Set<Channel<R, S>>\n  internalEventSubscribers: Set<{\n    type: T\n    handler: (event: Extract<InternalEmitEvent<R, S>, {type: T}>) => void\n    unsubscribers: Array<() => void>\n  }>\n  machine: ChannelActorLogic<R, S>\n  statusSubscribers: Set<{\n    handler: (event: StatusEvent) => void\n    unsubscribers: Array<() => void>\n  }>\n  subscribers: Set<{\n    type: R['type']\n    handler: (event: R['data']) => Promise<R['response']> | R['response']\n    unsubscribers: Array<() => void>\n  }>\n}\n\nconst noop = () => {}\n\n/**\n * @public\n */\nexport const createController = (input: {targetOrigin: string}): Controller => {\n  const {targetOrigin} = input\n  const targets = new Set<MessageEventSource>()\n  const connections = new Set<Connection>()\n\n  const addTarget = (target: MessageEventSource) => {\n    // If the target has already been added, return just a noop cleanup\n    if (targets.has(target)) {\n      return noop\n    }\n\n    if (!targets.size || !connections.size) {\n      targets.add(target)\n\n      // If there are existing connections, set the target on all existing\n      // channels, and trigger a connection event\n      connections.forEach((connection) => {\n        connection.channels.forEach((channel) => {\n          channel.setTarget(target)\n          channel.connect()\n        })\n      })\n      // We perform a 'soft' cleanup here: disconnect only as we want to\n      // maintain at least one live channel per connection\n      return () => {\n        targets.delete(target)\n        connections.forEach((connection) => {\n          connection.channels.forEach((channel) => {\n            if (channel.target === target) {\n              channel.disconnect()\n            }\n          })\n        })\n      }\n    }\n\n    targets.add(target)\n\n    // Maintain a list of channels to cleanup\n    const targetChannels = new Set<Channel<Message, Message>>()\n\n    // If we already have targets and connections, we need to create new\n    // channels for each source with all the associated subscribers.\n    connections.forEach((connection) => {\n      const channel = createChannel(\n        {\n          ...connection.input,\n          target,\n          targetOrigin,\n        },\n        connection.machine,\n      )\n\n      targetChannels.add(channel)\n      connection.channels.add(channel)\n\n      connection.subscribers.forEach(({type, handler, unsubscribers}) => {\n        unsubscribers.push(channel.on(type, handler))\n      })\n      connection.internalEventSubscribers.forEach(({type, handler, unsubscribers}) => {\n        // @ts-expect-error @todo\n        unsubscribers.push(channel.actor.on(type, handler).unsubscribe)\n      })\n      connection.statusSubscribers.forEach(({handler, unsubscribers}) => {\n        unsubscribers.push(channel.onStatus((status) => handler({channel: channel.id, status})))\n      })\n\n      channel.start()\n      channel.connect()\n    })\n\n    // We perform a more 'aggressive' cleanup here as we do not need to maintain\n    // these 'duplicate' channels: disconnect, stop, and delete\n    return () => {\n      targets.delete(target)\n      targetChannels.forEach((channel) => {\n        cleanupChannel(channel)\n        connections.forEach((connection) => {\n          connection.channels.delete(channel)\n        })\n      })\n    }\n  }\n\n  const cleanupChannel: (channel: Channel<Message, Message>) => void = (channel) => {\n    channel.disconnect()\n    // Necessary to allow disconnect messages to be sent before the channel\n    // actor is stopped\n    setTimeout(() => {\n      channel.stop()\n    }, 0)\n  }\n\n  const createConnection = <R extends Message, S extends Message>(\n    input: ConnectionInput,\n    machine: ChannelActorLogic<R, S> = createChannelMachine<R, S>(),\n  ): ConnectionInstance<R, S> => {\n    const connection: Connection<R, S> = {\n      channels: new Set(),\n      input,\n      internalEventSubscribers: new Set(),\n      machine,\n      statusSubscribers: new Set(),\n      subscribers: new Set(),\n    }\n\n    // @ts-expect-error @todo @help\n    connections.add(connection)\n\n    const {channels, internalEventSubscribers, statusSubscribers, subscribers} = connection\n\n    if (targets.size) {\n      // If targets have already been added, create a channel for each target\n      targets.forEach((target) => {\n        const channel = createChannel<R, S>(\n          {\n            ...input,\n            target,\n            targetOrigin,\n          },\n          machine,\n        )\n        channels.add(channel)\n      })\n    } else {\n      // If targets have not been added yet, create a channel without a target\n      const channel = createChannel<R, S>({...input, targetOrigin}, machine)\n      channels.add(channel)\n    }\n\n    const post: ConnectionInstance<R, S>['post'] = (data) => {\n      channels.forEach((channel) => {\n        channel.post(data)\n      })\n    }\n\n    const on: ConnectionInstance<R, S>['on'] = (type, handler) => {\n      const unsubscribers: Array<() => void> = []\n      channels.forEach((channel) => {\n        unsubscribers.push(channel.on(type, handler))\n      })\n      const subscriber = {type, handler, unsubscribers}\n      subscribers.add(subscriber)\n      return () => {\n        unsubscribers.forEach((unsub) => unsub())\n        subscribers.delete(subscriber)\n      }\n    }\n\n    const onInternalEvent = <\n      T extends InternalEmitEvent<R, S>['type'],\n      U extends Extract<InternalEmitEvent<R, S>, {type: T}>,\n    >(\n      type: T,\n      handler: (event: U) => void,\n    ) => {\n      const unsubscribers: Array<() => void> = []\n      channels.forEach((channel) => {\n        // @ts-expect-error @todo @help\n        unsubscribers.push(channel.actor.on(type, handler).unsubscribe)\n      })\n      const subscriber = {type, handler, unsubscribers}\n      // @ts-expect-error @todo @help\n      internalEventSubscribers.add(subscriber)\n      return () => {\n        unsubscribers.forEach((unsub) => unsub())\n        // @ts-expect-error @todo @help\n        internalEventSubscribers.delete(subscriber)\n      }\n    }\n\n    const onStatus = (handler: (event: StatusEvent) => void) => {\n      const unsubscribers: Array<() => void> = []\n      channels.forEach((channel) => {\n        unsubscribers.push(channel.onStatus((status) => handler({channel: channel.id, status})))\n      })\n      const subscriber = {handler, unsubscribers}\n      statusSubscribers.add(subscriber)\n      return () => {\n        unsubscribers.forEach((unsub) => unsub())\n        statusSubscribers.delete(subscriber)\n      }\n    }\n\n    const stop = () => {\n      channels.forEach((channel) => {\n        channel.disconnect()\n        channel.stop()\n      })\n    }\n\n    const start = () => {\n      channels.forEach((channel) => {\n        channel.start()\n        channel.connect()\n      })\n\n      return stop\n    }\n\n    return {\n      on,\n      onInternalEvent,\n      onStatus,\n      post,\n      start,\n      stop,\n    }\n  }\n\n  const destroy = () => {\n    connections.forEach(({channels}) => {\n      channels.forEach((channel) => {\n        cleanupChannel(channel)\n        channels.delete(channel)\n      })\n    })\n  }\n\n  return {\n    addTarget,\n    createConnection,\n    destroy,\n  }\n}\n","import {v4 as uuid} from 'uuid'\nimport {\n  assertEvent,\n  assign,\n  createActor,\n  emit,\n  enqueueActions,\n  raise,\n  setup,\n  stopChild,\n  type ActorRefFrom,\n} from 'xstate'\nimport {createListenLogic, listenInputFromContext} from './common'\nimport {\n  DOMAIN,\n  MSG_DISCONNECT,\n  MSG_HANDSHAKE_ACK,\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HEARTBEAT,\n  MSG_RESPONSE,\n} from './constants'\nimport {createRequestMachine, type RequestActorRef} from './request'\nimport type {\n  BufferAddedEmitEvent,\n  BufferFlushedEmitEvent,\n  HeartbeatEmitEvent,\n  HeartbeatMessage,\n  Message,\n  MessageEmitEvent,\n  ProtocolMessage,\n  RequestData,\n  Status,\n  WithoutResponse,\n} from './types'\n\n/**\n * @public\n */\nexport interface NodeInput {\n  name: string\n  connectTo: string\n  domain?: string\n}\n\n/**\n * @public\n */\nexport type NodeActorLogic<R extends Message, S extends Message> = ReturnType<\n  typeof createNodeMachine<R, S>\n>\n\n/**\n * @public\n */\nexport type NodeActor<R extends Message, S extends Message> = ActorRefFrom<NodeActorLogic<R, S>>\n\n/**\n * @public\n */\nexport type Node<R extends Message, S extends Message> = {\n  actor: NodeActor<R, S>\n  fetch: <const T extends S['type'], U extends WithoutResponse<S>>(\n    data: U,\n    options?: {signal?: AbortSignal},\n  ) => S extends U ? (S['type'] extends T ? Promise<S['response']> : never) : never\n  machine: NodeActorLogic<R, S>\n  on: <T extends R['type'], U extends Extract<R, {type: T}>>(\n    type: T,\n    handler: (event: U['data']) => U['response'],\n  ) => () => void\n  onStatus: (handler: (status: Status) => void) => () => void\n  post: (data: WithoutResponse<S>) => void\n  start: () => () => void\n  stop: () => void\n}\n\n/**\n * @public\n */\nexport const createNodeMachine = <\n  R extends Message, // Receives\n  S extends Message, // Sends\n  V extends WithoutResponse<S> = WithoutResponse<S>,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n>() => {\n  const nodeMachine = setup({\n    types: {} as {\n      children: {\n        'listen for disconnect': 'listen'\n        'listen for handshake ack': 'listen'\n        'listen for handshake syn': 'listen'\n        'listen for heartbeat': 'listen'\n        'listen for messages': 'listen'\n      }\n      context: {\n        buffer: Array<{\n          data: V\n          resolvable?: PromiseWithResolvers<S['response']>\n          signal?: AbortSignal\n        }>\n        connectionId: string | null\n        connectTo: string\n        domain: string\n        // The handshake buffer is a workaround to maintain backwards\n        // compatibility with the Sanity channels package, which may incorrectly\n        // send buffered messages _before_ it completes the handshake (i.e.\n        // sends an ack message). It should be removed in the next major.\n        handshakeBuffer: Array<{\n          type: 'message.received'\n          message: MessageEvent<ProtocolMessage<R>>\n        }>\n        name: string\n        requests: Array<RequestActorRef<S>>\n        target: MessageEventSource | undefined\n        targetOrigin: string | null\n      }\n      emitted:\n        | BufferAddedEmitEvent<V>\n        | BufferFlushedEmitEvent<V>\n        | HeartbeatEmitEvent\n        | MessageEmitEvent<R>\n        | (R extends R ? {type: R['type']; message: ProtocolMessage<R>} : never)\n      events:\n        | {type: 'heartbeat.received'; message: MessageEvent<ProtocolMessage<HeartbeatMessage>>}\n        | {type: 'message.received'; message: MessageEvent<ProtocolMessage<R>>}\n        | {\n            type: 'post'\n            data: V\n            resolvable?: PromiseWithResolvers<S['response']>\n            signal?: AbortSignal\n          }\n        | {type: 'request.aborted'; requestId: string}\n        | {type: 'request.failed'; requestId: string}\n        | {\n            type: 'request.success'\n            requestId: string\n            response: S['response'] | null\n            responseTo: string | undefined\n          }\n        | {type: 'request'; data: RequestData<S> | RequestData<S>[]} // @todo align with 'post' type\n      input: NodeInput\n    },\n    actors: {\n      requestMachine: createRequestMachine<S>(),\n      listen: createListenLogic(),\n    },\n    actions: {\n      'buffer incoming message': assign({\n        handshakeBuffer: ({event, context}) => {\n          assertEvent(event, 'message.received')\n          return [...context.handshakeBuffer, event]\n        },\n      }),\n      'buffer message': enqueueActions(({enqueue}) => {\n        enqueue.assign({\n          buffer: ({event, context}) => {\n            assertEvent(event, 'post')\n            return [\n              ...context.buffer,\n              {\n                data: event.data,\n                resolvable: event.resolvable,\n                signal: event.signal,\n              },\n            ]\n          },\n        })\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'post')\n          return {\n            type: '_buffer.added',\n            message: event.data,\n          } satisfies BufferAddedEmitEvent<V>\n        })\n      }),\n      'create request': assign({\n        requests: ({context, event, self, spawn}) => {\n          assertEvent(event, 'request')\n          const arr = Array.isArray(event.data) ? event.data : [event.data]\n          const requests = arr.map((request) => {\n            const id = `req-${uuid()}`\n            return spawn('requestMachine', {\n              id,\n              input: {\n                connectionId: context.connectionId!,\n                data: request.data,\n                domain: context.domain!,\n                expectResponse: request.expectResponse,\n                from: context.name,\n                parentRef: self,\n                resolvable: request.resolvable,\n                responseTo: request.responseTo,\n                sources: context.target!,\n                targetOrigin: context.targetOrigin!,\n                to: context.connectTo,\n                type: request.type,\n                signal: request.signal,\n              },\n            })\n          })\n          return [...context.requests, ...requests]\n        },\n      }),\n      'emit heartbeat': emit(() => {\n        return {\n          type: '_heartbeat',\n        } satisfies HeartbeatEmitEvent\n      }),\n      'emit received message': enqueueActions(({enqueue}) => {\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'message.received')\n          return {\n            type: '_message',\n            message: event.message.data,\n          } satisfies MessageEmitEvent<R>\n        })\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'message.received')\n          const emit = {\n            type: event.message.data.type,\n            message: event.message.data,\n          }\n          return emit\n        })\n      }),\n      'flush buffer': enqueueActions(({enqueue}) => {\n        enqueue.raise(({context}) => ({\n          type: 'request',\n          data: context.buffer.map(({data, resolvable, signal}) => ({\n            data: data.data,\n            type: data.type,\n            expectResponse: resolvable ? true : false,\n            resolvable,\n            signal,\n          })),\n        }))\n        enqueue.emit(({context}) => {\n          return {\n            type: '_buffer.flushed',\n            messages: context.buffer.map(({data}) => data),\n          } satisfies BufferFlushedEmitEvent<V>\n        })\n        enqueue.assign({\n          buffer: [],\n        })\n      }),\n      'flush handshake buffer': enqueueActions(({context, enqueue}) => {\n        context.handshakeBuffer.forEach((event) => enqueue.raise(event))\n        enqueue.assign({\n          handshakeBuffer: [],\n        })\n      }),\n      'post': raise(({event}) => {\n        assertEvent(event, 'post')\n        return {\n          type: 'request' as const,\n          data: {\n            data: event.data.data,\n            expectResponse: event.resolvable ? true : false,\n            type: event.data.type,\n            resolvable: event.resolvable,\n            signal: event.signal,\n          },\n        }\n      }),\n      'remove request': enqueueActions(({context, enqueue, event}) => {\n        assertEvent(event, ['request.success', 'request.failed', 'request.aborted'])\n        stopChild(event.requestId)\n        enqueue.assign({requests: context.requests.filter(({id}) => id !== event.requestId)})\n      }),\n      'send response': raise(({event}) => {\n        assertEvent(event, ['message.received', 'heartbeat.received'])\n        return {\n          type: 'request' as const,\n          data: {\n            type: MSG_RESPONSE,\n            responseTo: event.message.data.id,\n            data: undefined,\n          },\n        }\n      }),\n      'send handshake syn ack': raise({\n        type: 'request',\n        data: {type: MSG_HANDSHAKE_SYN_ACK},\n      }),\n      'set connection config': assign({\n        connectionId: ({event}) => {\n          assertEvent(event, 'message.received')\n          return event.message.data.connectionId\n        },\n        target: ({event}) => {\n          assertEvent(event, 'message.received')\n          return event.message.source || undefined\n        },\n        targetOrigin: ({event}) => {\n          assertEvent(event, 'message.received')\n          return event.message.origin\n        },\n      }),\n    },\n    guards: {\n      hasSource: ({context}) => context.target !== null,\n    },\n  }).createMachine({\n    /** @xstate-layout N4IgpgJg5mDOIC5QDsD2EwGIBOYCOArnAC4B0sBAxpXLANoAMAuoqAA6qwCWxXqyrEAA9EAVgYAWUgEYJDUQA4JAZmUSJC0coDsAGhABPRNIYLSErdOkBOAGzbx227YUBfV-rQYc+IrDIAZgCGXAA2kIwsSCAc3Lz8giIIoiakqgBMDKbp2tYS0srp+kYI0ununuhgpFwQ4ZgQ-NVcyABuqADW1V7NdWAILe2UQfHIkZGCsTx8AtFJ6aKipAzWOtrpC7Z5BUWGiNoK6aS26RLW2tLaqkqqFSA9NX2YALa0QTCkuDRcrRHMk5xpgk5ogJLZSNZIVDoVCFLZiohbIVSLkXLZRHZDgxbHcHrV6rFiBNolNRolEVJbCsdGUzsoyhiEcllOC1DowelVmVrOUPPcqqQABZBZAQWDCjotKANJo1NqdboC4Wi8VBSXIKADeXDUbjf4kwFkkEILbg8RZMHKOzWKzKJkHJa086Xa4qZS4pUisUSqU+QgkYnsQ0zcnJaRLDbpZwKNQSBYspm2MEyC5KTnaDSSd18h7K71q32EwMxYPA0BJFLKY5yZxIrKSURM0RnFHSBTrQqQ9babQejBCr2q9XSiBcWCUfjIMCUIn6oNxEPGtTWFFR0RUy7iGzt+3Ip0XURXVZKPvVCfIKczyB+vyzqLzoGzcuIG0MGTyCztjRtjaJjbHVMNAUTdu1PUhz0vYhryLOcSwXMthBfK0ZGsLQGBZekCi0Jso1IdI23WG04zOE4wIg6coIgBox3Imdi1JRdnxNOxSHNSQkWtW0mTjMxMQ7fDzgcbNKn7WjKJeN4Pi+MAfj+e84MfUMFHbZZwxOHZNDyO09gQOQjmAhZJCM9IMjIycKOvQUwCCbBiAAI2sshpNkiB6NLJ9EIQBQbWOdJlMhYCUjbJkchXGsFmsJQMVsWl3BzKp4GiHoAXgjykgAWmkZZ6xy3LZF2EobCy6xsQWJQ42kE4FjA-EwBSxTjSRUhDgqkzgO2BxdykU4AvXFQ-KjMC8yHKV6qNJi6WOdcypcZsXGxe0JG0XySKjM5lKsMyLwsiAxsYzylDfONznUEqrmi+1ThkHqXDONbULi1wgA */\n    id: 'node',\n    context: ({input}) => ({\n      buffer: [],\n      connectionId: null,\n      connectTo: input.connectTo,\n      domain: input.domain ?? DOMAIN,\n      handshakeBuffer: [],\n      name: input.name,\n      requests: [],\n      target: undefined,\n      targetOrigin: null,\n    }),\n    on: {\n      'request.success': {\n        actions: 'remove request',\n      },\n      'request.failed': {\n        actions: 'remove request',\n      },\n      'request.aborted': {\n        actions: 'remove request',\n      },\n    },\n    initial: 'idle',\n    states: {\n      idle: {\n        invoke: {\n          id: 'listen for handshake syn',\n          src: 'listen',\n          input: listenInputFromContext({\n            include: MSG_HANDSHAKE_SYN,\n            count: 1,\n          }),\n          onDone: {\n            target: 'handshaking',\n            guard: 'hasSource',\n          },\n        },\n        on: {\n          'message.received': {\n            actions: 'set connection config',\n          },\n          'post': {\n            actions: 'buffer message',\n          },\n        },\n      },\n      handshaking: {\n        entry: 'send handshake syn ack',\n        invoke: [\n          {\n            id: 'listen for handshake ack',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_HANDSHAKE_ACK,\n              count: 1,\n              // Override the default `message.received` responseType to prevent\n              // buffering the ack message. We transition to the connected state\n              // using onDone instead of listening to this event using `on`\n              responseType: 'handshake.complete',\n            }),\n            onDone: 'connected',\n          },\n          {\n            id: 'listen for disconnect',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_DISCONNECT,\n              count: 1,\n              responseType: 'disconnect',\n            }),\n          },\n          {\n            id: 'listen for messages',\n            src: 'listen',\n            input: listenInputFromContext({\n              exclude: [MSG_DISCONNECT, MSG_HANDSHAKE_ACK, MSG_HEARTBEAT, MSG_RESPONSE],\n            }),\n          },\n        ],\n        on: {\n          'request': {\n            actions: 'create request',\n          },\n          'post': {\n            actions: 'buffer message',\n          },\n          'message.received': {\n            actions: 'buffer incoming message',\n          },\n          'disconnect': {\n            target: 'idle',\n          },\n        },\n      },\n      connected: {\n        entry: ['flush handshake buffer', 'flush buffer'],\n        invoke: [\n          {\n            id: 'listen for messages',\n            src: 'listen',\n            input: listenInputFromContext({\n              exclude: [MSG_RESPONSE, MSG_HEARTBEAT],\n            }),\n          },\n          {\n            id: 'listen for heartbeat',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_HEARTBEAT,\n              responseType: 'heartbeat.received',\n            }),\n          },\n          {\n            id: 'listen for disconnect',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_DISCONNECT,\n              count: 1,\n              responseType: 'disconnect',\n            }),\n          },\n        ],\n        on: {\n          'request': {\n            actions: 'create request',\n          },\n          'post': {\n            actions: 'post',\n          },\n          'disconnect': {\n            target: 'idle',\n          },\n          'message.received': {\n            actions: ['send response', 'emit received message'],\n          },\n          'heartbeat.received': {\n            actions: ['send response', 'emit heartbeat'],\n          },\n        },\n      },\n    },\n  })\n  return nodeMachine\n}\n\n/**\n * @public\n */\nexport const createNode = <R extends Message, S extends Message>(\n  input: NodeInput,\n  machine: NodeActorLogic<R, S> = createNodeMachine<R, S>(),\n): Node<R, S> => {\n  const actor = createActor(machine, {\n    input,\n  })\n\n  const on = <T extends R['type'], U extends Extract<R, {type: T}>>(\n    type: T,\n    handler: (event: U['data']) => U['response'],\n  ) => {\n    const {unsubscribe} = actor.on(\n      // @ts-expect-error @todo `type` typing\n      type,\n      (event: {type: T; message: ProtocolMessage<U>}) => {\n        handler(event.message.data)\n      },\n    )\n    return unsubscribe\n  }\n\n  const onStatus = (handler: (status: Status) => void) => {\n    const snapshot = actor.getSnapshot()\n    let currentStatus: Status =\n      typeof snapshot.value === 'string' ? snapshot.value : Object.keys(snapshot.value)[0]\n\n    const {unsubscribe} = actor.subscribe((state) => {\n      const status: Status =\n        typeof state.value === 'string' ? state.value : Object.keys(state.value)[0]\n      if (currentStatus !== status) {\n        currentStatus = status\n        handler(status)\n      }\n    })\n    return unsubscribe\n  }\n\n  const post = (data: WithoutResponse<S>) => {\n    actor.send({type: 'post', data})\n  }\n\n  const fetch = (data: WithoutResponse<S>, options?: {signal?: AbortSignal}) => {\n    const resolvable = Promise.withResolvers<S['response']>()\n    actor.send({\n      type: 'post',\n      data,\n      resolvable,\n      signal: options?.signal,\n    })\n    return resolvable.promise as never\n  }\n\n  const stop = () => {\n    actor.stop()\n  }\n\n  const start = () => {\n    actor.start()\n    return stop\n  }\n\n  return {\n    actor,\n    fetch,\n    machine,\n    on,\n    onStatus,\n    post,\n    start,\n    stop,\n  }\n}\n"],"names":["v4","fromEventObservable","setup","sendTo","assign","fromCallback","enqueueActions","assertEvent","raise","stopChild","createActor","emit","defer","fromEvent","map","pipe","filter","bufferCount","concatMap","take","EMPTY","takeUntil","listenInputFromContext","config","context","count","include","exclude","responseType","domain","from","connectTo","Array","isArray","target","to","name","messageEvents$","window","createListenLogic","compatMap","input","event","data","length","includes","type","source","listenFilter","message","arr","DOMAIN","RESPONSE_TIMEOUT","HEARTBEAT_INTERVAL","HANDSHAKE_INTERVAL","MSG_RESPONSE","MSG_HEARTBEAT","MSG_DISCONNECT","MSG_HANDSHAKE_SYN","MSG_HANDSHAKE_SYN_ACK","MSG_HANDSHAKE_ACK","HANDSHAKE_MSG_TYPES","INTERNAL_MSG_TYPES","createRequestMachine","types","actors","listen","abortSignal$","signal","requestId","Error","responseTo","sources","has","size","actions","params","targetOrigin","forEach","postMessage","parentRef","self","response","resolvable","resolve","id","console","warn","reject","guards","expectsResponse","expectResponse","delays","initialTimeout","responseTimeout","createMachine","connectionId","uuid","Set","initial","on","abort","states","idle","after","sending","entry","always","guard","awaiting","invoke","src","onError","failed","success","aborted","output","sendBackAtInterval","sendBack","send","immediate","interval","setInterval","clearInterval","createChannelMachine","requestMachine","enqueue","buffer","requests","spawn","request","messages","post","respond","respondTo","heartbeat","connect","handshaking","syn","disconnect","exit","connected","checking","disconnected","createChannel","machine","actor","stop","handler","unsubscribe","async","onStatus","currentSnapshot","getSnapshot","currentStatus","value","Object","keys","subscribe","state","status","setTarget","start","noop","createController","targets","connections","cleanupChannel","channel","setTimeout","addTarget","add","connection","channels","delete","targetChannels","subscribers","unsubscribers","push","internalEventSubscribers","statusSubscribers","createConnection","subscriber","unsub","onInternalEvent","destroy","createNodeMachine","handshakeBuffer","origin","hasSource","onDone","createNode","fetch","options","Promise","withResolvers","promise","snapshot"],"mappings":"aAIaA,MAAA,qCAAAC,WAAAC,YAAAC,YAAAC,kBAAAC,oBAAAC,iBAAAC,WAAAC,eAAAC,iBAAAC,UAAAC,MAAA,yBAAAC,eAAAC,SAAAC,UAAAC,YAAAC,iBAAAC,eAAAC,UAAAC,WAAAC,eAAAC,MAAA,OAAA,MAAAC,EAETC,GAeF,EAQEC,cAIA,MAAMC,MAACA,EAAOC,QAAAA,EAAAC,QAASA,EAASC,aAAAA,EAAe,oBAAsBL,EAC9D,MAAA,CACLE,QACAI,OAAQL,EAAQK,OAChBC,KAAMN,EAAQO,UACdL,QAASA,EAAWM,MAAMC,QAAQP,GAAWA,EAAU,CAACA,GAAY,GACpEC,QAASA,EAAWK,MAAMC,QAAQN,GAAWA,EAAU,CAACA,GAAY,GACpEC,eACAM,OAAQV,EAAQU,OAChBC,GAAIX,EAAQY,KAAA,EAyBLC,EAAiBzB,GAAM,IAClCC,EAAyCyB,OAAQ,aAMtCC,EACXC,GAGAvC,GAAoB,EAAEwC,YACbJ,SAAetB,KACpByB,EAAY1B,EAAI0B,GAAazB,IAC7BC,EAlCJ,CAACyB,GACAC,IACO,MAAAC,KAACA,GAAQD,EACf,QACGD,EAAMf,QAAQkB,QAASH,EAAMf,QAAQmB,SAASF,EAAKG,UACnDL,EAAMd,QAAQiB,SAAUH,EAAMd,QAAQkB,SAASF,EAAKG,QACrDH,EAAKd,SAAWY,EAAMZ,QACtBc,EAAKb,OAASW,EAAMX,MACpBa,EAAKR,KAAOM,EAAMN,MAChBM,EAAMP,QAAUQ,EAAMK,SAAWN,EAAMP,OAAA,EAyBlCc,CAAaP,IACpB3B,GArBAgC,EAqBmBL,EAAMb,aApB5Bc,IAA6F,CAC5FI,OACAG,QAASP,MAmBPD,EAAMhB,MACFV,EACEE,EAAYwB,EAAMhB,OAClBP,GAAWgC,GAAQA,IACnB/B,EAAKsB,EAAMhB,QAEbV,KA5BR,IAAI+B,CA8BH,ICxFUK,EAAS,iBAGTC,EAAmB,IAGnBC,EAAqB,IAGrBC,EAAqB,IAKrBC,EAAe,mBAKfC,EAAgB,oBAGhBC,EAAiB,qBAGjBC,EAAoB,wBAGpBC,EAAwB,4BAGxBC,EAAoB,wBAGpBC,EAAsB,CACjCH,EACAC,EACAC,GAIWE,EAAqB,CAChCP,EACAE,EACAD,KACGK,GCMQE,EAAuB,IAI3B7D,EAAM,CACX8D,MAAO,CAAC,EAqCRC,OAAQ,CACNC,OAAQjE,GACN,EACEwC,YAQA,MAAM0B,EAAe1B,EAAM2B,OACvBvD,EAAU4B,EAAM2B,OAAQ,SAASrD,MA9FzCkC,EA+FuB,WAAWR,EAAM4B,oBA9F3CtB,GACCA,EAAOhC,KACLI,EAAK,GACLL,GAAI,KACI,MAAA,IAAIwD,MAAMrB,EAAO,OA4FjB7B,EAjGZ,IAAI6B,EAyGW,OAAApC,EAA0DyB,OAAQ,WAAWvB,KAClFC,GAPqB0B,GACrBA,EAAMC,MAAMG,OAASS,GACrBb,EAAMC,MAAM4B,aAAe9B,EAAM4B,aAC/B3B,EAAMK,QACRN,EAAM+B,QAAQC,IAAI/B,EAAMK,UAIxB5B,EAAKsB,EAAM+B,QAAQE,MACnBrD,EAAU8C,GAAY,KAK9BQ,QAAS,CACP,eAAgB,EAAEnD,WAAUoD,KAC1B,MAAMJ,QAACA,EAASK,aAAAA,GAAgBrD,GAC1ByB,QAACA,GAAW2B,EAEVJ,EAAAM,SAAS/B,IACfA,EAAOgC,YAAY9B,EAAS,CAAC4B,gBAAa,GAC3C,EAEH,aAAc1E,GACZ,EAAEqB,aAAaA,EAAQwD,YACvB,EAAExD,UAASyD,WACLzD,EAAQ0D,UACV1D,EAAQ2D,YAAYC,QAAQ5D,EAAQ0D,UAE/B,CACLpC,KAAM,kBACNuB,UAAWY,EAAKI,GAChBH,SAAU1D,EAAQ0D,SAClBX,WAAY/C,EAAQ+C,eAI1B,UAAWpE,GACT,EAAEqB,aAAaA,EAAQwD,YACvB,EAAExD,UAASyD,WAETK,QAAQC,KACN,oCAAoC/D,EAAQsB,oBAAoBtB,EAAQM,eAAeN,EAAQ6D,SAEjG7D,EAAQ2D,YAAYK,OAAO,IAAIlB,MAAM,yBAC9B,CAACxB,KAAM,iBAAkBuB,UAAWY,EAAKI,OAGpD,WAAYlF,GACV,EAAEqB,aAAaA,EAAQwD,YACvB,EAAExD,UAASyD,WACTzD,EAAQ2D,YAAYK,OAAO,IAAIlB,MAAM,oBAC9B,CAACxB,KAAM,kBAAmBuB,UAAWY,EAAKI,QAIvDI,OAAQ,CACNC,gBAAiB,EAAElE,aAAaA,EAAQmE,gBAE1CC,OAAQ,CACNC,eAAgB,EAChBC,gBDxK0B,OC0K3BC,cAAc,CAEfvE,QAAS,EAAEiB,YACF,CACLuD,aAAcvD,EAAMuD,aACpBrD,KAAMF,EAAME,KACZd,OAAQY,EAAMZ,OACd8D,eAAgBlD,EAAMkD,iBAAkB,EACxC7D,KAAMW,EAAMX,KACZuD,GAAI,OAAOY,MACXjB,UAAWvC,EAAMuC,UACjBG,WAAY1C,EAAM0C,WAClBD,SAAU,KACVX,WAAY9B,EAAM8B,WAClBH,OAAQ3B,EAAM2B,OACdI,QAAS/B,EAAM+B,mBAAmB0B,IAAMzD,EAAM+B,QAAU,IAAI0B,IAAI,CAACzD,EAAM+B,UACvEK,aAAcpC,EAAMoC,aACpB1C,GAAIM,EAAMN,GACVW,KAAML,EAAMK,OAGhBqD,QAAS,OACTC,GAAI,CACFC,MAAO,YAETC,OAAQ,CACNC,KAAM,CACJC,MAAO,CACLX,eAAgB,CACd,CACE3D,OAAQ,cAKhBuE,QAAS,CACPC,MAAO,CACL5D,KAAM,eACN8B,OAAQ,EAAEpD,cACF,MAAAwE,aAACA,OAAcrD,EAAMd,OAAAA,EAAAC,KAAQA,KAAMuD,EAAId,WAAAA,EAAApC,GAAYA,EAAIW,KAAAA,GAAQtB,EAWrE,MAAO,CAACyB,QAVQ,CACd+C,eACArD,OACAd,SACAC,OACAuD,KACAlD,KACAW,OACAyB,iBAKNoC,OAAQ,CACN,CACEC,MAAO,kBACP1E,OAAQ,YAEV,YAGJ2E,SAAU,CACRC,OAAQ,CACNzB,GAAI,sBACJ0B,IAAK,SACLtE,MAAO,EAAEjB,cAAc,CACrB6C,UAAW7C,EAAQ6D,GACnBb,QAAShD,EAAQgD,QACjBJ,OAAQ5C,EAAQ4C,SAElB4C,QAAS,WAEXR,MAAO,CACLV,gBAAiB,UAEnBM,GAAI,CACFnD,QAAS,CACP0B,QAASvE,EAAO,CACd8E,SAAU,EAAExC,WAAWA,EAAMC,KAAKA,KAClC4B,WAAY,EAAE7B,WAAWA,EAAMC,KAAK4B,aAEtCrC,OAAQ,aAId+E,OAAQ,CACNnE,KAAM,QACN4D,MAAO,WAETQ,QAAS,CACPpE,KAAM,QACN4D,MAAO,cAETS,QAAS,CACPrE,KAAM,QACN4D,MAAO,aAGXU,OAAQ,EAAE5F,UAASyD,WACF,CACbZ,UAAWY,EAAKI,GAChBH,SAAU1D,EAAQ0D,SAClBX,WAAY/C,EAAQ+C,eClMtB8C,EAAqBhH,GAGzB,EAAEiH,WAAU7E,YACZ,MAAM8E,EAAO,KACXD,EAAS7E,EAAMC,MAAK,EAGlBD,EAAM+E,WACRD,IAGF,MAAME,EAAWC,YAAYH,EAAM9E,EAAMgF,UAEzC,MAAO,KACLE,cAAcF,EAAQ,CAAA,IAObG,EAAuB,IAMX1H,EAAM,CAC3B8D,MAAO,CAAC,EA2CRC,OAAQ,CACN4D,eAAgB9D,IAChBG,OAAQ3B,IACR8E,sBAEF1C,QAAS,CACP,iBAAkBrE,GAAe,EAAEwH,cACjCA,EAAQ1H,OAAO,CACb2H,OAAQ,EAAErF,QAAOlB,cACfjB,EAAYmC,EAAO,QACZ,IAAIlB,EAAQuG,OAAQrF,EAAMC,SAGrCmF,EAAQnH,MAAK,EAAE+B,YACbnC,EAAYmC,EAAO,QACZ,CACLI,KAAM,gBACNG,QAASP,EAAMC,QAElB,IAEH,iBAAkBvC,EAAO,CACvB4H,SAAU,EAAExG,UAASkB,QAAOuC,OAAMgD,YAChC1H,EAAYmC,EAAO,WAEnB,MAAMsF,GADMhG,MAAMC,QAAQS,EAAMC,MAAQD,EAAMC,KAAO,CAACD,EAAMC,OACvC7B,KAAKoH,IAClB,MAAA7C,EAAK,OAAOY,MAClB,OAAOgC,EAAM,iBAAkB,CAC7B5C,KACA5C,MAAO,CACLuD,aAAcxE,EAAQwE,aACtBrD,KAAMuF,EAAQvF,KACdd,OAAQL,EAAQK,OAChB8D,eAAgBuC,EAAQvC,eACxB7D,KAAMN,EAAQY,KACd4C,UAAWC,EACXV,WAAY2D,EAAQ3D,WACpBC,QAAShD,EAAQU,OACjB2C,aAAcrD,EAAQqD,aACtB1C,GAAIX,EAAQO,UACZe,KAAMoF,EAAQpF,OAEjB,IAEH,MAAO,IAAItB,EAAQwG,YAAaA,EAAQ,IAG5C,wBAAyB1H,GAAe,EAAEwH,cAChCA,EAAAnH,MAAK,EAAE+B,YACbnC,EAAYmC,EAAO,oBACZ,CACLI,KAAM,WACNG,QAASP,EAAMO,QAAQN,SAG3BmF,EAAQnH,MAAK,EAAE+B,YACbnC,EAAYmC,EAAO,oBACN,CACXI,KAAMJ,EAAMO,QAAQN,KAAKG,KACzBG,QAASP,EAAMO,QAAQN,QAG1B,IAEH,eAAgBrC,GAAe,EAAEwH,cAC/BA,EAAQtH,OAAM,EAAEgB,cAAc,CAC5BsB,KAAM,UACNH,KAAMnB,EAAQuG,OAAOjH,KAAI,EAAE6B,OAAMG,WAAW,CAACH,OAAMG,eAErDgF,EAAQnH,MAAK,EAAEa,cACN,CACLsB,KAAM,kBACNqF,SAAU3G,EAAQuG,WAGtBD,EAAQ1H,OAAO,CACb2H,OAAQ,IACT,IAEHK,KAAQ5H,GAAM,EAAEkC,YACdnC,EAAYmC,EAAO,QACZ,CACLI,KAAM,UACNH,KAAM,CACJA,KAAMD,EAAMC,KAAKA,KACjBgD,gBAAgB,EAChB7C,KAAMJ,EAAMC,KAAKG,UAIvB,iBAAkBxC,GAAe,EAAEkB,UAASsG,UAASpF,YACvCnC,EAAAmC,EAAO,CAAC,kBAAmB,iBAAkB,oBACzDjC,EAAUiC,EAAM2B,WAChByD,EAAQ1H,OAAO,CAAC4H,SAAUxG,EAAQwG,SAAShH,QAAO,EAAEqE,QAAQA,IAAO3C,EAAM2B,aAAW,IAEtFgE,QAAW7H,GAAM,EAAEkC,YACjBnC,EAAYmC,EAAO,YACZ,CACLI,KAAM,UACNH,KAAM,CACJA,KAAMD,EAAMC,KACZG,KAAMS,EACNgB,WAAY7B,EAAM4F,eAIxB,qBAAsB9H,EAAM,CAC1BsC,KAAM,UACNH,KAAM,CAACG,KAAMc,KAEf,kBAAmBpD,GAAM,KAChB,CACLsC,KAAM,UACNH,KAAM,CAACG,KAAMW,OAGjB,qBAAsBjD,EAAM,CAC1BsC,KAAM,UACNH,KAAM,CAACG,KAAMY,KAEf,aAActD,EAAO,CACnB8B,OAAQ,EAAEQ,YACRnC,EAAYmC,EAAO,cACZA,EAAMR,WAInBuD,OAAQ,CACN,aAAc,EAAEjE,eAAeA,EAAQU,OACvC,yBAA0B,EAAEV,aAAaA,EAAQ+G,aAElDxC,cAAc,CAEfV,GAAI,UACJ7D,QAAS,EAAEiB,YAAY,CACrB4C,GAAI5C,EAAM4C,IAAM,GAAG5C,EAAML,QAAQ6D,MACjC8B,OAAQ,GACR/B,aAAc,OAAOC,MACrBlE,UAAWU,EAAMV,UACjBF,OAAQY,EAAMZ,QAAUsB,EACxBoF,UAAW9F,EAAM8F,YAAa,EAC9BnG,KAAMK,EAAML,KACZ4F,SAAU,GACV9F,OAAQO,EAAMP,OACd2C,aAAcpC,EAAMoC,eAEtBuB,GAAI,CACF,aAAc,CACZzB,QAAS,cAEX,kBAAmB,CACjBA,QAAS,kBAEX,iBAAkB,CAChBA,QAAS,mBAGbwB,QAAS,OACTG,OAAQ,CACNC,KAAM,CACJH,GAAI,CACFoC,QAAS,CACPtG,OAAQ,cACR0E,MAAO,cAETwB,KAAM,CACJzD,QAAS,oBAIf8D,YAAa,CACXpD,GAAI,cACJyB,OAAQ,CACN,CACEzB,GAAI,WACJ0B,IAAK,qBACLtE,MAAO,KAAO,CACZC,MAAO,CAACI,KAAM,OACd2E,SFlUoB,IEmUpBD,WAAW,KAGf,CACEnC,GAAI,uBACJ0B,IAAK,SACLtE,MAAQA,GACNnB,EAAuB,CACrBI,QAASiC,EACTlC,MAAO,GAFTH,CAGGmB,KAUT2D,GAAI,CACFsC,IAAO,CACL/D,QAAS,sBAEXuD,QAAW,CACTvD,QAAS,kBAEXyD,KAAQ,CACNzD,QAAS,kBAEX,mBAAoB,CAClBzC,OAAQ,aAEVyG,WAAc,CACZzG,OAAQ,iBAGZ0G,KAAM,sBAERC,UAAW,CACTnC,MAAO,eACPI,OAAQ,CACNzB,GAAI,sBACJ0B,IAAK,SACLtE,MAAOnB,EAAuB,CAC5BK,QAAS,CAAC4B,EAAcC,MAG5B4C,GAAI,CACFgC,KAAQ,CACNzD,QAAS,QAEXuD,QAAW,CACTvD,QAAS,kBAEXO,SAAY,CACVP,QAAS,WAEX,mBAAoB,CAClBA,QAAS,yBAEXgE,WAAc,CACZzG,OAAQ,iBAGZiE,QAAS,YACTG,OAAQ,CACNiC,UAAW,CACTpC,QAAS,WACTG,OAAQ,CACNwC,SAAU,CACRnC,OAAQ,CACNC,MAAO,yBACP1E,OAAQ,YAGZuE,QAAS,CACPL,GAAI,CACF,iBAAkB,CAChBlE,OAAQ,iBAGZ4E,OAAQ,CACNzB,GAAI,iBACJ0B,IAAK,qBACLtE,MAAO,KAAO,CACZC,MAAO,CAACI,KAAM,OAAQH,KAAM,CAACG,KAAMU,EAAeb,UAAM,IACxD8E,SAAU,IACVD,WAAW,UAQzBuB,aAAc,CACZ1D,GAAI,eACJqB,MAAO,kBACPN,GAAI,CACF8B,QAAS,CACPvD,QAAS,kBAEXyD,KAAM,CACJzD,QAAS,kBAEX6D,QAAS,CACPtG,OAAQ,cACR0E,MAAO,mBAaNoC,EAAgB,CAC3BvG,EACAwG,EAAmCrB,OAEnC,MAAMvC,EAAK5C,EAAM4C,IAAM,GAAG5C,EAAML,QAAQ6D,MAClCiD,EAAQxI,EAAYuI,EAAS,CACjCxG,MAAO,IAAIA,EAAO4C,QAsDd8D,EAAO,KACXD,EAAMC,MAAK,EAQN,MAAA,CACLD,QACAV,QA7Cc,KACdU,EAAM3B,KAAK,CAACzE,KAAM,WAAU,EA6C5B6F,WA1CiB,KACjBO,EAAM3B,KAAK,CAACzE,KAAM,cAAa,EA0C/BuC,KACAjD,KAAMK,EAAML,KACZ6G,UACA7C,GAnES,CACTtD,EACAsG,KAEM,MAAAC,YAACA,GAAeH,EAAM9C,GAE1BtD,GACAwG,MAAO5G,IACL,MAAMwC,QAAiBkE,EAAQ1G,EAAMO,QAAQN,MAE3CuC,GAAAgE,EAAM3B,KAAK,CAACzE,KAAM,WAAYwF,UAAW5F,EAAMO,QAAQoC,GAAI1C,KAAMuC,GAAS,IAIzE,OAAAmE,CAAA,EAsDPE,SA3CgBH,IACV,MAAAI,EAAkBN,EAAMO,cAC9B,IAAIC,EAC+B,iBAA1BF,EAAgBG,MACnBH,EAAgBG,MAChBC,OAAOC,KAAKL,EAAgBG,OAAO,GAEzC,MAAMN,YAACA,GAAeH,EAAMY,WAAWC,IACrC,MAAMC,EACmB,iBAAhBD,EAAMJ,MAAqBI,EAAMJ,MAAQC,OAAOC,KAAKE,EAAMJ,OAAO,GACvED,IAAkBM,IACpBN,EAAgBM,EAChBZ,EAAQY,GAAM,IAGX,OAAAX,CAAA,EA6BPjB,KAtBYzF,IACZuG,EAAM3B,KAAK,CAACzE,KAAM,OAAQH,QAAK,EAsB/BsH,UA3BiB/H,IACjBgH,EAAM3B,KAAK,CAACzE,KAAM,aAAcZ,UAAO,EA2BvCgI,MAhBY,KACZhB,EAAMgB,QACCf,GAePA,OACA,UAAIjH,GACK,OAAAgH,EAAMO,cAAcjI,QAAQU,MACrC,EAAA,ECrdEiI,EAAO,OAKAC,EAAoB3H,IAC/B,MAAMoC,aAACA,GAAgBpC,EACjB4H,EAAc,IAAAnE,IACdoE,EAAkB,IAAApE,IAiFlBqE,EAAgEC,IAC5DA,EAAA7B,aAGR8B,YAAW,KACTD,EAAQrB,MAAK,GACZ,EAAC,EAiIC,MAAA,CACLuB,UAvNiBxI,IAEb,GAAAmI,EAAQ5F,IAAIvC,GACP,OAAAiI,EAGT,IAAKE,EAAQ3F,OAAS4F,EAAY5F,KAChC,OAAA2F,EAAQM,IAAIzI,GAIZoI,EAAYxF,SAAS8F,IACRA,EAAAC,SAAS/F,SAAS0F,IAC3BA,EAAQP,UAAU/H,GAClBsI,EAAQhC,SAAQ,GACjB,IAII,KACL6B,EAAQS,OAAO5I,GACfoI,EAAYxF,SAAS8F,IACRA,EAAAC,SAAS/F,SAAS0F,IACfA,EAAAtI,SAAWA,GACrBsI,EAAQ7B,YAAW,GAEtB,GACF,EAIL0B,EAAQM,IAAIzI,GAGN,MAAA6I,MAAqB7E,IAIf,OAAAoE,EAAAxF,SAAS8F,IACnB,MAAMJ,EAAUxB,EACd,IACK4B,EAAWnI,MACdP,SACA2C,gBAEF+F,EAAW3B,SAGb8B,EAAeJ,IAAIH,GACnBI,EAAWC,SAASF,IAAIH,GAExBI,EAAWI,YAAYlG,SAAQ,EAAEhC,OAAMsG,UAAS6B,oBAC9CA,EAAcC,KAAKV,EAAQpE,GAAGtD,EAAMsG,GAAQ,IAE9CwB,EAAWO,yBAAyBrG,SAAQ,EAAEhC,OAAMsG,UAAS6B,oBAE3DA,EAAcC,KAAKV,EAAQtB,MAAM9C,GAAGtD,EAAMsG,GAASC,YAAW,IAEhEuB,EAAWQ,kBAAkBtG,SAAQ,EAAEsE,UAAS6B,oBAC9CA,EAAcC,KAAKV,EAAQjB,UAAUS,GAAWZ,EAAQ,CAACoB,QAASA,EAAQnF,GAAI2E,aAAS,IAGzFQ,EAAQN,QACRM,EAAQhC,SAAQ,IAKX,KACL6B,EAAQS,OAAO5I,GACf6I,EAAejG,SAAS0F,IACtBD,EAAeC,GACfF,EAAYxF,SAAS8F,IACRA,EAAAC,SAASC,OAAON,EAAO,GACnC,GACF,CAAA,EA6IHa,iBAhIuB,CACvB5I,EACAwG,EAAmCrB,OAEnC,MAAMgD,EAA+B,CACnCC,aAAc3E,IACdzD,MAAAA,EACA0I,6BAA8BjF,IAC9B+C,UACAmC,sBAAuBlF,IACvB8E,gBAAiB9E,KAInBoE,EAAYK,IAAIC,GAEhB,MAAMC,SAACA,EAAAM,yBAAUA,EAA0BC,kBAAAA,EAAAJ,YAAmBA,GAAeJ,EAE7E,GAAIP,EAAQ3F,KAEF2F,EAAAvF,SAAS5C,IACf,MAAMsI,EAAUxB,EACd,IACKvG,EACHP,SACA2C,gBAEFoE,GAEF4B,EAASF,IAAIH,EAAO,QAEjB,CAEL,MAAMA,EAAUxB,EAAoB,IAAIvG,EAAOoC,gBAAeoE,GAC9D4B,EAASF,IAAIH,EACf,CAEM,MAsDArB,EAAO,KACF0B,EAAA/F,SAAS0F,IACRA,EAAA7B,aACR6B,EAAQrB,MAAK,GACd,EAYI,MAAA,CACL/C,GAjEyC,CAACtD,EAAMsG,KAChD,MAAM6B,EAAmC,GAChCJ,EAAA/F,SAAS0F,IAChBS,EAAcC,KAAKV,EAAQpE,GAAGtD,EAAMsG,GAAQ,IAE9C,MAAMkC,EAAa,CAACxI,OAAMsG,UAAS6B,iBACvB,OAAAD,EAAAL,IAAIW,GACT,KACSL,EAAAnG,SAASyG,GAAUA,MACjCP,EAAYF,OAAOQ,EAAU,CAAA,EAyD/BE,gBArDsB,CAItB1I,EACAsG,KAEA,MAAM6B,EAAmC,GAChCJ,EAAA/F,SAAS0F,IAEhBS,EAAcC,KAAKV,EAAQtB,MAAM9C,GAAGtD,EAAMsG,GAASC,YAAW,IAEhE,MAAMiC,EAAa,CAACxI,OAAMsG,UAAS6B,iBAEV,OAAAE,EAAAR,IAAIW,GACtB,KACSL,EAAAnG,SAASyG,GAAUA,MAEjCJ,EAAyBL,OAAOQ,EAAU,CAAA,EAoC5C/B,SAhCgBH,IAChB,MAAM6B,EAAmC,GAChCJ,EAAA/F,SAAS0F,IAChBS,EAAcC,KAAKV,EAAQjB,UAAUS,GAAWZ,EAAQ,CAACoB,QAASA,EAAQnF,GAAI2E,aAAS,IAEnF,MAAAsB,EAAa,CAAClC,UAAS6B,iBACX,OAAAG,EAAAT,IAAIW,GACf,KACSL,EAAAnG,SAASyG,GAAUA,MACjCH,EAAkBN,OAAOQ,EAAU,CAAA,EAwBrClD,KA1E8CzF,IACrCkI,EAAA/F,SAAS0F,IAChBA,EAAQpC,KAAKzF,EAAI,GAClB,EAwEDuH,MAdY,KACZW,EAAS/F,SAAS0F,IACRA,EAAAN,QACRM,EAAQhC,SAAQ,IAGXW,GASPA,OAAA,EAgBFsC,QAZc,KACdnB,EAAYxF,SAAQ,EAAE+F,eACXA,EAAA/F,SAAS0F,IAChBD,EAAeC,GACfK,EAASC,OAAON,EAAO,GACxB,GACF,EACH,ECrNWkB,EAAoB,IAMXxL,EAAM,CACxB8D,MAAO,CAAC,EAwDRC,OAAQ,CACN4D,eAAgB9D,IAChBG,OAAQ3B,KAEVoC,QAAS,CACP,0BAA2BvE,EAAO,CAChCuL,gBAAiB,EAAEjJ,QAAOlB,cACxBjB,EAAYmC,EAAO,oBACZ,IAAIlB,EAAQmK,gBAAiBjJ,MAGxC,iBAAkBpC,GAAe,EAAEwH,cACjCA,EAAQ1H,OAAO,CACb2H,OAAQ,EAAErF,QAAOlB,cACfjB,EAAYmC,EAAO,QACZ,IACFlB,EAAQuG,OACX,CACEpF,KAAMD,EAAMC,KACZwC,WAAYzC,EAAMyC,WAClBf,OAAQ1B,EAAM0B,YAKtB0D,EAAQnH,MAAK,EAAE+B,YACbnC,EAAYmC,EAAO,QACZ,CACLI,KAAM,gBACNG,QAASP,EAAMC,QAElB,IAEH,iBAAkBvC,EAAO,CACvB4H,SAAU,EAAExG,UAASkB,QAAOuC,OAAMgD,YAChC1H,EAAYmC,EAAO,WAEnB,MAAMsF,GADMhG,MAAMC,QAAQS,EAAMC,MAAQD,EAAMC,KAAO,CAACD,EAAMC,OACvC7B,KAAKoH,IAClB,MAAA7C,EAAK,OAAOY,MAClB,OAAOgC,EAAM,iBAAkB,CAC7B5C,KACA5C,MAAO,CACLuD,aAAcxE,EAAQwE,aACtBrD,KAAMuF,EAAQvF,KACdd,OAAQL,EAAQK,OAChB8D,eAAgBuC,EAAQvC,eACxB7D,KAAMN,EAAQY,KACd4C,UAAWC,EACXE,WAAY+C,EAAQ/C,WACpBZ,WAAY2D,EAAQ3D,WACpBC,QAAShD,EAAQU,OACjB2C,aAAcrD,EAAQqD,aACtB1C,GAAIX,EAAQO,UACZe,KAAMoF,EAAQpF,KACdsB,OAAQ8D,EAAQ9D,SAEnB,IAEH,MAAO,IAAI5C,EAAQwG,YAAaA,EAAQ,IAG5C,iBAAkBrH,GAAK,KACd,CACLmC,KAAM,iBAGV,wBAAyBxC,GAAe,EAAEwH,cAChCA,EAAAnH,MAAK,EAAE+B,YACbnC,EAAYmC,EAAO,oBACZ,CACLI,KAAM,WACNG,QAASP,EAAMO,QAAQN,SAG3BmF,EAAQnH,MAAK,EAAE+B,YACbnC,EAAYmC,EAAO,oBACN,CACXI,KAAMJ,EAAMO,QAAQN,KAAKG,KACzBG,QAASP,EAAMO,QAAQN,QAG1B,IAEH,eAAgBrC,GAAe,EAAEwH,cAC/BA,EAAQtH,OAAM,EAAEgB,cAAc,CAC5BsB,KAAM,UACNH,KAAMnB,EAAQuG,OAAOjH,KAAI,EAAE6B,OAAMwC,aAAYf,aAAa,CACxDzB,KAAMA,EAAKA,KACXG,KAAMH,EAAKG,KACX6C,iBAAgBR,EAChBA,aACAf,iBAGJ0D,EAAQnH,MAAK,EAAEa,cACN,CACLsB,KAAM,kBACNqF,SAAU3G,EAAQuG,OAAOjH,KAAI,EAAE6B,UAAUA,QAG7CmF,EAAQ1H,OAAO,CACb2H,OAAQ,IACT,IAEH,yBAA0BzH,GAAe,EAAEkB,UAASsG,cAC1CtG,EAAAmK,gBAAgB7G,SAASpC,GAAUoF,EAAQtH,MAAMkC,KACzDoF,EAAQ1H,OAAO,CACbuL,gBAAiB,IAClB,IAEHvD,KAAQ5H,GAAM,EAAEkC,YACdnC,EAAYmC,EAAO,QACZ,CACLI,KAAM,UACNH,KAAM,CACJA,KAAMD,EAAMC,KAAKA,KACjBgD,iBAAsBjD,EAAAyC,WACtBrC,KAAMJ,EAAMC,KAAKG,KACjBqC,WAAYzC,EAAMyC,WAClBf,OAAQ1B,EAAM0B,YAIpB,iBAAkB9D,GAAe,EAAEkB,UAASsG,UAASpF,YACvCnC,EAAAmC,EAAO,CAAC,kBAAmB,iBAAkB,oBACzDjC,EAAUiC,EAAM2B,WAChByD,EAAQ1H,OAAO,CAAC4H,SAAUxG,EAAQwG,SAAShH,QAAO,EAAEqE,QAAQA,IAAO3C,EAAM2B,aAAW,IAEtF,gBAAiB7D,GAAM,EAAEkC,YACvBnC,EAAYmC,EAAO,CAAC,mBAAoB,uBACjC,CACLI,KAAM,UACNH,KAAM,CACJG,KAAMS,EACNgB,WAAY7B,EAAMO,QAAQN,KAAK0C,GAC/B1C,UAAM,OAIZ,yBAA0BnC,EAAM,CAC9BsC,KAAM,UACNH,KAAM,CAACG,KAAMa,KAEf,wBAAyBvD,EAAO,CAC9B4F,aAAc,EAAEtD,YACdnC,EAAYmC,EAAO,oBACZA,EAAMO,QAAQN,KAAKqD,cAE5B9D,OAAQ,EAAEQ,YACRnC,EAAYmC,EAAO,oBACZA,EAAMO,QAAQF,aAAU,GAEjC8B,aAAc,EAAEnC,YACdnC,EAAYmC,EAAO,oBACZA,EAAMO,QAAQ2I,WAI3BnG,OAAQ,CACNoG,UAAW,EAAErK,aAAgC,OAAnBA,EAAQU,UAEnC6D,cAAc,CAEfV,GAAI,OACJ7D,QAAS,EAAEiB,YAAY,CACrBsF,OAAQ,GACR/B,aAAc,KACdjE,UAAWU,EAAMV,UACjBF,OAAQY,EAAMZ,QAAUsB,EACxBwI,gBAAiB,GACjBvJ,KAAMK,EAAML,KACZ4F,SAAU,GACV9F,YAAQ,EACR2C,aAAc,OAEhBuB,GAAI,CACF,kBAAmB,CACjBzB,QAAS,kBAEX,iBAAkB,CAChBA,QAAS,kBAEX,kBAAmB,CACjBA,QAAS,mBAGbwB,QAAS,OACTG,OAAQ,CACNC,KAAM,CACJO,OAAQ,CACNzB,GAAI,2BACJ0B,IAAK,SACLtE,MAAOnB,EAAuB,CAC5BI,QAASgC,EACTjC,MAAO,IAETqK,OAAQ,CACN5J,OAAQ,cACR0E,MAAO,cAGXR,GAAI,CACF,mBAAoB,CAClBzB,QAAS,yBAEXyD,KAAQ,CACNzD,QAAS,oBAIf8D,YAAa,CACX/B,MAAO,yBACPI,OAAQ,CACN,CACEzB,GAAI,2BACJ0B,IAAK,SACLtE,MAAOnB,EAAuB,CAC5BI,QAASkC,EACTnC,MAAO,EAIPG,aAAc,uBAEhBkK,OAAQ,aAEV,CACEzG,GAAI,wBACJ0B,IAAK,SACLtE,MAAOnB,EAAuB,CAC5BI,QAAS+B,EACThC,MAAO,EACPG,aAAc,gBAGlB,CACEyD,GAAI,sBACJ0B,IAAK,SACLtE,MAAOnB,EAAuB,CAC5BK,QAAS,CAAC8B,EAAgBG,EAAmBJ,EAAeD,OAIlE6C,GAAI,CACF8B,QAAW,CACTvD,QAAS,kBAEXyD,KAAQ,CACNzD,QAAS,kBAEX,mBAAoB,CAClBA,QAAS,2BAEXgE,WAAc,CACZzG,OAAQ,UAId2G,UAAW,CACTnC,MAAO,CAAC,yBAA0B,gBAClCI,OAAQ,CACN,CACEzB,GAAI,sBACJ0B,IAAK,SACLtE,MAAOnB,EAAuB,CAC5BK,QAAS,CAAC4B,EAAcC,MAG5B,CACE6B,GAAI,uBACJ0B,IAAK,SACLtE,MAAOnB,EAAuB,CAC5BI,QAAS8B,EACT5B,aAAc,wBAGlB,CACEyD,GAAI,wBACJ0B,IAAK,SACLtE,MAAOnB,EAAuB,CAC5BI,QAAS+B,EACThC,MAAO,EACPG,aAAc,iBAIpBwE,GAAI,CACF8B,QAAW,CACTvD,QAAS,kBAEXyD,KAAQ,CACNzD,QAAS,QAEXgE,WAAc,CACZzG,OAAQ,QAEV,mBAAoB,CAClByC,QAAS,CAAC,gBAAiB,0BAE7B,qBAAsB,CACpBA,QAAS,CAAC,gBAAiB,wBAY1BoH,EAAa,CACxBtJ,EACAwG,EAAgCyC,OAE1B,MAAAxC,EAAQxI,EAAYuI,EAAS,CACjCxG,UAgDI0G,EAAO,KACXD,EAAMC,MAAK,EAQN,MAAA,CACLD,QACA8C,MAtBY,CAACrJ,EAA0BsJ,KACjC,MAAA9G,EAAa+G,QAAQC,gBAC3B,OAAAjD,EAAM3B,KAAK,CACTzE,KAAM,OACNH,OACAwC,aACAf,OAAQ6H,GAAS7H,SAEZe,EAAWiH,OAAA,EAelBnD,UACA7C,GA1DS,CACTtD,EACAsG,KAEM,MAAAC,YAACA,GAAeH,EAAM9C,GAE1BtD,GACCJ,IACS0G,EAAA1G,EAAMO,QAAQN,KAAI,IAGvB,OAAA0G,CAAA,EAgDPE,SA7CgBH,IACV,MAAAiD,EAAWnD,EAAMO,cACvB,IAAIC,EACwB,iBAAnB2C,EAAS1C,MAAqB0C,EAAS1C,MAAQC,OAAOC,KAAKwC,EAAS1C,OAAO,GAEpF,MAAMN,YAACA,GAAeH,EAAMY,WAAWC,IACrC,MAAMC,EACmB,iBAAhBD,EAAMJ,MAAqBI,EAAMJ,MAAQC,OAAOC,KAAKE,EAAMJ,OAAO,GACvED,IAAkBM,IACpBN,EAAgBM,EAChBZ,EAAQY,GAAM,IAGX,OAAAX,CAAA,EAiCPjB,KA9BYzF,IACZuG,EAAM3B,KAAK,CAACzE,KAAM,OAAQH,QAAK,EA8B/BuH,MAZY,KACZhB,EAAMgB,QACCf,GAWPA,OAAA"}