import { jsxs, Fragment, jsx } from "react/jsx-runtime";
import { createCompatibilityActors, getQueryCacheKey } from "./PresentationToolGrantsCheck.js";
import { useQueryParams, useRevalidate } from "./hooks.js";
import { applySourceDocuments, getPublishedId } from "@sanity/client/csm";
import { createChannelMachine } from "@sanity/comlink";
import { applyPatch } from "mendoza";
import LRUCache from "mnemonist/lru-cache-with-delete";
import { useState, useEffect, useMemo, memo } from "react";
import { useProjectId, useDataset, useClient } from "sanity";
import { MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL, LIVE_QUERY_CACHE_SIZE, LIVE_QUERY_CACHE_BATCH_SIZE } from "./index.js";
function LoaderQueries(props) {
  const {
    liveDocument,
    controller,
    perspective: activePerspective,
    documentsOnPage,
    onLoadersConnection,
    onDocumentsOnPage
  } = props, [comlink, setComlink] = useState(), [liveQueries, setLiveQueries] = useState({}), projectId = useProjectId(), dataset = useDataset();
  useEffect(() => {
    const interval = setInterval(
      () => setLiveQueries((liveQueries2) => {
        if (Object.keys(liveQueries2).length < 1)
          return liveQueries2;
        const now = Date.now();
        if (!Object.values(liveQueries2).some(
          (liveQuery) => liveQuery.heartbeat !== !1 && now > liveQuery.receivedAt + liveQuery.heartbeat
        ))
          return liveQueries2;
        const next = {};
        for (const [key, value] of Object.entries(liveQueries2))
          value.heartbeat !== !1 && now > value.receivedAt + value.heartbeat || (next[key] = value);
        return next;
      }),
      MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL
    );
    return () => clearInterval(interval);
  }, []), useEffect(() => {
    if (controller) {
      const comlink2 = controller.createConnection(
        {
          name: "presentation",
          connectTo: "loaders",
          heartbeat: !0
        },
        createChannelMachine().provide({
          actors: createCompatibilityActors()
        })
      );
      return setComlink(comlink2), comlink2.onStatus(onLoadersConnection), comlink2.on("loader/documents", (data) => {
        data.projectId === projectId && data.dataset === dataset && onDocumentsOnPage(
          "loaders",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          data.perspective,
          data.documents
        );
      }), comlink2.on("loader/query-listen", (data) => {
        if (data.projectId === projectId && data.dataset === dataset) {
          if (typeof data.heartbeat == "number" && data.heartbeat < MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL)
            throw new Error(
              `Loader query listen heartbeat interval must be at least ${MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`
            );
          setLiveQueries((prev) => ({
            ...prev,
            [getQueryCacheKey(data.query, data.params)]: {
              perspective: data.perspective,
              query: data.query,
              params: data.params,
              receivedAt: Date.now(),
              heartbeat: data.heartbeat ?? !1
            }
          }));
        }
      }), comlink2.start();
    }
  }, [controller, dataset, onDocumentsOnPage, onLoadersConnection, projectId]);
  const [cache] = useState(() => new LRUCache(LIVE_QUERY_CACHE_SIZE)), studioClient = useClient({ apiVersion: "2023-10-16" }), clientConfig = useMemo(() => studioClient.config(), [studioClient]), client = useMemo(
    () => studioClient.withConfig({
      resultSourceMap: "withKeyArraySelector"
    }),
    [studioClient]
  );
  useEffect(() => {
    if (comlink) {
      const { projectId: projectId2, dataset: dataset2 } = clientConfig;
      comlink.post({
        type: "loader/perspective",
        data: {
          projectId: projectId2,
          dataset: dataset2,
          perspective: activePerspective
        }
      });
    }
  }, [comlink, clientConfig, activePerspective]);
  const turboIds = useMemo(() => {
    const documentsActuallyInUse = documentsOnPage.map(({ _id }) => _id), ids = [...new Set(documentsActuallyInUse)], max = cache.capacity;
    return ids.length >= max && (ids.length = max), ids;
  }, [cache.capacity, documentsOnPage]), [documentsCacheLastUpdated, setDocumentsCacheLastUpdated] = useState(0);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Turbo,
      {
        cache,
        client,
        turboIds,
        setDocumentsCacheLastUpdated
      }
    ),
    Object.entries(liveQueries).map(([key, { query, params, perspective }]) => /* @__PURE__ */ jsx(
      QuerySubscription,
      {
        cache,
        projectId: clientConfig.projectId,
        dataset: clientConfig.dataset,
        perspective,
        query,
        params,
        comlink,
        client,
        refreshInterval: activePerspective ? 2e3 : 0,
        liveDocument,
        documentsCacheLastUpdated
      },
      `${key}${perspective}`
    ))
  ] });
}
const Turbo = memo(function(props) {
  const { cache, client, turboIds, setDocumentsCacheLastUpdated } = props, [batch, setBatch] = useState([]);
  return useEffect(() => {
    const batchSet = new Set(batch.flat()), nextBatch = /* @__PURE__ */ new Set();
    for (const turboId of turboIds)
      !batchSet.has(turboId) && !cache.has(turboId) && nextBatch.add(turboId);
    const nextBatchSlice = [...nextBatch].slice(0, LIVE_QUERY_CACHE_BATCH_SIZE);
    nextBatchSlice.length !== 0 && setBatch((prevBatch) => [...prevBatch.slice(-LIVE_QUERY_CACHE_BATCH_SIZE), nextBatchSlice]);
  }, [batch, cache, turboIds]), useEffect(() => {
    const subscription = client.listen(
      "*",
      {},
      {
        events: ["mutation"],
        effectFormat: "mendoza",
        includePreviousRevision: !1,
        includeResult: !1,
        tag: "presentation-loader"
      }
    ).subscribe((update) => {
      if (update.type === "mutation" && update.transition === "disappear" && cache.delete(update.documentId) && setDocumentsCacheLastUpdated(Date.now()), update.type !== "mutation" || !update.effects?.apply?.length) return;
      const cachedDocument = cache.peek(update.documentId);
      if (cachedDocument) {
        const patchDoc = { ...cachedDocument };
        delete patchDoc._rev;
        const patchedDocument = applyPatch(patchDoc, update.effects.apply);
        cache.set(update.documentId, patchedDocument), setDocumentsCacheLastUpdated(Date.now());
      }
    });
    return () => subscription.unsubscribe();
  }, [cache, client, setDocumentsCacheLastUpdated]), /* @__PURE__ */ jsx(Fragment, { children: batch.map((ids) => /* @__PURE__ */ jsx(
    GetDocuments,
    {
      cache,
      client,
      ids,
      setDocumentsCacheLastUpdated
    },
    JSON.stringify(ids)
  )) });
}), GetDocuments = memo(function(props) {
  const { client, cache, ids, setDocumentsCacheLastUpdated } = props;
  return useEffect(() => {
    const missingIds = ids.filter((id) => !cache.has(id));
    missingIds.length !== 0 && client.getDocuments(missingIds).then((documents) => {
      for (const doc of documents)
        doc && doc?._id && (cache.set(doc._id, doc), setDocumentsCacheLastUpdated(Date.now()));
    }, console.error);
  }, [cache, client, ids, setDocumentsCacheLastUpdated]), null;
});
GetDocuments.displayName = "GetDocuments";
function QuerySubscription(props) {
  const {
    cache,
    projectId,
    dataset,
    perspective,
    query,
    client,
    refreshInterval,
    liveDocument,
    comlink,
    documentsCacheLastUpdated
  } = props, params = useQueryParams(props.params), data = useQuerySubscription({
    cache,
    client,
    liveDocument,
    params,
    perspective,
    query,
    refreshInterval,
    documentsCacheLastUpdated
  }), result = data?.result, resultSourceMap = data?.resultSourceMap, tags = data?.tags;
  return useEffect(() => {
    resultSourceMap && comlink?.post({
      type: "loader/query-change",
      data: {
        projectId,
        dataset,
        perspective,
        query,
        params,
        result,
        resultSourceMap,
        tags
      }
    });
  }, [comlink, dataset, params, perspective, projectId, query, result, resultSourceMap, tags]), null;
}
function useQuerySubscription(props) {
  const {
    cache,
    liveDocument,
    client,
    refreshInterval,
    query,
    params,
    perspective,
    documentsCacheLastUpdated
  } = props, [snapshot, setSnapshot] = useState(null), { projectId, dataset } = useMemo(() => {
    const { projectId: projectId2, dataset: dataset2 } = client.config();
    return { projectId: projectId2, dataset: dataset2 };
  }, [client]), [error, setError] = useState(null);
  if (error) throw error;
  const [revalidate, startRefresh] = useRevalidate({ refreshInterval }), shouldRefetch = revalidate === "refresh" || revalidate === "inflight";
  return useEffect(() => {
    if (!shouldRefetch)
      return;
    let fulfilled = !1, fetching = !1;
    const controller = new AbortController();
    async function effect() {
      const { signal } = controller;
      fetching = !0;
      const { result, resultSourceMap, syncTags } = await client.fetch(query, params, {
        tag: "presentation-loader",
        signal,
        perspective,
        filterResponse: !1
      });
      fetching = !1, signal.aborted || (setSnapshot({ result, resultSourceMap, tags: syncTags }), fulfilled = !0);
    }
    const onFinally = startRefresh();
    return effect().catch((error2) => {
      fetching = !1, error2.name !== "AbortError" && setError(error2);
    }).finally(onFinally), () => {
      !fulfilled && !fetching && controller.abort();
    };
  }, [
    client,
    dataset,
    liveDocument,
    params,
    perspective,
    projectId,
    query,
    shouldRefetch,
    startRefresh
  ]), useMemo(() => documentsCacheLastUpdated && snapshot?.resultSourceMap ? {
    result: turboChargeResultIfSourceMap(
      cache,
      liveDocument,
      snapshot.result,
      perspective,
      snapshot.resultSourceMap
    ),
    resultSourceMap: snapshot.resultSourceMap
  } : snapshot, [cache, documentsCacheLastUpdated, liveDocument, perspective, snapshot]);
}
let warnedAboutCrossDatasetReference = !1;
function turboChargeResultIfSourceMap(cache, liveDocument, result, perspective, resultSourceMap) {
  if (perspective === "raw")
    throw new Error("turboChargeResultIfSourceMap does not support raw perspective");
  return applySourceDocuments(
    result,
    resultSourceMap,
    (sourceDocument) => {
      if (sourceDocument._projectId) {
        warnedAboutCrossDatasetReference || (console.warn(
          "Cross dataset references are not supported yet, ignoring source document",
          sourceDocument
        ), warnedAboutCrossDatasetReference = !0);
        return;
      }
      return liveDocument?._id && getPublishedId(liveDocument._id) === getPublishedId(sourceDocument._id) ? liveDocument : cache.get(sourceDocument._id);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (changedValue, { previousValue }) => typeof changedValue == "number" && typeof previousValue == "string" ? `${changedValue}` : changedValue,
    perspective
  );
}
export {
  LoaderQueries as default,
  turboChargeResultIfSourceMap
};
//# sourceMappingURL=LoaderQueries.js.map
