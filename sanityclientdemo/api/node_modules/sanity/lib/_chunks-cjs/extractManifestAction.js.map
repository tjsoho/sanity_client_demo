{"version":3,"file":"extractManifestAction.js","sources":["../../src/_internal/cli/actions/manifest/extractManifestAction.ts"],"sourcesContent":["import {createHash} from 'node:crypto'\nimport {mkdir, writeFile} from 'node:fs/promises'\nimport {dirname, join, resolve} from 'node:path'\nimport {Worker} from 'node:worker_threads'\n\nimport {type CliCommandArguments, type CliCommandContext} from '@sanity/cli'\nimport {minutesToMilliseconds} from 'date-fns'\nimport readPkgUp from 'read-pkg-up'\n\nimport {\n  type CreateManifest,\n  type CreateWorkspaceManifest,\n  type ManifestWorkspaceFile,\n} from '../../../manifest/manifestTypes'\nimport {type ExtractManifestWorkerData} from '../../threads/extractManifest'\nimport {getTimer} from '../../util/timing'\n\nconst MANIFEST_FILENAME = 'create-manifest.json'\nconst SCHEMA_FILENAME_SUFFIX = '.create-schema.json'\n\n/** Escape-hatch env flags to change action behavior */\nconst FEATURE_ENABLED_ENV_NAME = 'SANITY_CLI_EXTRACT_MANIFEST_ENABLED'\nconst EXTRACT_MANIFEST_ENABLED = process.env[FEATURE_ENABLED_ENV_NAME] !== 'false'\nconst EXTRACT_MANIFEST_LOG_ERRORS = process.env.SANITY_CLI_EXTRACT_MANIFEST_LOG_ERRORS === 'true'\n\nconst CREATE_TIMER = 'create-manifest'\n\nconst EXTRACT_TASK_TIMEOUT_MS = minutesToMilliseconds(2)\n\nconst EXTRACT_FAILURE_MESSAGE =\n  \"Couldn't extract manifest file. Sanity Create will not be available for the studio.\\n\" +\n  `Disable this message with ${FEATURE_ENABLED_ENV_NAME}=false`\n\ninterface ExtractFlags {\n  path?: string\n}\n\n/**\n * This function will never throw.\n * @returns `undefined` if extract succeeded - caught error if it failed\n */\nexport async function extractManifestSafe(\n  args: CliCommandArguments<ExtractFlags>,\n  context: CliCommandContext,\n): Promise<Error | undefined> {\n  if (!EXTRACT_MANIFEST_ENABLED) {\n    return undefined\n  }\n\n  try {\n    await extractManifest(args, context)\n    return undefined\n  } catch (err) {\n    if (EXTRACT_MANIFEST_LOG_ERRORS) {\n      context.output.error(err)\n    }\n    return err\n  }\n}\n\nasync function extractManifest(\n  args: CliCommandArguments<ExtractFlags>,\n  context: CliCommandContext,\n): Promise<void> {\n  const {output, workDir} = context\n\n  const flags = args.extOptions\n  const defaultOutputDir = resolve(join(workDir, 'dist'))\n\n  const outputDir = resolve(defaultOutputDir)\n  const defaultStaticPath = join(outputDir, 'static')\n\n  const staticPath = flags.path ?? defaultStaticPath\n\n  const path = join(staticPath, MANIFEST_FILENAME)\n\n  const rootPkgPath = readPkgUp.sync({cwd: __dirname})?.path\n  if (!rootPkgPath) {\n    throw new Error('Could not find root directory for `sanity` package')\n  }\n\n  const timer = getTimer()\n  timer.start(CREATE_TIMER)\n  const spinner = output.spinner({}).start('Extracting manifest')\n\n  try {\n    const workspaceManifests = await getWorkspaceManifests({rootPkgPath, workDir})\n    await mkdir(staticPath, {recursive: true})\n\n    const workspaceFiles = await writeWorkspaceFiles(workspaceManifests, staticPath)\n\n    const manifest: CreateManifest = {\n      version: 1,\n      createdAt: new Date().toISOString(),\n      workspaces: workspaceFiles,\n    }\n\n    await writeFile(path, JSON.stringify(manifest, null, 2))\n    const manifestDuration = timer.end(CREATE_TIMER)\n\n    spinner.succeed(`Extracted manifest (${manifestDuration.toFixed()}ms)`)\n  } catch (err) {\n    spinner.info(EXTRACT_FAILURE_MESSAGE)\n    throw err\n  }\n}\n\nasync function getWorkspaceManifests({\n  rootPkgPath,\n  workDir,\n}: {\n  rootPkgPath: string\n  workDir: string\n}): Promise<CreateWorkspaceManifest[]> {\n  const workerPath = join(\n    dirname(rootPkgPath),\n    'lib',\n    '_internal',\n    'cli',\n    'threads',\n    'extractManifest.js',\n  )\n\n  const worker = new Worker(workerPath, {\n    workerData: {workDir} satisfies ExtractManifestWorkerData,\n    // eslint-disable-next-line no-process-env\n    env: process.env,\n  })\n\n  let timeout = false\n  const timeoutId = setTimeout(() => {\n    timeout = true\n    worker.terminate()\n  }, EXTRACT_TASK_TIMEOUT_MS)\n\n  try {\n    return await new Promise<CreateWorkspaceManifest[]>((resolveWorkspaces, reject) => {\n      const buffer: CreateWorkspaceManifest[] = []\n      worker.addListener('message', (message) => buffer.push(message))\n      worker.addListener('exit', (exitCode) => {\n        if (exitCode === 0) {\n          resolveWorkspaces(buffer)\n        } else if (timeout) {\n          reject(new Error(`Extract manifest was aborted after ${EXTRACT_TASK_TIMEOUT_MS}ms`))\n        }\n      })\n      worker.addListener('error', reject)\n    })\n  } finally {\n    clearTimeout(timeoutId)\n  }\n}\n\nfunction writeWorkspaceFiles(\n  manifestWorkspaces: CreateWorkspaceManifest[],\n  staticPath: string,\n): Promise<ManifestWorkspaceFile[]> {\n  const output = manifestWorkspaces.reduce<Promise<ManifestWorkspaceFile>[]>(\n    (workspaces, workspace) => {\n      return [...workspaces, writeWorkspaceSchemaFile(workspace, staticPath)]\n    },\n    [],\n  )\n  return Promise.all(output)\n}\n\nasync function writeWorkspaceSchemaFile(\n  workspace: CreateWorkspaceManifest,\n  staticPath: string,\n): Promise<ManifestWorkspaceFile> {\n  const schemaString = JSON.stringify(workspace.schema, null, 2)\n  const hash = createHash('sha1').update(schemaString).digest('hex')\n  const filename = `${hash.slice(0, 8)}${SCHEMA_FILENAME_SUFFIX}`\n\n  // workspaces with identical schemas will overwrite each others schema file. This is ok, since they are identical and can be shared\n  await writeFile(join(staticPath, filename), schemaString)\n\n  return {\n    ...workspace,\n    schema: filename,\n  }\n}\n"],"names":["minutesToMilliseconds","resolve","join","path","readPkgUp","getTimer","mkdir","writeFile","dirname","Worker","createHash"],"mappings":"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"}