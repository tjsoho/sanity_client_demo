"use strict";
var jsxRuntime = require("react/jsx-runtime"), PresentationToolGrantsCheck = require("./PresentationToolGrantsCheck.cjs"), hooks = require("./hooks.cjs"), client = require("@sanity/client"), csm = require("@sanity/client/csm"), comlink = require("@sanity/comlink"), isEqual = require("fast-deep-equal"), react = require("react"), sanity = require("sanity"), useEffectEvent = require("use-effect-event"), index = require("./index.cjs");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var isEqual__default = /* @__PURE__ */ _interopDefaultCompat(isEqual);
function LoaderQueries(props) {
  const {
    liveDocument: _liveDocument,
    controller,
    perspective: activePerspective,
    onLoadersConnection,
    onDocumentsOnPage
  } = props, [comlink$1, setComlink] = react.useState(), [liveQueries, setLiveQueries] = react.useState({}), projectId = sanity.useProjectId(), dataset = sanity.useDataset();
  react.useEffect(() => {
    const interval = setInterval(
      () => setLiveQueries((liveQueries2) => {
        if (Object.keys(liveQueries2).length < 1)
          return liveQueries2;
        const now = Date.now();
        if (!Object.values(liveQueries2).some(
          (liveQuery) => liveQuery.heartbeat !== !1 && now > liveQuery.receivedAt + liveQuery.heartbeat
        ))
          return liveQueries2;
        const next = {};
        for (const [key, value] of Object.entries(liveQueries2))
          value.heartbeat !== !1 && now > value.receivedAt + value.heartbeat || (next[key] = value);
        return next;
      }),
      index.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL
    );
    return () => clearInterval(interval);
  }, []), react.useEffect(() => {
    if (controller) {
      const comlink2 = controller.createConnection(
        {
          name: "presentation",
          connectTo: "loaders",
          heartbeat: !0
        },
        comlink.createChannelMachine().provide({
          actors: PresentationToolGrantsCheck.createCompatibilityActors()
        })
      );
      return setComlink(comlink2), comlink2.onStatus(onLoadersConnection), comlink2.on("loader/documents", (data) => {
        data.projectId === projectId && data.dataset === dataset && onDocumentsOnPage(
          "loaders",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          data.perspective,
          data.documents
        );
      }), comlink2.on("loader/query-listen", (data) => {
        if (data.projectId === projectId && data.dataset === dataset) {
          if (typeof data.heartbeat == "number" && data.heartbeat < index.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL)
            throw new Error(
              `Loader query listen heartbeat interval must be at least ${index.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`
            );
          setLiveQueries((prev) => ({
            ...prev,
            [PresentationToolGrantsCheck.getQueryCacheKey(data.query, data.params)]: {
              perspective: data.perspective,
              query: data.query,
              params: data.params,
              receivedAt: Date.now(),
              heartbeat: data.heartbeat ?? !1
            }
          }));
        }
      }), comlink2.start();
    }
  }, [controller, dataset, onDocumentsOnPage, onLoadersConnection, projectId]);
  const [syncTagsInUse] = react.useState(() => /* @__PURE__ */ new Set()), [lastLiveEventId, setLastLiveEventId] = react.useState(null), studioClient = sanity.useClient({ apiVersion: "2023-10-16" }), clientConfig = react.useMemo(() => studioClient.config(), [studioClient]), client$1 = react.useMemo(
    () => studioClient.withConfig({
      resultSourceMap: "withKeyArraySelector"
    }),
    [studioClient]
  );
  react.useEffect(() => {
    if (comlink$1) {
      const { projectId: projectId2, dataset: dataset2 } = clientConfig;
      comlink$1.post({
        type: "loader/perspective",
        data: {
          projectId: projectId2,
          dataset: dataset2,
          perspective: activePerspective
        }
      });
    }
  }, [comlink$1, clientConfig, activePerspective]);
  const handleSyncTags = useEffectEvent.useEffectEvent((event) => {
    const flattenedSyncTags = Array.from(syncTagsInUse).flat();
    event.tags.some((tag) => flattenedSyncTags.includes(tag)) ? setLastLiveEventId(event.id) : console.log("No matching tags found", event.tags, { flattenedSyncTags });
  });
  react.useEffect(() => {
    const subscription = client.createClient(client$1.config()).withConfig({
      // Necessary for the live drafts to work
      apiVersion: "vX"
    }).live.events({ includeDrafts: !0, tag: "presentation-loader" }).subscribe({
      next: (event) => {
        event.type === "message" ? handleSyncTags(event) : event.type === "restart" ? setLastLiveEventId(event.id) : event.type === "reconnect" && setLastLiveEventId(null);
      },
      // eslint-disable-next-line no-console
      error: (err) => console.error("Error validating EventSource URL:", err)
    });
    return () => subscription.unsubscribe();
  }, [client$1, handleSyncTags]);
  const liveDocument = react.useDeferredValue(_liveDocument);
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: Object.entries(liveQueries).map(([key, { query, params, perspective }]) => /* @__PURE__ */ jsxRuntime.jsx(
    QuerySubscription,
    {
      projectId: clientConfig.projectId,
      dataset: clientConfig.dataset,
      perspective,
      query,
      params,
      comlink: comlink$1,
      client: client$1,
      liveDocument,
      lastLiveEventId,
      syncTagsInUse
    },
    `${key}${perspective}`
  )) });
}
function QuerySubscriptionComponent(props) {
  const {
    projectId,
    dataset,
    perspective,
    query,
    client: client2,
    liveDocument,
    comlink: comlink2,
    lastLiveEventId,
    syncTagsInUse
  } = props, params = hooks.useQueryParams(props.params), {
    result,
    resultSourceMap,
    syncTags: tags
  } = useQuerySubscription({
    client: client2,
    liveDocument,
    params,
    perspective,
    query,
    lastLiveEventId
  }) || {}, handleQueryChange = useEffectEvent.useEffectEvent(
    (comlink22, perspective2, query2, params2, result2, resultSourceMap2, tags2) => {
      comlink22?.post({
        type: "loader/query-change",
        data: {
          projectId,
          dataset,
          perspective: perspective2,
          query: query2,
          params: params2,
          result: result2,
          resultSourceMap: resultSourceMap2,
          tags: tags2
        }
      });
    }
  );
  return react.useEffect(() => {
    if (resultSourceMap && handleQueryChange(comlink2, perspective, query, params, result, resultSourceMap, tags), Array.isArray(tags))
      return syncTagsInUse.add(tags), () => {
        syncTagsInUse.delete(tags);
      };
  }, [
    comlink2,
    handleQueryChange,
    params,
    perspective,
    query,
    result,
    resultSourceMap,
    syncTagsInUse,
    tags
  ]), null;
}
const QuerySubscription = react.memo(QuerySubscriptionComponent);
QuerySubscription.displayName = "Memo(QuerySubscription)";
function useQuerySubscription(props) {
  const { liveDocument, client: client2, query, params, perspective, lastLiveEventId } = props, [snapshot, setSnapshot] = react.useState(null), [error, setError] = react.useState(null);
  if (error) throw error;
  const [revalidate, startRefresh] = hooks.useRevalidate({
    // Refresh interval is set to zero as we're using the Live Draft Content API to revalidate queries
    refreshInterval: 0
  }), shouldRefetch = revalidate === "refresh" || revalidate === "inflight" || lastLiveEventId !== snapshot?.lastLiveEventId;
  react.useEffect(() => {
    if (!shouldRefetch)
      return;
    let fulfilled = !1, fetching = !1;
    const controller = new AbortController();
    async function effect() {
      const { signal } = controller;
      fetching = !0;
      const { result: result2, resultSourceMap: resultSourceMap2, syncTags: syncTags2 } = await client2.fetch(query, params, {
        lastLiveEventId,
        tag: "presentation-loader",
        signal,
        perspective,
        filterResponse: !1,
        returnQuery: !1
      });
      fetching = !1, signal.aborted || (setSnapshot((prev) => ({
        result: isEqual__default.default(prev?.result, result2) ? prev?.result : result2,
        resultSourceMap: isEqual__default.default(prev?.resultSourceMap, resultSourceMap2) ? prev?.resultSourceMap : resultSourceMap2,
        syncTags: isEqual__default.default(prev?.syncTags, syncTags2) ? prev?.syncTags : syncTags2,
        lastLiveEventId
      })), fulfilled = !0);
    }
    const onFinally = startRefresh();
    return effect().catch((error2) => {
      fetching = !1, error2.name !== "AbortError" && setError(error2);
    }).finally(onFinally), () => {
      !fulfilled && !fetching && controller.abort();
    };
  }, [client2, lastLiveEventId, params, perspective, query, shouldRefetch, startRefresh]);
  const { result, resultSourceMap, syncTags } = snapshot ?? {};
  return react.useMemo(() => liveDocument && resultSourceMap ? {
    result: turboChargeResultIfSourceMap(liveDocument, result, perspective, resultSourceMap),
    resultSourceMap,
    syncTags
  } : { result, resultSourceMap, syncTags }, [liveDocument, perspective, result, resultSourceMap, syncTags]);
}
function turboChargeResultIfSourceMap(liveDocument, result, perspective, resultSourceMap) {
  if (perspective === "raw")
    throw new Error("turboChargeResultIfSourceMap does not support raw perspective");
  return csm.applySourceDocuments(
    result,
    resultSourceMap,
    (sourceDocument) => {
      if (
        // If _projectId is set, it's a cross dataset reference and we should skip it
        !sourceDocument._projectId && liveDocument?._id && csm.getPublishedId(liveDocument._id) === csm.getPublishedId(sourceDocument._id)
      )
        return liveDocument;
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (changedValue, { previousValue }) => typeof changedValue == "number" && typeof previousValue == "string" ? `${changedValue}` : changedValue,
    perspective
  );
}
exports.default = LoaderQueries;
exports.turboChargeResultIfSourceMap = turboChargeResultIfSourceMap;
//# sourceMappingURL=LiveQueries.cjs.map
