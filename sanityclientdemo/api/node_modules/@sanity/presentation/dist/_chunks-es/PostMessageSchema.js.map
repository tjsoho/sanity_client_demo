{"version":3,"file":"PostMessageSchema.js","sources":["../../src/overlays/schema/helpers.ts","../../src/overlays/schema/SchemaIcon.tsx","../../src/overlays/schema/extract.ts","../../src/overlays/schema/PostMessageSchema.tsx"],"sourcesContent":["import {\n  type ArraySchemaType,\n  type NumberSchemaType,\n  type ObjectField,\n  type ObjectFieldType,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type Rule,\n  type SchemaType as SanitySchemaType,\n  type Schema as SchemaDef,\n  type StringSchemaType,\n} from '@sanity/types'\nimport {type SchemaType} from 'groq-js'\n\nexport function isFieldRequired(field: ObjectField): boolean {\n  const {validation} = field.type\n  if (!validation) {\n    return false\n  }\n  const rules = Array.isArray(validation) ? validation : [validation]\n  for (const rule of rules) {\n    let required = false\n\n    // hack to check if a field is required. We create a proxy that returns itself when a method is called,\n    // if the method is \"required\" we set a flag\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => {\n          if (methodName === 'required') {\n            required = true\n          }\n          return proxy\n        },\n      },\n    ) as Rule\n\n    if (typeof rule === 'function') {\n      rule(proxy)\n      if (required) {\n        return true\n      }\n    }\n\n    if (typeof rule === 'object' && rule !== null && '_required' in rule) {\n      if (rule._required === 'required') {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction isType(\n  typeDef: SanitySchemaType | ObjectField | ObjectFieldType,\n  typeName: string,\n): boolean {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (type.name === typeName || (type.type && type.type.name === typeName)) {\n      return true\n    }\n\n    type = type.type\n  }\n  return false\n}\n\nexport function isObjectType(typeDef: SanitySchemaType): typeDef is ObjectSchemaType {\n  return isType(typeDef, 'object') || typeDef.jsonType === 'object' || 'fields' in typeDef\n}\nexport function isArrayType(typeDef: SanitySchemaType): typeDef is ArraySchemaType {\n  return isType(typeDef, 'array')\n}\nexport function isReferenceType(typeDef: SanitySchemaType): typeDef is ReferenceSchemaType {\n  return isType(typeDef, 'reference')\n}\n// @todo\nexport function isCrossDatasetReferenceType(typeDef: SanitySchemaType): boolean {\n  return isType(typeDef, 'crossDatasetReference')\n}\nexport function isStringType(typeDef: SanitySchemaType): typeDef is StringSchemaType {\n  return isType(typeDef, 'string')\n}\nexport function isNumberType(typeDef: SanitySchemaType): typeDef is NumberSchemaType {\n  return isType(typeDef, 'number')\n}\n\n// Traverse the type tree and return the \"last\" type, ie deepest type in the tree\nexport function lastType(typeDef: SanitySchemaType): SanitySchemaType | undefined {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (!type.type) {\n      return type\n    }\n    type = type.type\n  }\n\n  return undefined\n}\n\n// Traverse the type tree and gather all the fields\nexport function gatherFields(type: SanitySchemaType | ObjectSchemaType): ObjectField[] {\n  if ('fields' in type) {\n    return type.type ? gatherFields(type.type).concat(type.fields) : type.fields\n  }\n\n  return []\n}\n\n// Sorts the types by their dependencies by using a topological sort depth-first algorithm.\nexport function sortByDependencies(compiledSchema: SchemaDef): string[] {\n  const seen = new Set<SanitySchemaType>()\n\n  // Walks the dependencies of a schema type and adds them to the dependencies set\n  function walkDependencies(\n    schemaType: SanitySchemaType,\n    dependencies: Set<SanitySchemaType>,\n  ): void {\n    if (seen.has(schemaType)) {\n      return\n    }\n    seen.add(schemaType)\n\n    if ('fields' in schemaType) {\n      for (const field of gatherFields(schemaType)) {\n        const last = lastType(field.type)\n        if (last!.name === 'document') {\n          dependencies.add(last!)\n          continue\n        }\n\n        let schemaTypeName: string | undefined\n        if (schemaType.type!.type) {\n          schemaTypeName = field.type.type!.name\n        } else if ('jsonType' in schemaType.type!) {\n          schemaTypeName = field.type.jsonType\n        }\n\n        if (schemaTypeName === 'object' || schemaTypeName === 'block') {\n          if (isReferenceType(field.type)) {\n            field.type.to.forEach((ref) => dependencies.add(ref.type!))\n          } else {\n            dependencies.add(field.type)\n          }\n        }\n        walkDependencies(field.type, dependencies)\n      }\n    } else if ('of' in schemaType) {\n      for (const item of schemaType.of) {\n        walkDependencies(item, dependencies)\n      }\n    }\n  }\n  const dependencyMap = new Map<SanitySchemaType, Set<SanitySchemaType>>()\n  compiledSchema.getTypeNames().forEach((typeName) => {\n    const schemaType = compiledSchema.get(typeName)\n    if (schemaType === undefined || schemaType.type === null) {\n      return\n    }\n    const dependencies = new Set<SanitySchemaType>()\n\n    walkDependencies(schemaType, dependencies)\n    dependencyMap.set(schemaType, dependencies)\n    seen.clear() // Clear the seen set for the next type\n  })\n\n  // Sorts the types by their dependencies\n  const typeNames: string[] = []\n  // holds a temporary mark for types that are currently being visited, to detect cyclic dependencies\n  const currentlyVisiting = new Set<SanitySchemaType>()\n\n  // holds a permanent mark for types that have been already visited\n  const visited = new Set<SanitySchemaType>()\n\n  // visit implements a depth-first search\n  function visit(type: SanitySchemaType) {\n    if (visited.has(type)) {\n      return\n    }\n    // If we find a type that is already in the temporary mark, we have a cyclic dependency.\n    if (currentlyVisiting.has(type)) {\n      return\n    }\n    // mark this as a temporary mark, meaning it's being visited\n    currentlyVisiting.add(type)\n    const deps = dependencyMap.get(type)\n    if (deps !== undefined) {\n      deps.forEach((dep) => visit(dep))\n    }\n    currentlyVisiting.delete(type)\n    visited.add(type)\n\n    if (!typeNames.includes(type.name)) {\n      typeNames.unshift(type.name)\n    }\n  }\n  // Visit all types in the dependency map\n  for (const [type] of dependencyMap) {\n    visit(type)\n  }\n\n  return typeNames\n}\n","import {type SchemaType as SanitySchemaType} from '@sanity/types'\nimport {ThemeProvider, type ThemeContextValue} from '@sanity/ui'\nimport {createElement, type FunctionComponent} from 'react'\nimport {ServerStyleSheet, StyleSheetManager} from 'styled-components'\n\nexport const SchemaIcon: FunctionComponent<{\n  schemaType: SanitySchemaType\n  theme: ThemeContextValue\n}> = function SchemaIcon({schemaType, theme: themeContext}) {\n  const {theme, scheme, tone} = themeContext\n  const sheet = new ServerStyleSheet()\n\n  return schemaType.icon ? (\n    <StyleSheetManager sheet={sheet.instance}>\n      <ThemeProvider theme={theme} scheme={scheme} tone={tone}>\n        {createElement(schemaType.icon)}\n      </ThemeProvider>\n    </StyleSheetManager>\n  ) : null\n}\n","import type {\n  SchemaArrayNode,\n  SchemaBooleanNode,\n  SchemaInlineNode,\n  SchemaNode,\n  SchemaNullNode,\n  SchemaNumberNode,\n  SchemaObjectField,\n  SchemaObjectNode,\n  SchemaStringNode,\n  SchemaType,\n  SchemaUnionNode,\n  SchemaUnionNodeOptions,\n  SchemaUnionOption,\n  SchemaUnknownNode,\n} from '@repo/visual-editing-helpers'\nimport type {InsertMenuOptions} from '@sanity/insert-menu'\nimport type {\n  ArraySchemaType,\n  NumberSchemaType,\n  ObjectSchemaType,\n  ReferenceSchemaType,\n  SchemaType as SanitySchemaType,\n  StringSchemaType,\n} from '@sanity/types'\nimport type {ThemeContextValue} from '@sanity/ui'\nimport {createElement} from 'react'\nimport {renderToString} from 'react-dom/server'\nimport type {Workspace} from 'sanity'\nimport {\n  gatherFields,\n  isArrayType,\n  isCrossDatasetReferenceType,\n  isFieldRequired,\n  isNumberType,\n  isObjectType,\n  isReferenceType,\n  isStringType,\n  lastType,\n  sortByDependencies,\n} from './helpers'\nimport {SchemaIcon} from './SchemaIcon'\n\nconst documentDefaultFields = (typeName: string): Record<string, SchemaObjectField> => ({\n  _id: {\n    type: 'objectField',\n    name: '_id',\n    value: {\n      type: 'string',\n    },\n  },\n  _type: {\n    type: 'objectField',\n    name: '_type',\n    value: {\n      type: 'string',\n      value: typeName,\n    },\n  },\n  _createdAt: {\n    type: 'objectField',\n    name: '_createdAt',\n    value: {\n      type: 'string',\n    },\n  },\n  _updatedAt: {\n    type: 'objectField',\n    name: '_updatedAt',\n    value: {\n      type: 'string',\n    },\n  },\n  _rev: {\n    type: 'objectField',\n    name: '_rev',\n    value: {\n      type: 'string',\n    },\n  },\n})\n\nfunction createStringNodeDefintion(\n  stringSchemaType: StringSchemaType,\n): SchemaStringNode | SchemaUnionNode<SchemaStringNode> {\n  const listOptions = stringSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'string',\n        value: typeof v === 'string' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'string',\n  }\n}\n\nfunction createNumberNodeDefintion(\n  numberSchemaType: NumberSchemaType,\n): SchemaNumberNode | SchemaUnionNode<SchemaNumberNode> {\n  const listOptions = numberSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'number',\n        value: typeof v === 'number' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'number',\n  }\n}\n\nfunction createReferenceNode(name: string, inArray: boolean = false): SchemaObjectNode {\n  const fields: Record<string, SchemaObjectField> = {\n    _ref: {\n      type: 'objectField',\n      name: '_ref',\n      value: {\n        type: 'string',\n      },\n    },\n    _type: {\n      type: 'objectField',\n      name: '_type',\n      value: {\n        type: 'string',\n        value: 'reference',\n      },\n    },\n    _weak: {\n      type: 'objectField',\n      name: '_weak',\n      value: {\n        type: 'boolean',\n      },\n      optional: true,\n    },\n  }\n\n  if (inArray) {\n    fields['_key'] = {\n      type: 'objectField',\n      name: '_key',\n      value: {\n        type: 'string',\n      },\n    } satisfies SchemaObjectField\n  }\n\n  return {\n    type: 'object',\n    fields,\n    dereferencesTo: name,\n  } satisfies SchemaObjectNode\n}\n\nfunction createReferenceNodeDefintion(\n  reference: ReferenceSchemaType,\n): SchemaObjectNode | SchemaUnionNode<SchemaObjectNode> {\n  const references = gatherReferenceNames(reference)\n  if (references.length === 1) {\n    return createReferenceNode(references[0])\n  }\n\n  return {\n    type: 'union',\n    of: references.map((name) => ({\n      type: 'unionOption',\n      name,\n      value: createReferenceNode(name),\n    })),\n  }\n}\n\n// Traverse the reference type tree and gather all the reference names\nfunction gatherReferenceNames(type: ReferenceSchemaType): string[] {\n  const allReferences = gatherReferenceTypes(type)\n  // Remove duplicates\n  return [...new Set([...allReferences.map((ref) => ref.name)])]\n}\n\nfunction gatherReferenceTypes(type: ReferenceSchemaType): ObjectSchemaType[] {\n  const refTo = 'to' in type ? type.to : []\n  if ('type' in type && isReferenceType(type.type!)) {\n    return [...gatherReferenceTypes(type.type), ...refTo]\n  }\n\n  return refTo\n}\n\nconst typesMap = new Map<string, Omit<SchemaStringNode, 'name'> | Omit<SchemaBooleanNode, 'name'>>([\n  ['text', {type: 'string'}],\n  ['url', {type: 'string'}],\n  ['datetime', {type: 'string'}],\n  ['date', {type: 'string'}],\n  ['boolean', {type: 'boolean'}],\n  ['email', {type: 'string'}],\n])\n\nexport function extractSchema(workspace: Workspace, theme: ThemeContextValue): SchemaType[] {\n  const inlineFields = new Set<SanitySchemaType>()\n  const {schema: schemaDef, basePath} = workspace\n\n  const sortedSchemaTypeNames = sortByDependencies(schemaDef)\n  return sortedSchemaTypeNames\n    .map((typeName) => {\n      const schemaType = schemaDef.get(typeName)\n      if (schemaType === undefined) {\n        return\n      }\n      const base = convertBaseType(schemaType)\n\n      if (base === null) {\n        return\n      }\n\n      if (base.type === 'type') {\n        inlineFields.add(schemaType)\n      }\n\n      return base\n    })\n    .filter((type: SchemaType | undefined): type is SchemaType => type !== undefined)\n\n  function extractIcon(schemaType: SanitySchemaType): string | undefined {\n    if (!schemaType.icon) return undefined\n    return renderToString(createElement(SchemaIcon, {schemaType, theme}))\n  }\n\n  function convertBaseType(schemaType: SanitySchemaType): SchemaType | null {\n    let typeName: string | undefined\n    if (schemaType.type) {\n      typeName = schemaType.type.name\n    } else if ('jsonType' in schemaType) {\n      typeName = schemaType.jsonType\n    }\n\n    if (typeName === 'document') {\n      const object = createObject(schemaType)\n      if (object.type === 'unknown') {\n        return null\n      }\n\n      return {\n        type: 'document',\n        name: schemaType.name,\n        title: typeof schemaType.title === 'string' ? schemaType.title : undefined,\n        icon: extractIcon(schemaType),\n        fields: {\n          ...documentDefaultFields(schemaType.name),\n          ...object.fields,\n        },\n      }\n    }\n\n    const value = convertSchemaType(schemaType)\n    if (value.type === 'unknown') {\n      return null\n    }\n\n    if (value.type === 'object') {\n      return {\n        name: schemaType.name,\n        type: 'type',\n        value: {\n          type: 'object',\n          fields: {\n            _type: {\n              type: 'objectField',\n              name: '_type',\n              value: {\n                type: 'string',\n                value: schemaType.name,\n              },\n            },\n            ...value.fields,\n          },\n        },\n      }\n    }\n\n    return {\n      name: schemaType.name,\n      title: typeof schemaType.title === 'string' ? schemaType.title : undefined,\n      type: 'type',\n      value,\n    }\n  }\n\n  function createObject(\n    schemaType: ObjectSchemaType | SanitySchemaType,\n  ): SchemaObjectNode | SchemaUnknownNode {\n    const fields: Record<string, SchemaObjectField> = {}\n\n    for (const field of gatherFields(schemaType)) {\n      const value = convertSchemaType(field.type)\n      if (value === null) {\n        continue\n      }\n\n      fields[field.name] = {\n        type: 'objectField',\n        name: field.name,\n        title: typeof field.type.title === 'string' ? field.type.title : undefined,\n        value,\n        optional: isFieldRequired(field) === false,\n      }\n    }\n\n    return {\n      type: 'object',\n      fields,\n    }\n  }\n\n  function convertSchemaType(schemaType: SanitySchemaType): SchemaNode {\n    if (lastType(schemaType)?.name === 'document') {\n      return createReferenceNode(schemaType.name)\n    }\n\n    if (inlineFields.has(schemaType.type!)) {\n      return {type: 'inline', name: schemaType.type!.name} satisfies SchemaInlineNode\n    }\n\n    if (schemaType.type?.type?.name === 'object') {\n      return {type: 'inline', name: schemaType.type.name} satisfies SchemaInlineNode\n    }\n\n    if (isStringType(schemaType)) {\n      return createStringNodeDefintion(schemaType)\n    }\n\n    if (isNumberType(schemaType)) {\n      return createNumberNodeDefintion(schemaType)\n    }\n\n    const mapped = typesMap.get(schemaType.type?.name || '')\n    if (mapped) {\n      return mapped\n    }\n\n    if (schemaType.type && typesMap.has(schemaType.type.name)) {\n      return typesMap.get(schemaType.type.name)!\n    }\n\n    // Cross dataset references are not supported\n    if (isCrossDatasetReferenceType(schemaType)) {\n      return {type: 'unknown'} satisfies SchemaUnknownNode // we don't support cross-dataset references at the moment\n    }\n\n    if (isReferenceType(schemaType)) {\n      return createReferenceNodeDefintion(schemaType)\n    }\n\n    if (isArrayType(schemaType)) {\n      return createArray(schemaType)\n    }\n\n    if (isObjectType(schemaType)) {\n      return createObject(schemaType)\n    }\n\n    throw new Error(`Type \"${schemaType.name}\" not found`)\n  }\n\n  function createUnionNodeOptions(\n    schemaType: ArraySchemaType,\n    of: SchemaUnionOption<SchemaNode>[],\n  ): SchemaUnionNodeOptions | undefined {\n    const {options} = schemaType\n    if (!options) return undefined\n    const opts = {\n      ...options,\n    }\n    if (options.insertMenu) {\n      opts.insertMenu = {\n        ...options.insertMenu,\n        views: (options.insertMenu as InsertMenuOptions).views?.map((view) =>\n          view.name === 'grid'\n            ? {\n                name: 'grid',\n                previewImageUrls: view.previewImageUrl\n                  ? of.reduce(\n                      (acc, {name}) => {\n                        const url = view.previewImageUrl?.(name)\n                        if (!url) return acc\n                        // If the URL is relative, make it absolute\n                        try {\n                          new URL(url)\n                          acc[name] = url\n                        } catch {\n                          acc[name] = new URL(\n                            url,\n                            `${window.location.origin}${basePath ? `${basePath}/` : ''}`,\n                          ).toString()\n                        }\n                        return acc\n                      },\n                      {} as Record<string, string | undefined>,\n                    )\n                  : undefined,\n              }\n            : view,\n        ),\n      }\n    }\n    return opts\n  }\n\n  function createArray(\n    arraySchemaType: ArraySchemaType,\n  ): SchemaArrayNode | SchemaUnionNode | SchemaNullNode {\n    const of: SchemaUnionOption[] = []\n    for (const item of arraySchemaType.of) {\n      let field = convertSchemaType(item)\n      const option = {\n        type: 'unionOption',\n        icon: extractIcon(item),\n        name: item.name,\n        title: typeof item.title === 'string' ? item.title : undefined,\n        value: field,\n      } satisfies SchemaUnionOption\n      if (field.type === 'inline') {\n        field = {\n          type: 'object',\n          fields: {\n            _key: createKeyField(),\n          },\n          rest: field,\n        } satisfies SchemaObjectNode\n      } else if (field.type === 'object') {\n        field.rest = {\n          type: 'object',\n          fields: {\n            _key: createKeyField(),\n          },\n        }\n      }\n      option.value = field\n      of.push(option)\n    }\n\n    if (of.length === 0) {\n      return {type: 'null'}\n    }\n\n    if (of.length > 1) {\n      return {\n        type: 'union',\n        of,\n        options: createUnionNodeOptions(arraySchemaType, of),\n      }\n    }\n\n    const {name, title, value} = of[0]\n    return {\n      type: 'array',\n      of: {\n        type: 'arrayItem',\n        name,\n        title: typeof title === 'string' ? title : undefined,\n        value,\n      },\n    }\n  }\n}\n\nfunction createKeyField(): SchemaObjectField<SchemaStringNode> {\n  return {\n    type: 'objectField',\n    name: '_key',\n    value: {\n      type: 'string',\n    },\n  }\n}\n","import type {UnresolvedPath} from '@repo/visual-editing-helpers'\nimport type {ClientPerspective} from '@sanity/client'\nimport {useRootTheme} from '@sanity/ui'\nimport {memo, useEffect} from 'react'\nimport {API_VERSION} from '../../constants'\nimport {useClient, useWorkspace} from '../../internals'\nimport type {VisualEditingConnection} from '../../types'\nimport {extractSchema} from './extract'\n\nexport interface PostMessageSchemaProps {\n  comlink: VisualEditingConnection\n  perspective: ClientPerspective\n}\n\nfunction getDocumentPathArray(paths: UnresolvedPath[]) {\n  const documentPathMap = paths.reduce(\n    (acc, {id, path}) => {\n      if (acc[id]) {\n        acc[id].add(path)\n      } else {\n        acc[id] = new Set<string>([path])\n      }\n      return acc\n    },\n    {} as Record<string, Set<string>>,\n  )\n\n  return Object.entries(documentPathMap)\n}\n\n/**\n * Experimental approach for sending a representation of the workspace schema\n * over postMessage so it can be used to enrich the Visual Editing experience\n */\nfunction PostMessageSchema(props: PostMessageSchemaProps): JSX.Element | null {\n  const {comlink, perspective} = props\n\n  const workspace = useWorkspace()\n  const theme = useRootTheme()\n\n  // Send a representation of the schema to the visual editing context\n  useEffect(() => {\n    const schema = extractSchema(workspace, theme)\n    /**\n     * @deprecated switch to explict schema fetching (using\n     * 'visual-editing/schema') at next major\n     */\n    comlink.post({type: 'presentation/schema', data: {schema}})\n\n    return comlink.on('visual-editing/schema', () => ({schema}))\n  }, [comlink, theme, workspace])\n\n  const client = useClient({apiVersion: API_VERSION})\n\n  // Resolve union types from an array of unresolved paths\n  useEffect(() => {\n    return comlink.on('visual-editing/schema-union-types', async (data) => {\n      const documentPathArray = getDocumentPathArray(data.paths)\n      const unionTypes = await Promise.all(\n        documentPathArray.map(async ([id, paths]) => {\n          const arr = Array.from(paths)\n          const projection = arr.map((path, i) => `\"${i}\": ${path}[0]._type`).join(',')\n          const query = `*[_id == $id][0]{${projection}}`\n          const result = await client.fetch(query, {id}, {perspective, tag: 'presentation-schema'})\n          const mapped = arr.map((path, i) => ({path: path, type: result[i]}))\n          return {id, paths: mapped}\n        }),\n      )\n\n      const newState = new Map()\n      unionTypes.forEach((action) => {\n        newState.set(action.id, new Map(action.paths.map(({path, type}) => [path, type])))\n      })\n      return {types: newState}\n    })\n  }, [comlink, client, perspective])\n\n  return null\n}\n\nexport default memo(PostMessageSchema)\n"],"names":[],"mappings":"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"}