"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("uuid"),t=require("xstate"),s=require("rxjs");const n=e=>({context:t})=>{const{count:s,include:n,exclude:a,responseType:r="message.received"}=e;return{count:s,domain:t.domain,from:t.connectTo,include:n?Array.isArray(n)?n:[n]:[],exclude:a?Array.isArray(a)?a:[a]:[],responseType:r,target:t.target,to:t.name}},a=s.defer((()=>s.fromEvent(window,"message"))),r=e=>t.fromEventObservable((({input:t})=>{return a.pipe(e?s.map(e):s.pipe(),s.filter((e=>t=>{const{data:s}=t;return(!e.include.length||e.include.includes(s.type))&&(!e.exclude.length||!e.exclude.includes(s.type))&&s.domain===e.domain&&s.from===e.from&&s.to===e.to&&(!e.target||t.source===e.target)})(t)),s.map((n=t.responseType,e=>({type:n,message:e}))),t.count?s.pipe(s.bufferCount(t.count),s.concatMap((e=>e)),s.take(t.count)):s.pipe());var n})),o="sanity/comlink",i="comlink/response",c="comlink/heartbeat",d="comlink/disconnect",u="comlink/handshake/syn",p="comlink/handshake/syn-ack",l="comlink/handshake/ack",g=[u,p,l],f=[i,d,c,...g],m=()=>t.setup({types:{},actors:{listen:t.fromEventObservable((({input:e})=>{const t=e.signal?s.fromEvent(e.signal,"abort").pipe((n=`Request ${e.requestId} aborted`,e=>e.pipe(s.take(1),s.map((()=>{throw new Error(n)}))))):s.EMPTY;var n;return s.fromEvent(window,"message").pipe(s.filter((t=>t.data?.type===i&&t.data?.responseTo===e.requestId&&!!t.source&&e.sources.has(t.source))),s.take(e.sources.size),s.takeUntil(t))}))},actions:{"send message":({context:e},t)=>{const{sources:s,targetOrigin:n}=e,{message:a}=t;s.forEach((e=>{e.postMessage(a,{targetOrigin:n})}))},"on success":t.sendTo((({context:e})=>e.parentRef),(({context:e,self:t})=>(e.response&&e.resolvable?.resolve(e.response),{type:"request.success",requestId:t.id,response:e.response,responseTo:e.responseTo}))),"on fail":t.sendTo((({context:e})=>e.parentRef),(({context:e,self:t})=>(console.warn(`Received no response to message '${e.type}' on client '${e.from}' (ID: '${e.id}').`),e.resolvable?.reject(new Error("No response received")),{type:"request.failed",requestId:t.id}))),"on abort":t.sendTo((({context:e})=>e.parentRef),(({context:e,self:t})=>(e.resolvable?.reject(new Error("Request aborted")),{type:"request.aborted",requestId:t.id})))},guards:{expectsResponse:({context:e})=>e.expectResponse},delays:{initialTimeout:0,responseTimeout:1e4}}).createMachine({context:({input:t})=>({connectionId:t.connectionId,data:t.data,domain:t.domain,expectResponse:t.expectResponse??!1,from:t.from,id:`msg-${e.v4()}`,parentRef:t.parentRef,resolvable:t.resolvable,response:null,responseTo:t.responseTo,signal:t.signal,sources:t.sources instanceof Set?t.sources:new Set([t.sources]),targetOrigin:t.targetOrigin,to:t.to,type:t.type}),initial:"idle",on:{abort:".aborted"},states:{idle:{after:{initialTimeout:[{target:"sending"}]}},sending:{entry:{type:"send message",params:({context:e})=>{const{connectionId:t,data:s,domain:n,from:a,id:r,responseTo:o,to:i,type:c}=e;return{message:{connectionId:t,data:s,domain:n,from:a,id:r,to:i,type:c,responseTo:o}}}},always:[{guard:"expectsResponse",target:"awaiting"},"success"]},awaiting:{invoke:{id:"listen for response",src:"listen",input:({context:e})=>({requestId:e.id,sources:e.sources,signal:e.signal}),onError:"aborted"},after:{responseTimeout:"failed"},on:{message:{actions:t.assign({response:({event:e})=>e.data.data,responseTo:({event:e})=>e.data.responseTo}),target:"success"}}},failed:{type:"final",entry:"on fail"},success:{type:"final",entry:"on success"},aborted:{type:"final",entry:"on abort"}},output:({context:e,self:t})=>({requestId:t.id,response:e.response,responseTo:e.responseTo})}),h=t.fromCallback((({sendBack:e,input:t})=>{const s=()=>{e(t.event)};t.immediate&&s();const n=setInterval(s,t.interval);return()=>{clearInterval(n)}})),v=()=>t.setup({types:{},actors:{requestMachine:m(),listen:r(),sendBackAtInterval:h},actions:{"buffer message":t.enqueueActions((({enqueue:e})=>{e.assign({buffer:({event:e,context:s})=>(t.assertEvent(e,"post"),[...s.buffer,e.data])}),e.emit((({event:e})=>(t.assertEvent(e,"post"),{type:"_buffer.added",message:e.data})))})),"create request":t.assign({requests:({context:s,event:n,self:a,spawn:r})=>{t.assertEvent(n,"request");const o=(Array.isArray(n.data)?n.data:[n.data]).map((t=>{const n=`req-${e.v4()}`;return r("requestMachine",{id:n,input:{connectionId:s.connectionId,data:t.data,domain:s.domain,expectResponse:t.expectResponse,from:s.name,parentRef:a,responseTo:t.responseTo,sources:s.target,targetOrigin:s.targetOrigin,to:s.connectTo,type:t.type}})}));return[...s.requests,...o]}}),"emit received message":t.enqueueActions((({enqueue:e})=>{e.emit((({event:e})=>(t.assertEvent(e,"message.received"),{type:"_message",message:e.message.data}))),e.emit((({event:e})=>(t.assertEvent(e,"message.received"),{type:e.message.data.type,message:e.message.data})))})),"flush buffer":t.enqueueActions((({enqueue:e})=>{e.raise((({context:e})=>({type:"request",data:e.buffer.map((({data:e,type:t})=>({data:e,type:t})))}))),e.emit((({context:e})=>({type:"_buffer.flushed",messages:e.buffer}))),e.assign({buffer:[]})})),post:t.raise((({event:e})=>(t.assertEvent(e,"post"),{type:"request",data:{data:e.data.data,expectResponse:!0,type:e.data.type}}))),"remove request":t.enqueueActions((({context:e,enqueue:s,event:n})=>{t.assertEvent(n,["request.success","request.failed","request.aborted"]),t.stopChild(n.requestId),s.assign({requests:e.requests.filter((({id:e})=>e!==n.requestId))})})),respond:t.raise((({event:e})=>(t.assertEvent(e,"response"),{type:"request",data:{data:e.data,type:i,responseTo:e.respondTo}}))),"send handshake ack":t.raise({type:"request",data:{type:l}}),"send disconnect":t.raise((()=>({type:"request",data:{type:d}}))),"send handshake syn":t.raise({type:"request",data:{type:u}}),"set target":t.assign({target:({event:e})=>(t.assertEvent(e,"target.set"),e.target)})},guards:{"has target":({context:e})=>!!e.target,"should send heartbeats":({context:e})=>e.heartbeat}}).createMachine({id:"channel",context:({input:t})=>({id:t.id||`${t.name}-${e.v4()}`,buffer:[],connectionId:`cnx-${e.v4()}`,connectTo:t.connectTo,domain:t.domain??o,heartbeat:t.heartbeat??!1,name:t.name,requests:[],target:t.target,targetOrigin:t.targetOrigin}),on:{"target.set":{actions:"set target"},"request.success":{actions:"remove request"},"request.failed":{actions:"remove request"}},initial:"idle",states:{idle:{on:{connect:{target:"handshaking",guard:"has target"},post:{actions:"buffer message"}}},handshaking:{id:"handshaking",invoke:[{id:"send syn",src:"sendBackAtInterval",input:()=>({event:{type:"syn"},interval:500,immediate:!0})},{id:"listen for handshake",src:"listen",input:e=>n({include:p,count:1})(e)}],on:{syn:{actions:"send handshake syn"},request:{actions:"create request"},post:{actions:"buffer message"},"message.received":{target:"connected"},disconnect:{target:"disconnected"}},exit:"send handshake ack"},connected:{entry:"flush buffer",invoke:{id:"listen for messages",src:"listen",input:n({exclude:[i,c]})},on:{post:{actions:"post"},request:{actions:"create request"},response:{actions:"respond"},"message.received":{actions:"emit received message"},disconnect:{target:"disconnected"}},initial:"heartbeat",states:{heartbeat:{initial:"checking",states:{checking:{always:{guard:"should send heartbeats",target:"sending"}},sending:{on:{"request.failed":{target:"#handshaking"}},invoke:{id:"send heartbeat",src:"sendBackAtInterval",input:()=>({event:{type:"post",data:{type:c,data:void 0}},interval:2e3,immediate:!1})}}}}}},disconnected:{id:"disconnected",entry:"send disconnect",on:{request:{actions:"create request"},post:{actions:"buffer message"},connect:{target:"handshaking",guard:"has target"}}}}}),b=(s,n=v())=>{const a=s.id||`${s.name}-${e.v4()}`,r=t.createActor(n,{input:{...s,id:a}}),o=()=>{r.stop()};return{actor:r,connect:()=>{r.send({type:"connect"})},disconnect:()=>{r.send({type:"disconnect"})},id:a,name:s.name,machine:n,on:(e,t)=>{const{unsubscribe:s}=r.on(e,(async e=>{const s=await t(e.message.data);s&&r.send({type:"response",respondTo:e.message.id,data:s})}));return s},onStatus:e=>{const t=r.getSnapshot();let s="string"==typeof t.value?t.value:Object.keys(t.value)[0];const{unsubscribe:n}=r.subscribe((t=>{const n="string"==typeof t.value?t.value:Object.keys(t.value)[0];s!==n&&(s=n,e(n))}));return n},post:e=>{r.send({type:"post",data:e})},setTarget:e=>{r.send({type:"target.set",target:e})},start:()=>(r.start(),o),stop:o,get target(){return r.getSnapshot().context.target}}},y=()=>{},q=()=>t.setup({types:{},actors:{requestMachine:m(),listen:r()},actions:{"buffer incoming message":t.assign({handshakeBuffer:({event:e,context:s})=>(t.assertEvent(e,"message.received"),[...s.handshakeBuffer,e])}),"buffer message":t.enqueueActions((({enqueue:e})=>{e.assign({buffer:({event:e,context:s})=>(t.assertEvent(e,"post"),[...s.buffer,{data:e.data,resolvable:e.resolvable,signal:e.signal}])}),e.emit((({event:e})=>(t.assertEvent(e,"post"),{type:"_buffer.added",message:e.data})))})),"create request":t.assign({requests:({context:s,event:n,self:a,spawn:r})=>{t.assertEvent(n,"request");const o=(Array.isArray(n.data)?n.data:[n.data]).map((t=>{const n=`req-${e.v4()}`;return r("requestMachine",{id:n,input:{connectionId:s.connectionId,data:t.data,domain:s.domain,expectResponse:t.expectResponse,from:s.name,parentRef:a,resolvable:t.resolvable,responseTo:t.responseTo,sources:s.target,targetOrigin:s.targetOrigin,to:s.connectTo,type:t.type,signal:t.signal}})}));return[...s.requests,...o]}}),"emit heartbeat":t.emit((()=>({type:"_heartbeat"}))),"emit received message":t.enqueueActions((({enqueue:e})=>{e.emit((({event:e})=>(t.assertEvent(e,"message.received"),{type:"_message",message:e.message.data}))),e.emit((({event:e})=>(t.assertEvent(e,"message.received"),{type:e.message.data.type,message:e.message.data})))})),"flush buffer":t.enqueueActions((({enqueue:e})=>{e.raise((({context:e})=>({type:"request",data:e.buffer.map((({data:e,resolvable:t,signal:s})=>({data:e.data,type:e.type,expectResponse:!!t,resolvable:t,signal:s})))}))),e.emit((({context:e})=>({type:"_buffer.flushed",messages:e.buffer.map((({data:e})=>e))}))),e.assign({buffer:[]})})),"flush handshake buffer":t.enqueueActions((({context:e,enqueue:t})=>{e.handshakeBuffer.forEach((e=>t.raise(e))),t.assign({handshakeBuffer:[]})})),post:t.raise((({event:e})=>(t.assertEvent(e,"post"),{type:"request",data:{data:e.data.data,expectResponse:!!e.resolvable,type:e.data.type,resolvable:e.resolvable,signal:e.signal}}))),"remove request":t.enqueueActions((({context:e,enqueue:s,event:n})=>{t.assertEvent(n,["request.success","request.failed","request.aborted"]),t.stopChild(n.requestId),s.assign({requests:e.requests.filter((({id:e})=>e!==n.requestId))})})),"send response":t.raise((({event:e})=>(t.assertEvent(e,["message.received","heartbeat.received"]),{type:"request",data:{type:i,responseTo:e.message.data.id,data:void 0}}))),"send handshake syn ack":t.raise({type:"request",data:{type:p}}),"set connection config":t.assign({connectionId:({event:e})=>(t.assertEvent(e,"message.received"),e.message.data.connectionId),target:({event:e})=>(t.assertEvent(e,"message.received"),e.message.source||void 0),targetOrigin:({event:e})=>(t.assertEvent(e,"message.received"),e.message.origin)})},guards:{hasSource:({context:e})=>null!==e.target}}).createMachine({id:"node",context:({input:e})=>({buffer:[],connectionId:null,connectTo:e.connectTo,domain:e.domain??o,handshakeBuffer:[],name:e.name,requests:[],target:void 0,targetOrigin:null}),on:{"request.success":{actions:"remove request"},"request.failed":{actions:"remove request"},"request.aborted":{actions:"remove request"}},initial:"idle",states:{idle:{invoke:{id:"listen for handshake syn",src:"listen",input:n({include:u,count:1}),onDone:{target:"handshaking",guard:"hasSource"}},on:{"message.received":{actions:"set connection config"},post:{actions:"buffer message"}}},handshaking:{entry:"send handshake syn ack",invoke:[{id:"listen for handshake ack",src:"listen",input:n({include:l,count:1,responseType:"handshake.complete"}),onDone:"connected"},{id:"listen for disconnect",src:"listen",input:n({include:d,count:1,responseType:"disconnect"})},{id:"listen for messages",src:"listen",input:n({exclude:[d,l,c,i]})}],on:{request:{actions:"create request"},post:{actions:"buffer message"},"message.received":{actions:"buffer incoming message"},disconnect:{target:"idle"}}},connected:{entry:["flush handshake buffer","flush buffer"],invoke:[{id:"listen for messages",src:"listen",input:n({exclude:[i,c]})},{id:"listen for heartbeat",src:"listen",input:n({include:c,responseType:"heartbeat.received"})},{id:"listen for disconnect",src:"listen",input:n({include:d,count:1,responseType:"disconnect"})}],on:{request:{actions:"create request"},post:{actions:"post"},disconnect:{target:"idle"},"message.received":{actions:["send response","emit received message"]},"heartbeat.received":{actions:["send response","emit heartbeat"]}}}}});exports.DOMAIN=o,exports.HANDSHAKE_INTERVAL=500,exports.HANDSHAKE_MSG_TYPES=g,exports.HEARTBEAT_INTERVAL=1e3,exports.INTERNAL_MSG_TYPES=f,exports.MSG_DISCONNECT=d,exports.MSG_HANDSHAKE_ACK=l,exports.MSG_HANDSHAKE_SYN=u,exports.MSG_HANDSHAKE_SYN_ACK=p,exports.MSG_HEARTBEAT=c,exports.MSG_RESPONSE=i,exports.RESPONSE_TIMEOUT=1e4,exports.createChannel=b,exports.createChannelMachine=v,exports.createController=e=>{const{targetOrigin:t}=e,s=new Set,n=new Set,a=e=>{e.disconnect(),setTimeout((()=>{e.stop()}),0)};return{addTarget:e=>{if(s.has(e))return y;if(!s.size||!n.size)return s.add(e),n.forEach((t=>{t.channels.forEach((t=>{t.setTarget(e),t.connect()}))})),()=>{s.delete(e),n.forEach((t=>{t.channels.forEach((t=>{t.target===e&&t.disconnect()}))}))};s.add(e);const r=new Set;return n.forEach((s=>{const n=b({...s.input,target:e,targetOrigin:t},s.machine);r.add(n),s.channels.add(n),s.subscribers.forEach((({type:e,handler:t,unsubscribers:s})=>{s.push(n.on(e,t))})),s.internalEventSubscribers.forEach((({type:e,handler:t,unsubscribers:s})=>{s.push(n.actor.on(e,t).unsubscribe)})),s.statusSubscribers.forEach((({handler:e,unsubscribers:t})=>{t.push(n.onStatus((t=>e({channel:n.id,status:t}))))})),n.start(),n.connect()})),()=>{s.delete(e),r.forEach((e=>{a(e),n.forEach((t=>{t.channels.delete(e)}))}))}},createConnection:(e,a=v())=>{const r={channels:new Set,input:e,internalEventSubscribers:new Set,machine:a,statusSubscribers:new Set,subscribers:new Set};n.add(r);const{channels:o,internalEventSubscribers:i,statusSubscribers:c,subscribers:d}=r;if(s.size)s.forEach((s=>{const n=b({...e,target:s,targetOrigin:t},a);o.add(n)}));else{const s=b({...e,targetOrigin:t},a);o.add(s)}const u=()=>{o.forEach((e=>{e.disconnect(),e.stop()}))};return{on:(e,t)=>{const s=[];o.forEach((n=>{s.push(n.on(e,t))}));const n={type:e,handler:t,unsubscribers:s};return d.add(n),()=>{s.forEach((e=>e())),d.delete(n)}},onInternalEvent:(e,t)=>{const s=[];o.forEach((n=>{s.push(n.actor.on(e,t).unsubscribe)}));const n={type:e,handler:t,unsubscribers:s};return i.add(n),()=>{s.forEach((e=>e())),i.delete(n)}},onStatus:e=>{const t=[];o.forEach((s=>{t.push(s.onStatus((t=>e({channel:s.id,status:t}))))}));const s={handler:e,unsubscribers:t};return c.add(s),()=>{t.forEach((e=>e())),c.delete(s)}},post:e=>{o.forEach((t=>{t.post(e)}))},start:()=>(o.forEach((e=>{e.start(),e.connect()})),u),stop:u}},destroy:()=>{n.forEach((({channels:e})=>{e.forEach((t=>{a(t),e.delete(t)}))}))}}},exports.createListenLogic=r,exports.createNode=(e,s=q())=>{const n=t.createActor(s,{input:e}),a=()=>{n.stop()};return{actor:n,fetch:(e,t)=>{const s=Promise.withResolvers();return n.send({type:"post",data:e,resolvable:s,signal:t?.signal}),s.promise},machine:s,on:(e,t)=>{const{unsubscribe:s}=n.on(e,(e=>{t(e.message.data)}));return s},onStatus:e=>{const t=n.getSnapshot();let s="string"==typeof t.value?t.value:Object.keys(t.value)[0];const{unsubscribe:a}=n.subscribe((t=>{const n="string"==typeof t.value?t.value:Object.keys(t.value)[0];s!==n&&(s=n,e(n))}));return a},post:e=>{n.send({type:"post",data:e})},start:()=>(n.start(),a),stop:a}},exports.createNodeMachine=q,exports.createRequestMachine=m;//# sourceMappingURL=index.cjs.map
