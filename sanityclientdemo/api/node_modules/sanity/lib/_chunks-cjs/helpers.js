"use strict";
var fs = require("node:fs/promises"), path = require("node:path"), node_stream = require("node:stream"), FormData = require("form-data"), readPkgUp = require("read-pkg-up"), _internal = require("./_internal.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var fs__default = /* @__PURE__ */ _interopDefaultCompat(fs), path__default = /* @__PURE__ */ _interopDefaultCompat(path), FormData__default = /* @__PURE__ */ _interopDefaultCompat(FormData), readPkgUp__default = /* @__PURE__ */ _interopDefaultCompat(readPkgUp);
const debug = _internal.debug.extend("deploy");
function promiseWithResolvers() {
  let resolve, reject;
  return { promise: new Promise((res, rej) => {
    resolve = res, reject = rej;
  }), resolve, reject };
}
async function getUserApplication({
  client,
  appHost
}) {
  try {
    return await client.request({
      uri: "/user-applications",
      query: appHost ? { appHost } : { default: "true" }
    });
  } catch (e) {
    if (e?.statusCode === 404)
      return null;
    throw debug("Error getting user application", e), e;
  }
}
async function getUserApplications({
  client
}) {
  try {
    return await client.request({
      uri: "/user-applications"
    });
  } catch (e) {
    if (e?.statusCode === 404)
      return null;
    throw debug("Error getting user application", e), e;
  }
}
function createUserApplication(client, body) {
  return client.request({ uri: "/user-applications", method: "POST", body });
}
async function getOrCreateUserApplication({
  client,
  spinner,
  context
}) {
  const { output, prompt } = context, existingUserApplication = await getUserApplication({ client });
  if (spinner.succeed(), existingUserApplication)
    return existingUserApplication;
  const userApplications = await getUserApplications({ client });
  if (userApplications?.length) {
    const choices = userApplications.map((app) => ({
      value: app.appHost,
      name: app.appHost
    })), selected = await prompt.single({
      message: "Select existing studio hostname",
      type: "list",
      choices: [
        { value: "new", name: "Create new studio hostname" },
        new prompt.Separator(),
        ...choices
      ]
    });
    if (selected !== "new")
      return userApplications.find((app) => app.appHost === selected);
  }
  output.print("Your project has not been assigned a studio hostname."), output.print("To deploy your Sanity Studio to our hosted sanity.studio service,"), output.print("you will need one. Please enter the part you want to use.");
  const { promise, resolve } = promiseWithResolvers();
  return await prompt.single({
    type: "input",
    filter: (inp) => inp.replace(/\.sanity\.studio$/i, ""),
    message: "Studio hostname (<value>.sanity.studio):",
    // if a string is returned here, it is relayed to the user and prompt allows
    // the user to try again until this function returns true
    validate: async (appHost) => {
      try {
        const response = await createUserApplication(client, {
          appHost,
          urlType: "internal"
        });
        return resolve(response), !0;
      } catch (e) {
        if ([402, 409].includes(e?.statusCode))
          return e?.response?.body?.message || "Bad request";
        throw debug("Error creating user application", e), e;
      }
    }
  }), await promise;
}
async function getOrCreateUserApplicationFromConfig({
  client,
  context,
  spinner,
  appHost
}) {
  const { output } = context, existingUserApplication = await getUserApplication({ client, appHost });
  if (spinner.succeed(), existingUserApplication)
    return existingUserApplication;
  output.print("Your project has not been assigned a studio hostname."), output.print(`Creating https://${appHost}.sanity.studio`), output.print(""), spinner.start("Creating studio hostname");
  try {
    const response = await createUserApplication(client, {
      appHost,
      urlType: "internal"
    });
    return spinner.succeed(), response;
  } catch (e) {
    throw spinner.fail(), [402, 409].includes(e?.statusCode) ? new Error(e?.response?.body?.message || "Bad request") : (debug("Error creating user application from config", e), e);
  }
}
async function createDeployment({
  client,
  tarball,
  applicationId,
  isAutoUpdating,
  version
}) {
  const formData = new FormData__default.default();
  return formData.append("isAutoUpdating", isAutoUpdating.toString()), formData.append("version", version), formData.append("tarball", tarball, { contentType: "application/gzip", filename: "app.tar.gz" }), client.request({
    uri: `/user-applications/${applicationId}/deployments`,
    method: "POST",
    headers: formData.getHeaders(),
    body: formData.pipe(new node_stream.PassThrough())
  });
}
async function deleteUserApplication({
  applicationId,
  client
}) {
  await client.request({ uri: `/user-applications/${applicationId}`, method: "DELETE" });
}
async function getInstalledSanityVersion() {
  const sanityPkgPath = (await readPkgUp__default.default({ cwd: __dirname }))?.path;
  if (!sanityPkgPath)
    throw new Error("Unable to resolve `sanity` module root");
  const pkg = JSON.parse(await fs__default.default.readFile(sanityPkgPath, "utf-8"));
  if (typeof pkg?.version != "string")
    throw new Error("Unable to find version of `sanity` module");
  return pkg.version;
}
async function dirIsEmptyOrNonExistent(sourceDir) {
  try {
    if (!(await fs__default.default.stat(sourceDir)).isDirectory())
      throw new Error(`Directory ${sourceDir} is not a directory`);
  } catch (err) {
    if (err.code === "ENOENT")
      return !0;
    throw err;
  }
  return (await fs__default.default.readdir(sourceDir)).length === 0;
}
async function checkDir(sourceDir) {
  try {
    if (!(await fs__default.default.stat(sourceDir)).isDirectory())
      throw new Error(`Directory ${sourceDir} is not a directory`);
  } catch (err) {
    throw err.code === "ENOENT" ? new Error(`Directory "${sourceDir}" does not exist`) : err;
  }
  try {
    await fs__default.default.stat(path__default.default.join(sourceDir, "index.html"));
  } catch (err) {
    throw err.code === "ENOENT" ? new Error(
      [
        `"${sourceDir}/index.html" does not exist -`,
        "[SOURCE_DIR] must be a directory containing",
        'a Sanity studio built using "sanity build"'
      ].join(" ")
    ) : err;
  }
}
exports.checkDir = checkDir;
exports.createDeployment = createDeployment;
exports.debug = debug;
exports.deleteUserApplication = deleteUserApplication;
exports.dirIsEmptyOrNonExistent = dirIsEmptyOrNonExistent;
exports.getInstalledSanityVersion = getInstalledSanityVersion;
exports.getOrCreateUserApplication = getOrCreateUserApplication;
exports.getOrCreateUserApplicationFromConfig = getOrCreateUserApplicationFromConfig;
exports.getUserApplication = getUserApplication;
//# sourceMappingURL=helpers.js.map
