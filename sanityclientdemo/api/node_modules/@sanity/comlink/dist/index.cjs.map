{"version":3,"file":"index.cjs","sources":["../src/common.ts","../src/constants.ts","../src/request.ts","../src/channel.ts","../src/controller.ts","../src/node.ts"],"sourcesContent":["import {bufferCount, concatMap, defer, filter, fromEvent, map, pipe, take} from 'rxjs'\nimport {fromEventObservable} from 'xstate'\nimport type {ListenInput, ProtocolMessage} from './types'\n\nexport const listenInputFromContext =\n  (\n    config: (\n      | {\n          include: string | string[]\n          exclude?: string | string[]\n        }\n      | {\n          include?: string | string[]\n          exclude: string | string[]\n        }\n    ) & {\n      matches?: boolean\n      count?: number\n      responseType?: string\n    },\n  ) =>\n  <\n    T extends {\n      domain: string\n      connectTo: string\n      name: string\n      target: MessageEventSource | undefined\n    },\n  >({\n    context,\n  }: {\n    context: T\n  }): ListenInput => {\n    const {count, include, exclude, responseType = 'message.received'} = config\n    return {\n      count,\n      domain: context.domain,\n      from: context.connectTo,\n      include: include ? (Array.isArray(include) ? include : [include]) : [],\n      exclude: exclude ? (Array.isArray(exclude) ? exclude : [exclude]) : [],\n      responseType,\n      target: context.target,\n      to: context.name,\n    }\n  }\n\nexport const listenFilter =\n  (input: ListenInput) =>\n  (event: MessageEvent<ProtocolMessage>): boolean => {\n    const {data} = event\n    return (\n      (input.include.length ? input.include.includes(data.type) : true) &&\n      (input.exclude.length ? !input.exclude.includes(data.type) : true) &&\n      data.domain === input.domain &&\n      data.from === input.from &&\n      data.to === input.to &&\n      (!input.target || event.source === input.target)\n    )\n  }\n\nexport const eventToMessage =\n  <T>(type: T) =>\n  (event: MessageEvent<ProtocolMessage>): {type: T; message: MessageEvent<ProtocolMessage>} => ({\n    type,\n    message: event,\n  })\n\nexport const messageEvents$ = defer(() =>\n  fromEvent<MessageEvent<ProtocolMessage>>(window, 'message'),\n)\n\n/**\n * @public\n */\nexport const createListenLogic = (\n  compatMap?: (event: MessageEvent<ProtocolMessage>) => MessageEvent<ProtocolMessage>,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n) =>\n  fromEventObservable(({input}: {input: ListenInput}) => {\n    return messageEvents$.pipe(\n      compatMap ? map(compatMap) : pipe(),\n      filter(listenFilter(input)),\n      map(eventToMessage(input.responseType)),\n      input.count\n        ? pipe(\n            bufferCount(input.count),\n            concatMap((arr) => arr),\n            take(input.count),\n          )\n        : pipe(),\n    )\n  })\n","import type {MessageType} from './types'\n\n/** @internal */\nexport const DOMAIN = 'sanity/comlink'\n\n/** @internal */\nexport const RESPONSE_TIMEOUT = 10000\n\n/** @internal */\nexport const HEARTBEAT_INTERVAL = 1000\n\n/** @internal */\nexport const HANDSHAKE_INTERVAL = 500\n\n/**\n * @public\n */\nexport const MSG_RESPONSE = 'comlink/response'\n\n/**\n * @public\n */\nexport const MSG_HEARTBEAT = 'comlink/heartbeat'\n\n/** @internal */\nexport const MSG_DISCONNECT = 'comlink/disconnect'\n\n/** @internal */\nexport const MSG_HANDSHAKE_SYN = 'comlink/handshake/syn'\n\n/** @internal */\nexport const MSG_HANDSHAKE_SYN_ACK = 'comlink/handshake/syn-ack'\n\n/** @internal */\nexport const MSG_HANDSHAKE_ACK = 'comlink/handshake/ack'\n\n/** @internal */\nexport const HANDSHAKE_MSG_TYPES = [\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HANDSHAKE_ACK,\n] satisfies MessageType[]\n\n/** @internal */\nexport const INTERNAL_MSG_TYPES = [\n  MSG_RESPONSE,\n  MSG_DISCONNECT,\n  MSG_HEARTBEAT,\n  ...HANDSHAKE_MSG_TYPES,\n] satisfies MessageType[]\n","import {EMPTY, filter, fromEvent, map, take, takeUntil, type Observable} from 'rxjs'\nimport {v4 as uuid} from 'uuid'\nimport {\n  assign,\n  fromEventObservable,\n  sendTo,\n  setup,\n  type ActorRefFrom,\n  type AnyActorRef,\n} from 'xstate'\nimport {MSG_RESPONSE, RESPONSE_TIMEOUT} from './constants'\nimport type {Message, MessageData, MessageType, ProtocolMessage, ResponseMessage} from './types'\n\nconst throwOnEvent =\n  <T>(message?: string) =>\n  (source: Observable<T>) =>\n    source.pipe(\n      take(1),\n      map(() => {\n        throw new Error(message)\n      }),\n    )\n\n/**\n * @public\n */\nexport interface RequestMachineContext<S extends Message> {\n  connectionId: string\n  data: MessageData | undefined\n  domain: string\n  expectResponse: boolean\n  from: string\n  id: string\n  parentRef: AnyActorRef\n  resolvable: PromiseWithResolvers<S['response']> | undefined\n  response: S['response'] | null\n  responseTo: string | undefined\n  signal: AbortSignal | undefined\n  sources: Set<MessageEventSource>\n  targetOrigin: string\n  to: string\n  type: MessageType\n}\n\n/**\n * @public\n */\nexport type RequestActorRef<S extends Message> = ActorRefFrom<\n  ReturnType<typeof createRequestMachine<S>>\n>\n\n/**\n * @public\n */\nexport const createRequestMachine = <\n  S extends Message,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n>() => {\n  return setup({\n    types: {} as {\n      children: {\n        'listen for response': 'listen'\n      }\n      context: RequestMachineContext<S>\n      // @todo Should response types be specified?\n      events: {type: 'message'; data: ProtocolMessage<ResponseMessage>} | {type: 'abort'}\n      emitted:\n        | {type: 'request.failed'; requestId: string}\n        | {type: 'request.aborted'; requestId: string}\n        | {\n            type: 'request.success'\n            requestId: string\n            response: MessageData | null\n            responseTo: string | undefined\n          }\n      input: {\n        connectionId: string\n        data?: S['data']\n        domain: string\n        expectResponse?: boolean\n        from: string\n        parentRef: AnyActorRef\n        resolvable?: PromiseWithResolvers<S['response']>\n        responseTo?: string\n        signal?: AbortSignal\n        sources: Set<MessageEventSource> | MessageEventSource\n        targetOrigin: string\n        to: string\n        type: S['type']\n      }\n      output: {\n        requestId: string\n        response: S['response'] | null\n        responseTo: string | undefined\n      }\n    },\n    actors: {\n      listen: fromEventObservable(\n        ({\n          input,\n        }: {\n          input: {\n            requestId: string\n            sources: Set<MessageEventSource>\n            signal?: AbortSignal\n          }\n        }) => {\n          const abortSignal$ = input.signal\n            ? fromEvent(input.signal, 'abort').pipe(\n                throwOnEvent(`Request ${input.requestId} aborted`),\n              )\n            : EMPTY\n\n          const messageFilter = (event: MessageEvent<ProtocolMessage<ResponseMessage>>) =>\n            event.data?.type === MSG_RESPONSE &&\n            event.data?.responseTo === input.requestId &&\n            !!event.source &&\n            input.sources.has(event.source)\n\n          return fromEvent<MessageEvent<ProtocolMessage<ResponseMessage>>>(window, 'message').pipe(\n            filter(messageFilter),\n            take(input.sources.size),\n            takeUntil(abortSignal$),\n          )\n        },\n      ),\n    },\n    actions: {\n      'send message': ({context}, params: {message: ProtocolMessage}) => {\n        const {sources, targetOrigin} = context\n        const {message} = params\n\n        sources.forEach((source) => {\n          source.postMessage(message, {targetOrigin})\n        })\n      },\n      'on success': sendTo(\n        ({context}) => context.parentRef,\n        ({context, self}) => {\n          if (context.response) {\n            context.resolvable?.resolve(context.response)\n          }\n          return {\n            type: 'request.success',\n            requestId: self.id,\n            response: context.response,\n            responseTo: context.responseTo,\n          }\n        },\n      ),\n      'on fail': sendTo(\n        ({context}) => context.parentRef,\n        ({context, self}) => {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `Received no response to message '${context.type}' on client '${context.from}' (ID: '${context.id}').`,\n          )\n          context.resolvable?.reject(new Error('No response received'))\n          return {type: 'request.failed', requestId: self.id}\n        },\n      ),\n      'on abort': sendTo(\n        ({context}) => context.parentRef,\n        ({context, self}) => {\n          context.resolvable?.reject(new Error('Request aborted'))\n          return {type: 'request.aborted', requestId: self.id}\n        },\n      ),\n    },\n    guards: {\n      expectsResponse: ({context}) => context.expectResponse,\n    },\n    delays: {\n      initialTimeout: 0,\n      responseTimeout: RESPONSE_TIMEOUT,\n    },\n  }).createMachine({\n    /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAOlwgBswBiAD1gBd0GwT0AzFgJ2QNwdzoKAFVyowAewCuDItTRY8hUuSoBtAAwBdRKAAOE2P1wT8ukLUQBGAEwBWEgBYAnK+eOAzB7sB2DzY8rABoQAE9rDQc3V0cNTw8fAA4NHwBfVJCFHAJiElgwfAgCKGpNHSQQAyMBU3NLBDsrDxI7DTaAjQA2OOcNDxDwhHsNJx9Ou0TOq2cJxP9HdMyMbOU8gqL8ErUrcv1DY1qK+sbm1vaPLp6+gcRnGydo9wDGycWQLKVc9AB3dGNN6jiWCwdAwMrmKoHMxHRCJRKOEiJHwuZKBZwXKzBMKIGyYkhtAkXOweTqOHw2RJvD45Ug-P4CAH0JgsNicMA8LhwAz4fKicTSWTyZafWm-f5QcEVSE1aGgepwhFIlF9aYYrGDC4+JzEppjGzOUkeGbpDIgfASCBwczU5QQ-YyuqIAC0nRuCBd+IJXu9KSpwppZEoYDt1RMsosiEcNjdVjiJEeGisiSTHkcVgWpptuXyhWKIahjqGzi1BqRJINnVcdkcbuTLS9VYC8ISfsUAbp4vzDphCHJIyjBvJNlxNmRNexQ3sJGH43GPj8jWJrZWuXYfyoEC7YcLsbrgRsjkcvkmdgNbopVhIPhVfnsh8ClMz-tWsCkmEwcHgUvt257u8v+6Hse4xnhOdZnImVidPqCRNB4JqpEAA */\n    context: ({input}) => {\n      return {\n        connectionId: input.connectionId,\n        data: input.data,\n        domain: input.domain,\n        expectResponse: input.expectResponse ?? false,\n        from: input.from,\n        id: `msg-${uuid()}`,\n        parentRef: input.parentRef,\n        resolvable: input.resolvable,\n        response: null,\n        responseTo: input.responseTo,\n        signal: input.signal,\n        sources: input.sources instanceof Set ? input.sources : new Set([input.sources]),\n        targetOrigin: input.targetOrigin,\n        to: input.to,\n        type: input.type,\n      }\n    },\n    initial: 'idle',\n    on: {\n      abort: '.aborted',\n    },\n    states: {\n      idle: {\n        after: {\n          initialTimeout: [\n            {\n              target: 'sending',\n            },\n          ],\n        },\n      },\n      sending: {\n        entry: {\n          type: 'send message',\n          params: ({context}) => {\n            const {connectionId, data, domain, from, id, responseTo, to, type} = context\n            const message = {\n              connectionId,\n              data,\n              domain,\n              from,\n              id,\n              to,\n              type,\n              responseTo,\n            }\n            return {message}\n          },\n        },\n        always: [\n          {\n            guard: 'expectsResponse',\n            target: 'awaiting',\n          },\n          'success',\n        ],\n      },\n      awaiting: {\n        invoke: {\n          id: 'listen for response',\n          src: 'listen',\n          input: ({context}) => ({\n            requestId: context.id,\n            sources: context.sources,\n            signal: context.signal,\n          }),\n          onError: 'aborted',\n        },\n        after: {\n          responseTimeout: 'failed',\n        },\n        on: {\n          message: {\n            actions: assign({\n              response: ({event}) => event.data.data,\n              responseTo: ({event}) => event.data.responseTo,\n            }),\n            target: 'success',\n          },\n        },\n      },\n      failed: {\n        type: 'final',\n        entry: 'on fail',\n      },\n      success: {\n        type: 'final',\n        entry: 'on success',\n      },\n      aborted: {\n        type: 'final',\n        entry: 'on abort',\n      },\n    },\n    output: ({context, self}) => {\n      const output = {\n        requestId: self.id,\n        response: context.response,\n        responseTo: context.responseTo,\n      }\n      return output\n    },\n  })\n}\n\n// export const delayedRequestMachine = requestMachine.provide({\n//   delays: {\n//     initialTimeout: 500,\n//   },\n// })\n","import {v4 as uuid} from 'uuid'\nimport {\n  assertEvent,\n  assign,\n  createActor,\n  enqueueActions,\n  fromCallback,\n  raise,\n  setup,\n  stopChild,\n  type ActorRefFrom,\n  type EventObject,\n} from 'xstate'\nimport {createListenLogic, listenInputFromContext} from './common'\nimport {\n  DOMAIN,\n  HANDSHAKE_INTERVAL,\n  MSG_DISCONNECT,\n  MSG_HANDSHAKE_ACK,\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HEARTBEAT,\n  MSG_RESPONSE,\n} from './constants'\nimport {createRequestMachine, type RequestActorRef} from './request'\nimport type {\n  BufferAddedEmitEvent,\n  BufferFlushedEmitEvent,\n  Message,\n  MessageEmitEvent,\n  ProtocolMessage,\n  RequestData,\n  Status,\n  WithoutResponse,\n} from './types'\n\n/**\n * @public\n */\nexport type ChannelActorLogic<R extends Message, S extends Message> = ReturnType<\n  typeof createChannelMachine<R, S>\n>\n/**\n * @public\n */\nexport type ChannelActor<R extends Message, S extends Message> = ActorRefFrom<\n  ReturnType<typeof createChannelMachine<R, S>>\n>\n\n/**\n * @public\n */\nexport type Channel<R extends Message, S extends Message> = {\n  actor: ChannelActor<R, S>\n  connect: () => void\n  disconnect: () => void\n  id: string\n  name: string\n  machine: ReturnType<typeof createChannelMachine<R, S>>\n  on: <T extends R['type'], U extends Extract<R, {type: T}>>(\n    type: T,\n    handler: (event: U['data']) => Promise<U['response']> | U['response'],\n  ) => () => void\n  onStatus: (handler: (status: Status) => void) => () => void\n  post: (data: WithoutResponse<S>) => void\n  setTarget: (target: MessageEventSource) => void\n  start: () => () => void\n  stop: () => void\n  target: MessageEventSource | undefined\n}\n\n/**\n * @public\n */\nexport interface ChannelInput {\n  connectTo: string\n  domain?: string\n  heartbeat?: boolean\n  name: string\n  id?: string\n  target?: MessageEventSource\n  targetOrigin: string\n}\n\nconst sendBackAtInterval = fromCallback<\n  EventObject,\n  {event: EventObject; immediate?: boolean; interval: number}\n>(({sendBack, input}) => {\n  const send = () => {\n    sendBack(input.event)\n  }\n\n  if (input.immediate) {\n    send()\n  }\n\n  const interval = setInterval(send, input.interval)\n\n  return () => {\n    clearInterval(interval)\n  }\n})\n\n/**\n * @public\n */\nexport const createChannelMachine = <\n  R extends Message, // Receives\n  S extends Message, // Sends\n  V extends WithoutResponse<S> = WithoutResponse<S>,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n>() => {\n  const channelMachine = setup({\n    types: {} as {\n      children: {\n        'listen for handshake': 'listen'\n        'listen for messages': 'listen'\n        'send heartbeat': 'sendBackAtInterval'\n        'send syn': 'sendBackAtInterval'\n      }\n      context: {\n        buffer: Array<V>\n        connectionId: string\n        connectTo: string\n        domain: string\n        heartbeat: boolean\n        id: string\n        name: string\n        requests: Array<RequestActorRef<S>>\n        target: MessageEventSource | undefined\n        targetOrigin: string\n      }\n      emitted:\n        | BufferAddedEmitEvent<V>\n        | BufferFlushedEmitEvent<V>\n        | MessageEmitEvent<R>\n        | (R extends R ? {type: R['type']; message: ProtocolMessage<R>} : never)\n      events:\n        | {type: 'connect'}\n        | {type: 'disconnect'}\n        | {type: 'message.received'; message: MessageEvent<ProtocolMessage<R>>}\n        | {type: 'post'; data: V}\n        | {type: 'response'; respondTo: string; data: Pick<S, 'response'>}\n        | {type: 'request.aborted'; requestId: string}\n        | {type: 'request.failed'; requestId: string}\n        | {\n            type: 'request.success'\n            requestId: string\n            response: S['response'] | null\n            responseTo: string | undefined\n          }\n        | {type: 'request'; data: RequestData<S> | RequestData<S>[]}\n        | {type: 'syn'}\n        | {type: 'target.set'; target: MessageEventSource}\n      input: ChannelInput\n    },\n    actors: {\n      requestMachine: createRequestMachine<S>(),\n      listen: createListenLogic(),\n      sendBackAtInterval,\n    },\n    actions: {\n      'buffer message': enqueueActions(({enqueue}) => {\n        enqueue.assign({\n          buffer: ({event, context}) => {\n            assertEvent(event, 'post')\n            return [...context.buffer, event.data]\n          },\n        })\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'post')\n          return {\n            type: '_buffer.added',\n            message: event.data,\n          } satisfies BufferAddedEmitEvent<V>\n        })\n      }),\n      'create request': assign({\n        requests: ({context, event, self, spawn}) => {\n          assertEvent(event, 'request')\n          const arr = Array.isArray(event.data) ? event.data : [event.data]\n          const requests = arr.map((request) => {\n            const id = `req-${uuid()}`\n            return spawn('requestMachine', {\n              id,\n              input: {\n                connectionId: context.connectionId,\n                data: request.data,\n                domain: context.domain,\n                expectResponse: request.expectResponse,\n                from: context.name,\n                parentRef: self,\n                responseTo: request.responseTo,\n                sources: context.target!,\n                targetOrigin: context.targetOrigin,\n                to: context.connectTo,\n                type: request.type,\n              },\n            })\n          })\n          return [...context.requests, ...requests]\n        },\n      }),\n      'emit received message': enqueueActions(({enqueue}) => {\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'message.received')\n          return {\n            type: '_message',\n            message: event.message.data,\n          } satisfies MessageEmitEvent<R>\n        })\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'message.received')\n          const emit = {\n            type: event.message.data.type,\n            message: event.message.data,\n          }\n          return emit\n        })\n      }),\n      'flush buffer': enqueueActions(({enqueue}) => {\n        enqueue.raise(({context}) => ({\n          type: 'request',\n          data: context.buffer.map(({data, type}) => ({data, type})),\n        }))\n        enqueue.emit(({context}) => {\n          return {\n            type: '_buffer.flushed',\n            messages: context.buffer,\n          } satisfies BufferFlushedEmitEvent<V>\n        })\n        enqueue.assign({\n          buffer: [],\n        })\n      }),\n      'post': raise(({event}) => {\n        assertEvent(event, 'post')\n        return {\n          type: 'request' as const,\n          data: {\n            data: event.data.data,\n            expectResponse: true,\n            type: event.data.type,\n          },\n        }\n      }),\n      'remove request': enqueueActions(({context, enqueue, event}) => {\n        assertEvent(event, ['request.success', 'request.failed', 'request.aborted'])\n        stopChild(event.requestId)\n        enqueue.assign({requests: context.requests.filter(({id}) => id !== event.requestId)})\n      }),\n      'respond': raise(({event}) => {\n        assertEvent(event, 'response')\n        return {\n          type: 'request' as const,\n          data: {\n            data: event.data,\n            type: MSG_RESPONSE,\n            responseTo: event.respondTo,\n          },\n        }\n      }),\n      'send handshake ack': raise({\n        type: 'request',\n        data: {type: MSG_HANDSHAKE_ACK},\n      }),\n      'send disconnect': raise(() => {\n        return {\n          type: 'request' as const,\n          data: {type: MSG_DISCONNECT},\n        }\n      }),\n      'send handshake syn': raise({\n        type: 'request',\n        data: {type: MSG_HANDSHAKE_SYN},\n      }),\n      'set target': assign({\n        target: ({event}) => {\n          assertEvent(event, 'target.set')\n          return event.target\n        },\n      }),\n    },\n    guards: {\n      'has target': ({context}) => !!context.target,\n      'should send heartbeats': ({context}) => context.heartbeat,\n    },\n  }).createMachine({\n    /** @xstate-layout N4IgpgJg5mDOIC5QGMAWBDAdpsAbAxAC7oBOMhAdLGIQNoAMAuoqAA4D2sAloV+5ixAAPRAHZRAJgoAWABz0ArHICMy2QGZZCgJwAaEAE9EE+tIrb6ANgkLl46fTuj1AXxf60WHARJgAjgCucJSwAcjIcLAMzEggHNy8-IIiCKLS2hQS6qb2yurisrL6RgjK9LIyCuqq0g7WstZuHhjYePi+gcEUAGboXLiQ0YLxPHwCsSmiCgoykpayDtqS6trqxYjKEk0gnq24FFwQA-jI-DjIdEzDnKNJExuOZpZ12eq29OrSCuupypYUojUaTKCnm5Wk2123gORzA+HilxibBuiXGoBSGnUAIU4gU9FWamUtR+lmUM1EllBEkslMUEnpkJa0JaEFgGAA1lxMFB8LADJghrERqjkhtshk3mTtNo5OpqpYfqCKhTptoqpY1WUtu4dky8BQWWz0Jzue1-EFYIjrgkxqLSupqRRPpoPqJtLI0hIioZENJJE7NnJ8ZYHVk1YyvPrDRyuTyEYLkTa7uixVlMh81KGFhS1j6EPkZlpVjTphr8mkI3sDVhWTHTQBbSLoGAUXwRLgAN0GVyFKNt91KimUFEKXvKC2s9R+6X+jipnzJeSqEJ1UKjNaNJp5EC4sFOrQuCbifeTwg2cgoym0RPxDtqkj0eaB9Ao8zSolMEivZVcq71+33c5CEgeFOCtXskzRM8EDxKRpmkSw3QJbQsmpH5tHmV8JHSbJpDsakV2aSMALOMALhAjoLXAxNbiglI-SxWw1Vw0QNDw0Qfg9KQ7EJSxHHxApK2hQCyOAiAzVgDhMGoI9hX7FMEHSF8cWkelpHURCbBsb481xAEgT9BQJCmWQsiE-URPI8TG1gWBmzAVsyLATtuyRY9ILtWoKmlL82Kqd0tAVJ91LMHFZDKIkVlkNVZHMkiDzE-Adz3UjDx7GiRQHCKnheD53k+HSSkDDIwpBVTqQwuKKEssSDTAUhCAAI3qyg0DIrd8Fkk86MQUMnVM+RynoegTDJH48hGp0vR-FDRqqKqasgOqGua9AQjATAd1NSiul6fpXOtWi7Wy19cslD4vnG7IX3oVjVDUVYEJQqrksW8SdstLqPKy0wKgG1RhtMWogqKhoMjkWp6XxUyFBe3c3tAz70vco6fq+V8PTkGUFzdQqNnELEM2yClrwwzQ4ZShKQJqr7UYU98AS0W9pT4z5pHG0yXwMkNNTyGk3B1TB2AgOBBDXXBDsyhSFG9EovQqN5i1JeRcKqw4Bkl+ToMx8x0j+EaqQ9XMSkBURMgMkEwQWKro2NWNNdPFJAzN0lJGM4slDxhBEJfXyplBd03wW1KxIdnrBxBh4JAyW75C8rJpmDqmIGWkgmpasPjqUcaHooMLHA0uU1UkJOgKW1B6rT1bWor5At0zgcTAkK7hrz1irB0D8cW0UvRPLyv07WqgNq2qAG+l9SnXUz0UOXD5xuMs3Y4+DVJBX7UiKrV6Q8gcfoJO54rFefLLqfJYX1WKYNLxL4NO1NwgA */\n    id: 'channel',\n    context: ({input}) => ({\n      id: input.id || `${input.name}-${uuid()}`,\n      buffer: [],\n      connectionId: `cnx-${uuid()}`,\n      connectTo: input.connectTo,\n      domain: input.domain ?? DOMAIN,\n      heartbeat: input.heartbeat ?? false,\n      name: input.name,\n      requests: [],\n      target: input.target,\n      targetOrigin: input.targetOrigin,\n    }),\n    on: {\n      'target.set': {\n        actions: 'set target',\n      },\n      'request.success': {\n        actions: 'remove request',\n      },\n      'request.failed': {\n        actions: 'remove request',\n      },\n    },\n    initial: 'idle',\n    states: {\n      idle: {\n        on: {\n          connect: {\n            target: 'handshaking',\n            guard: 'has target',\n          },\n          post: {\n            actions: 'buffer message',\n          },\n        },\n      },\n      handshaking: {\n        id: 'handshaking',\n        invoke: [\n          {\n            id: 'send syn',\n            src: 'sendBackAtInterval',\n            input: () => ({\n              event: {type: 'syn'},\n              interval: HANDSHAKE_INTERVAL,\n              immediate: true,\n            }),\n          },\n          {\n            id: 'listen for handshake',\n            src: 'listen',\n            input: (input) =>\n              listenInputFromContext({\n                include: MSG_HANDSHAKE_SYN_ACK,\n                count: 1,\n              })(input),\n            /* Below would maybe be more readable than transitioning to\n          'connected' on 'message', and 'ack' on exit but having onDone when\n          using passing invocations currently breaks XState Editor */\n            // onDone: {\n            //   target: 'connected',\n            //   actions: 'ack',\n            // },\n          },\n        ],\n        on: {\n          'syn': {\n            actions: 'send handshake syn',\n          },\n          'request': {\n            actions: 'create request',\n          },\n          'post': {\n            actions: 'buffer message',\n          },\n          'message.received': {\n            target: 'connected',\n          },\n          'disconnect': {\n            target: 'disconnected',\n          },\n        },\n        exit: 'send handshake ack',\n      },\n      connected: {\n        entry: 'flush buffer',\n        invoke: {\n          id: 'listen for messages',\n          src: 'listen',\n          input: listenInputFromContext({\n            exclude: [MSG_RESPONSE, MSG_HEARTBEAT],\n          }),\n        },\n        on: {\n          'post': {\n            actions: 'post',\n          },\n          'request': {\n            actions: 'create request',\n          },\n          'response': {\n            actions: 'respond',\n          },\n          'message.received': {\n            actions: 'emit received message',\n          },\n          'disconnect': {\n            target: 'disconnected',\n          },\n        },\n        initial: 'heartbeat',\n        states: {\n          heartbeat: {\n            initial: 'checking',\n            states: {\n              checking: {\n                always: {\n                  guard: 'should send heartbeats',\n                  target: 'sending',\n                },\n              },\n              sending: {\n                on: {\n                  'request.failed': {\n                    target: '#handshaking',\n                  },\n                },\n                invoke: {\n                  id: 'send heartbeat',\n                  src: 'sendBackAtInterval',\n                  input: () => ({\n                    event: {type: 'post', data: {type: MSG_HEARTBEAT, data: undefined}},\n                    interval: 2000,\n                    immediate: false,\n                  }),\n                },\n              },\n            },\n          },\n        },\n      },\n      disconnected: {\n        id: 'disconnected',\n        entry: 'send disconnect',\n        on: {\n          request: {\n            actions: 'create request',\n          },\n          post: {\n            actions: 'buffer message',\n          },\n          connect: {\n            target: 'handshaking',\n            guard: 'has target',\n          },\n        },\n      },\n    },\n  })\n\n  return channelMachine\n}\n\n/**\n * @public\n */\nexport const createChannel = <R extends Message, S extends Message>(\n  input: ChannelInput,\n  machine: ChannelActorLogic<R, S> = createChannelMachine<R, S>(),\n): Channel<R, S> => {\n  const id = input.id || `${input.name}-${uuid()}`\n  const actor = createActor(machine, {\n    input: {...input, id},\n  })\n\n  const on = <T extends R['type'], U extends Extract<R, {type: T}>>(\n    type: T,\n    handler: (event: U['data']) => Promise<U['response']> | U['response'],\n  ) => {\n    const {unsubscribe} = actor.on(\n      // @ts-expect-error @todo `type` typing\n      type,\n      async (event: {type: T; message: ProtocolMessage<U>}) => {\n        const response = await handler(event.message.data)\n        if (response) {\n          actor.send({type: 'response', respondTo: event.message.id, data: response})\n        }\n      },\n    )\n    return unsubscribe\n  }\n\n  const connect = () => {\n    actor.send({type: 'connect'})\n  }\n\n  const disconnect = () => {\n    actor.send({type: 'disconnect'})\n  }\n\n  const onStatus = (handler: (status: Status) => void) => {\n    const currentSnapshot = actor.getSnapshot()\n    let currentStatus: Status =\n      typeof currentSnapshot.value === 'string'\n        ? currentSnapshot.value\n        : Object.keys(currentSnapshot.value)[0]\n\n    const {unsubscribe} = actor.subscribe((state) => {\n      const status: Status =\n        typeof state.value === 'string' ? state.value : Object.keys(state.value)[0]\n      if (currentStatus !== status) {\n        currentStatus = status\n        handler(status)\n      }\n    })\n    return unsubscribe\n  }\n\n  const setTarget = (target: MessageEventSource) => {\n    actor.send({type: 'target.set', target})\n  }\n\n  const post = (data: WithoutResponse<S>) => {\n    actor.send({type: 'post', data})\n  }\n\n  const stop = () => {\n    actor.stop()\n  }\n\n  const start = () => {\n    actor.start()\n    return stop\n  }\n\n  return {\n    actor,\n    connect,\n    disconnect,\n    id,\n    name: input.name,\n    machine,\n    on,\n    onStatus,\n    post,\n    setTarget,\n    start,\n    stop,\n    get target() {\n      return actor.getSnapshot().context.target\n    },\n  }\n}\n","import {\n  createChannel,\n  createChannelMachine,\n  type Channel,\n  type ChannelActorLogic,\n  type ChannelInput,\n} from './channel'\nimport {type InternalEmitEvent, type Message, type StatusEvent, type WithoutResponse} from './types'\n\n/**\n * @public\n */\nexport type ConnectionInput = Omit<ChannelInput, 'target' | 'targetOrigin'>\n\n/**\n * @public\n */\nexport interface ConnectionInstance<R extends Message, S extends Message> {\n  on: <T extends R['type'], U extends Extract<R, {type: T}>>(\n    type: T,\n    handler: (event: U['data']) => Promise<U['response']> | U['response'],\n  ) => () => void\n  onInternalEvent: <\n    T extends InternalEmitEvent<R, S>['type'],\n    U extends Extract<InternalEmitEvent<R, S>, {type: T}>,\n  >(\n    type: T,\n    handler: (event: U) => void,\n  ) => () => void\n  onStatus: (handler: (event: StatusEvent) => void) => void\n  post: (data: WithoutResponse<S>) => void\n  start: () => () => void\n  stop: () => void\n}\n\n/**\n * @public\n */\nexport interface Controller {\n  addTarget: (target: MessageEventSource) => () => void\n  createConnection: <R extends Message, S extends Message>(\n    input: ConnectionInput,\n    machine?: ChannelActorLogic<R, S>,\n  ) => ConnectionInstance<R, S>\n  destroy: () => void\n}\n\ninterface Connection<\n  R extends Message = Message,\n  S extends Message = Message,\n  T extends InternalEmitEvent<R, S>['type'] = InternalEmitEvent<R, S>['type'],\n> {\n  input: ConnectionInput\n  channels: Set<Channel<R, S>>\n  internalEventSubscribers: Set<{\n    type: T\n    handler: (event: Extract<InternalEmitEvent<R, S>, {type: T}>) => void\n    unsubscribers: Array<() => void>\n  }>\n  machine: ChannelActorLogic<R, S>\n  statusSubscribers: Set<{\n    handler: (event: StatusEvent) => void\n    unsubscribers: Array<() => void>\n  }>\n  subscribers: Set<{\n    type: R['type']\n    handler: (event: R['data']) => Promise<R['response']> | R['response']\n    unsubscribers: Array<() => void>\n  }>\n}\n\nconst noop = () => {}\n\n/**\n * @public\n */\nexport const createController = (input: {targetOrigin: string}): Controller => {\n  const {targetOrigin} = input\n  const targets = new Set<MessageEventSource>()\n  const connections = new Set<Connection>()\n\n  const addTarget = (target: MessageEventSource) => {\n    // If the target has already been added, return just a noop cleanup\n    if (targets.has(target)) {\n      return noop\n    }\n\n    if (!targets.size || !connections.size) {\n      targets.add(target)\n\n      // If there are existing connections, set the target on all existing\n      // channels, and trigger a connection event\n      connections.forEach((connection) => {\n        connection.channels.forEach((channel) => {\n          channel.setTarget(target)\n          channel.connect()\n        })\n      })\n      // We perform a 'soft' cleanup here: disconnect only as we want to\n      // maintain at least one live channel per connection\n      return () => {\n        targets.delete(target)\n        connections.forEach((connection) => {\n          connection.channels.forEach((channel) => {\n            if (channel.target === target) {\n              channel.disconnect()\n            }\n          })\n        })\n      }\n    }\n\n    targets.add(target)\n\n    // Maintain a list of channels to cleanup\n    const targetChannels = new Set<Channel<Message, Message>>()\n\n    // If we already have targets and connections, we need to create new\n    // channels for each source with all the associated subscribers.\n    connections.forEach((connection) => {\n      const channel = createChannel(\n        {\n          ...connection.input,\n          target,\n          targetOrigin,\n        },\n        connection.machine,\n      )\n\n      targetChannels.add(channel)\n      connection.channels.add(channel)\n\n      connection.subscribers.forEach(({type, handler, unsubscribers}) => {\n        unsubscribers.push(channel.on(type, handler))\n      })\n      connection.internalEventSubscribers.forEach(({type, handler, unsubscribers}) => {\n        // @ts-expect-error @todo\n        unsubscribers.push(channel.actor.on(type, handler).unsubscribe)\n      })\n      connection.statusSubscribers.forEach(({handler, unsubscribers}) => {\n        unsubscribers.push(channel.onStatus((status) => handler({channel: channel.id, status})))\n      })\n\n      channel.start()\n      channel.connect()\n    })\n\n    // We perform a more 'aggressive' cleanup here as we do not need to maintain\n    // these 'duplicate' channels: disconnect, stop, and delete\n    return () => {\n      targets.delete(target)\n      targetChannels.forEach((channel) => {\n        cleanupChannel(channel)\n        connections.forEach((connection) => {\n          connection.channels.delete(channel)\n        })\n      })\n    }\n  }\n\n  const cleanupChannel: (channel: Channel<Message, Message>) => void = (channel) => {\n    channel.disconnect()\n    // Necessary to allow disconnect messages to be sent before the channel\n    // actor is stopped\n    setTimeout(() => {\n      channel.stop()\n    }, 0)\n  }\n\n  const createConnection = <R extends Message, S extends Message>(\n    input: ConnectionInput,\n    machine: ChannelActorLogic<R, S> = createChannelMachine<R, S>(),\n  ): ConnectionInstance<R, S> => {\n    const connection: Connection<R, S> = {\n      channels: new Set(),\n      input,\n      internalEventSubscribers: new Set(),\n      machine,\n      statusSubscribers: new Set(),\n      subscribers: new Set(),\n    }\n\n    // @ts-expect-error @todo @help\n    connections.add(connection)\n\n    const {channels, internalEventSubscribers, statusSubscribers, subscribers} = connection\n\n    if (targets.size) {\n      // If targets have already been added, create a channel for each target\n      targets.forEach((target) => {\n        const channel = createChannel<R, S>(\n          {\n            ...input,\n            target,\n            targetOrigin,\n          },\n          machine,\n        )\n        channels.add(channel)\n      })\n    } else {\n      // If targets have not been added yet, create a channel without a target\n      const channel = createChannel<R, S>({...input, targetOrigin}, machine)\n      channels.add(channel)\n    }\n\n    const post: ConnectionInstance<R, S>['post'] = (data) => {\n      channels.forEach((channel) => {\n        channel.post(data)\n      })\n    }\n\n    const on: ConnectionInstance<R, S>['on'] = (type, handler) => {\n      const unsubscribers: Array<() => void> = []\n      channels.forEach((channel) => {\n        unsubscribers.push(channel.on(type, handler))\n      })\n      const subscriber = {type, handler, unsubscribers}\n      subscribers.add(subscriber)\n      return () => {\n        unsubscribers.forEach((unsub) => unsub())\n        subscribers.delete(subscriber)\n      }\n    }\n\n    const onInternalEvent = <\n      T extends InternalEmitEvent<R, S>['type'],\n      U extends Extract<InternalEmitEvent<R, S>, {type: T}>,\n    >(\n      type: T,\n      handler: (event: U) => void,\n    ) => {\n      const unsubscribers: Array<() => void> = []\n      channels.forEach((channel) => {\n        // @ts-expect-error @todo @help\n        unsubscribers.push(channel.actor.on(type, handler).unsubscribe)\n      })\n      const subscriber = {type, handler, unsubscribers}\n      // @ts-expect-error @todo @help\n      internalEventSubscribers.add(subscriber)\n      return () => {\n        unsubscribers.forEach((unsub) => unsub())\n        // @ts-expect-error @todo @help\n        internalEventSubscribers.delete(subscriber)\n      }\n    }\n\n    const onStatus = (handler: (event: StatusEvent) => void) => {\n      const unsubscribers: Array<() => void> = []\n      channels.forEach((channel) => {\n        unsubscribers.push(channel.onStatus((status) => handler({channel: channel.id, status})))\n      })\n      const subscriber = {handler, unsubscribers}\n      statusSubscribers.add(subscriber)\n      return () => {\n        unsubscribers.forEach((unsub) => unsub())\n        statusSubscribers.delete(subscriber)\n      }\n    }\n\n    const stop = () => {\n      channels.forEach((channel) => {\n        channel.disconnect()\n        channel.stop()\n      })\n    }\n\n    const start = () => {\n      channels.forEach((channel) => {\n        channel.start()\n        channel.connect()\n      })\n\n      return stop\n    }\n\n    return {\n      on,\n      onInternalEvent,\n      onStatus,\n      post,\n      start,\n      stop,\n    }\n  }\n\n  const destroy = () => {\n    connections.forEach(({channels}) => {\n      channels.forEach((channel) => {\n        cleanupChannel(channel)\n        channels.delete(channel)\n      })\n    })\n  }\n\n  return {\n    addTarget,\n    createConnection,\n    destroy,\n  }\n}\n","import {v4 as uuid} from 'uuid'\nimport {\n  assertEvent,\n  assign,\n  createActor,\n  emit,\n  enqueueActions,\n  raise,\n  setup,\n  stopChild,\n  type ActorRefFrom,\n} from 'xstate'\nimport {createListenLogic, listenInputFromContext} from './common'\nimport {\n  DOMAIN,\n  MSG_DISCONNECT,\n  MSG_HANDSHAKE_ACK,\n  MSG_HANDSHAKE_SYN,\n  MSG_HANDSHAKE_SYN_ACK,\n  MSG_HEARTBEAT,\n  MSG_RESPONSE,\n} from './constants'\nimport {createRequestMachine, type RequestActorRef} from './request'\nimport type {\n  BufferAddedEmitEvent,\n  BufferFlushedEmitEvent,\n  HeartbeatEmitEvent,\n  HeartbeatMessage,\n  Message,\n  MessageEmitEvent,\n  ProtocolMessage,\n  RequestData,\n  Status,\n  WithoutResponse,\n} from './types'\n\n/**\n * @public\n */\nexport interface NodeInput {\n  name: string\n  connectTo: string\n  domain?: string\n}\n\n/**\n * @public\n */\nexport type NodeActorLogic<R extends Message, S extends Message> = ReturnType<\n  typeof createNodeMachine<R, S>\n>\n\n/**\n * @public\n */\nexport type NodeActor<R extends Message, S extends Message> = ActorRefFrom<NodeActorLogic<R, S>>\n\n/**\n * @public\n */\nexport type Node<R extends Message, S extends Message> = {\n  actor: NodeActor<R, S>\n  fetch: <const T extends S['type'], U extends WithoutResponse<S>>(\n    data: U,\n    options?: {signal?: AbortSignal},\n  ) => S extends U ? (S['type'] extends T ? Promise<S['response']> : never) : never\n  machine: NodeActorLogic<R, S>\n  on: <T extends R['type'], U extends Extract<R, {type: T}>>(\n    type: T,\n    handler: (event: U['data']) => U['response'],\n  ) => () => void\n  onStatus: (handler: (status: Status) => void) => () => void\n  post: (data: WithoutResponse<S>) => void\n  start: () => () => void\n  stop: () => void\n}\n\n/**\n * @public\n */\nexport const createNodeMachine = <\n  R extends Message, // Receives\n  S extends Message, // Sends\n  V extends WithoutResponse<S> = WithoutResponse<S>,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n>() => {\n  const nodeMachine = setup({\n    types: {} as {\n      children: {\n        'listen for disconnect': 'listen'\n        'listen for handshake ack': 'listen'\n        'listen for handshake syn': 'listen'\n        'listen for heartbeat': 'listen'\n        'listen for messages': 'listen'\n      }\n      context: {\n        buffer: Array<{\n          data: V\n          resolvable?: PromiseWithResolvers<S['response']>\n          signal?: AbortSignal\n        }>\n        connectionId: string | null\n        connectTo: string\n        domain: string\n        // The handshake buffer is a workaround to maintain backwards\n        // compatibility with the Sanity channels package, which may incorrectly\n        // send buffered messages _before_ it completes the handshake (i.e.\n        // sends an ack message). It should be removed in the next major.\n        handshakeBuffer: Array<{\n          type: 'message.received'\n          message: MessageEvent<ProtocolMessage<R>>\n        }>\n        name: string\n        requests: Array<RequestActorRef<S>>\n        target: MessageEventSource | undefined\n        targetOrigin: string | null\n      }\n      emitted:\n        | BufferAddedEmitEvent<V>\n        | BufferFlushedEmitEvent<V>\n        | HeartbeatEmitEvent\n        | MessageEmitEvent<R>\n        | (R extends R ? {type: R['type']; message: ProtocolMessage<R>} : never)\n      events:\n        | {type: 'heartbeat.received'; message: MessageEvent<ProtocolMessage<HeartbeatMessage>>}\n        | {type: 'message.received'; message: MessageEvent<ProtocolMessage<R>>}\n        | {\n            type: 'post'\n            data: V\n            resolvable?: PromiseWithResolvers<S['response']>\n            signal?: AbortSignal\n          }\n        | {type: 'request.aborted'; requestId: string}\n        | {type: 'request.failed'; requestId: string}\n        | {\n            type: 'request.success'\n            requestId: string\n            response: S['response'] | null\n            responseTo: string | undefined\n          }\n        | {type: 'request'; data: RequestData<S> | RequestData<S>[]} // @todo align with 'post' type\n      input: NodeInput\n    },\n    actors: {\n      requestMachine: createRequestMachine<S>(),\n      listen: createListenLogic(),\n    },\n    actions: {\n      'buffer incoming message': assign({\n        handshakeBuffer: ({event, context}) => {\n          assertEvent(event, 'message.received')\n          return [...context.handshakeBuffer, event]\n        },\n      }),\n      'buffer message': enqueueActions(({enqueue}) => {\n        enqueue.assign({\n          buffer: ({event, context}) => {\n            assertEvent(event, 'post')\n            return [\n              ...context.buffer,\n              {\n                data: event.data,\n                resolvable: event.resolvable,\n                signal: event.signal,\n              },\n            ]\n          },\n        })\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'post')\n          return {\n            type: '_buffer.added',\n            message: event.data,\n          } satisfies BufferAddedEmitEvent<V>\n        })\n      }),\n      'create request': assign({\n        requests: ({context, event, self, spawn}) => {\n          assertEvent(event, 'request')\n          const arr = Array.isArray(event.data) ? event.data : [event.data]\n          const requests = arr.map((request) => {\n            const id = `req-${uuid()}`\n            return spawn('requestMachine', {\n              id,\n              input: {\n                connectionId: context.connectionId!,\n                data: request.data,\n                domain: context.domain!,\n                expectResponse: request.expectResponse,\n                from: context.name,\n                parentRef: self,\n                resolvable: request.resolvable,\n                responseTo: request.responseTo,\n                sources: context.target!,\n                targetOrigin: context.targetOrigin!,\n                to: context.connectTo,\n                type: request.type,\n                signal: request.signal,\n              },\n            })\n          })\n          return [...context.requests, ...requests]\n        },\n      }),\n      'emit heartbeat': emit(() => {\n        return {\n          type: '_heartbeat',\n        } satisfies HeartbeatEmitEvent\n      }),\n      'emit received message': enqueueActions(({enqueue}) => {\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'message.received')\n          return {\n            type: '_message',\n            message: event.message.data,\n          } satisfies MessageEmitEvent<R>\n        })\n        enqueue.emit(({event}) => {\n          assertEvent(event, 'message.received')\n          const emit = {\n            type: event.message.data.type,\n            message: event.message.data,\n          }\n          return emit\n        })\n      }),\n      'flush buffer': enqueueActions(({enqueue}) => {\n        enqueue.raise(({context}) => ({\n          type: 'request',\n          data: context.buffer.map(({data, resolvable, signal}) => ({\n            data: data.data,\n            type: data.type,\n            expectResponse: resolvable ? true : false,\n            resolvable,\n            signal,\n          })),\n        }))\n        enqueue.emit(({context}) => {\n          return {\n            type: '_buffer.flushed',\n            messages: context.buffer.map(({data}) => data),\n          } satisfies BufferFlushedEmitEvent<V>\n        })\n        enqueue.assign({\n          buffer: [],\n        })\n      }),\n      'flush handshake buffer': enqueueActions(({context, enqueue}) => {\n        context.handshakeBuffer.forEach((event) => enqueue.raise(event))\n        enqueue.assign({\n          handshakeBuffer: [],\n        })\n      }),\n      'post': raise(({event}) => {\n        assertEvent(event, 'post')\n        return {\n          type: 'request' as const,\n          data: {\n            data: event.data.data,\n            expectResponse: event.resolvable ? true : false,\n            type: event.data.type,\n            resolvable: event.resolvable,\n            signal: event.signal,\n          },\n        }\n      }),\n      'remove request': enqueueActions(({context, enqueue, event}) => {\n        assertEvent(event, ['request.success', 'request.failed', 'request.aborted'])\n        stopChild(event.requestId)\n        enqueue.assign({requests: context.requests.filter(({id}) => id !== event.requestId)})\n      }),\n      'send response': raise(({event}) => {\n        assertEvent(event, ['message.received', 'heartbeat.received'])\n        return {\n          type: 'request' as const,\n          data: {\n            type: MSG_RESPONSE,\n            responseTo: event.message.data.id,\n            data: undefined,\n          },\n        }\n      }),\n      'send handshake syn ack': raise({\n        type: 'request',\n        data: {type: MSG_HANDSHAKE_SYN_ACK},\n      }),\n      'set connection config': assign({\n        connectionId: ({event}) => {\n          assertEvent(event, 'message.received')\n          return event.message.data.connectionId\n        },\n        target: ({event}) => {\n          assertEvent(event, 'message.received')\n          return event.message.source || undefined\n        },\n        targetOrigin: ({event}) => {\n          assertEvent(event, 'message.received')\n          return event.message.origin\n        },\n      }),\n    },\n    guards: {\n      hasSource: ({context}) => context.target !== null,\n    },\n  }).createMachine({\n    /** @xstate-layout N4IgpgJg5mDOIC5QDsD2EwGIBOYCOArnAC4B0sBAxpXLANoAMAuoqAA6qwCWxXqyrEAA9EAVgYAWUgEYJDUQA4JAZmUSJC0coDsAGhABPRNIYLSErdOkBOAGzbx227YUBfV-rQYc+IrDIAZgCGXAA2kIwsSCAc3Lz8giIIoiakqgBMDKbp2tYS0srp+kYI0ununuhgpFwQ4ZgQ-NVcyABuqADW1V7NdWAILe2UQfHIkZGCsTx8AtFJ6aKipAzWOtrpC7Z5BUWGiNoK6aS26RLW2tLaqkqqFSA9NX2YALa0QTCkuDRcrRHMk5xpgk5ogJLZSNZIVDoVCFLZiohbIVSLkXLZRHZDgxbHcHrV6rFiBNolNRolEVJbCsdGUzsoyhiEcllOC1DowelVmVrOUPPcqqQABZBZAQWDCjotKANJo1NqdboC4Wi8VBSXIKADeXDUbjf4kwFkkEILbg8RZMHKOzWKzKJkHJa086Xa4qZS4pUisUSqU+QgkYnsQ0zcnJaRLDbpZwKNQSBYspm2MEyC5KTnaDSSd18h7K71q32EwMxYPA0BJFLKY5yZxIrKSURM0RnFHSBTrQqQ9babQejBCr2q9XSiBcWCUfjIMCUIn6oNxEPGtTWFFR0RUy7iGzt+3Ip0XURXVZKPvVCfIKczyB+vyzqLzoGzcuIG0MGTyCztjRtjaJjbHVMNAUTdu1PUhz0vYhryLOcSwXMthBfK0ZGsLQGBZekCi0Jso1IdI23WG04zOE4wIg6coIgBox3Imdi1JRdnxNOxSHNSQkWtW0mTjMxMQ7fDzgcbNKn7WjKJeN4Pi+MAfj+e84MfUMFHbZZwxOHZNDyO09gQOQjmAhZJCM9IMjIycKOvQUwCCbBiAAI2sshpNkiB6NLJ9EIQBQbWOdJlMhYCUjbJkchXGsFmsJQMVsWl3BzKp4GiHoAXgjykgAWmkZZ6xy3LZF2EobCy6xsQWJQ42kE4FjA-EwBSxTjSRUhDgqkzgO2BxdykU4AvXFQ-KjMC8yHKV6qNJi6WOdcypcZsXGxe0JG0XySKjM5lKsMyLwsiAxsYzylDfONznUEqrmi+1ThkHqXDONbULi1wgA */\n    id: 'node',\n    context: ({input}) => ({\n      buffer: [],\n      connectionId: null,\n      connectTo: input.connectTo,\n      domain: input.domain ?? DOMAIN,\n      handshakeBuffer: [],\n      name: input.name,\n      requests: [],\n      target: undefined,\n      targetOrigin: null,\n    }),\n    on: {\n      'request.success': {\n        actions: 'remove request',\n      },\n      'request.failed': {\n        actions: 'remove request',\n      },\n      'request.aborted': {\n        actions: 'remove request',\n      },\n    },\n    initial: 'idle',\n    states: {\n      idle: {\n        invoke: {\n          id: 'listen for handshake syn',\n          src: 'listen',\n          input: listenInputFromContext({\n            include: MSG_HANDSHAKE_SYN,\n            count: 1,\n          }),\n          onDone: {\n            target: 'handshaking',\n            guard: 'hasSource',\n          },\n        },\n        on: {\n          'message.received': {\n            actions: 'set connection config',\n          },\n          'post': {\n            actions: 'buffer message',\n          },\n        },\n      },\n      handshaking: {\n        entry: 'send handshake syn ack',\n        invoke: [\n          {\n            id: 'listen for handshake ack',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_HANDSHAKE_ACK,\n              count: 1,\n              // Override the default `message.received` responseType to prevent\n              // buffering the ack message. We transition to the connected state\n              // using onDone instead of listening to this event using `on`\n              responseType: 'handshake.complete',\n            }),\n            onDone: 'connected',\n          },\n          {\n            id: 'listen for disconnect',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_DISCONNECT,\n              count: 1,\n              responseType: 'disconnect',\n            }),\n          },\n          {\n            id: 'listen for messages',\n            src: 'listen',\n            input: listenInputFromContext({\n              exclude: [MSG_DISCONNECT, MSG_HANDSHAKE_ACK, MSG_HEARTBEAT, MSG_RESPONSE],\n            }),\n          },\n        ],\n        on: {\n          'request': {\n            actions: 'create request',\n          },\n          'post': {\n            actions: 'buffer message',\n          },\n          'message.received': {\n            actions: 'buffer incoming message',\n          },\n          'disconnect': {\n            target: 'idle',\n          },\n        },\n      },\n      connected: {\n        entry: ['flush handshake buffer', 'flush buffer'],\n        invoke: [\n          {\n            id: 'listen for messages',\n            src: 'listen',\n            input: listenInputFromContext({\n              exclude: [MSG_RESPONSE, MSG_HEARTBEAT],\n            }),\n          },\n          {\n            id: 'listen for heartbeat',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_HEARTBEAT,\n              responseType: 'heartbeat.received',\n            }),\n          },\n          {\n            id: 'listen for disconnect',\n            src: 'listen',\n            input: listenInputFromContext({\n              include: MSG_DISCONNECT,\n              count: 1,\n              responseType: 'disconnect',\n            }),\n          },\n        ],\n        on: {\n          'request': {\n            actions: 'create request',\n          },\n          'post': {\n            actions: 'post',\n          },\n          'disconnect': {\n            target: 'idle',\n          },\n          'message.received': {\n            actions: ['send response', 'emit received message'],\n          },\n          'heartbeat.received': {\n            actions: ['send response', 'emit heartbeat'],\n          },\n        },\n      },\n    },\n  })\n  return nodeMachine\n}\n\n/**\n * @public\n */\nexport const createNode = <R extends Message, S extends Message>(\n  input: NodeInput,\n  machine: NodeActorLogic<R, S> = createNodeMachine<R, S>(),\n): Node<R, S> => {\n  const actor = createActor(machine, {\n    input,\n  })\n\n  const on = <T extends R['type'], U extends Extract<R, {type: T}>>(\n    type: T,\n    handler: (event: U['data']) => U['response'],\n  ) => {\n    const {unsubscribe} = actor.on(\n      // @ts-expect-error @todo `type` typing\n      type,\n      (event: {type: T; message: ProtocolMessage<U>}) => {\n        handler(event.message.data)\n      },\n    )\n    return unsubscribe\n  }\n\n  const onStatus = (handler: (status: Status) => void) => {\n    const snapshot = actor.getSnapshot()\n    let currentStatus: Status =\n      typeof snapshot.value === 'string' ? snapshot.value : Object.keys(snapshot.value)[0]\n\n    const {unsubscribe} = actor.subscribe((state) => {\n      const status: Status =\n        typeof state.value === 'string' ? state.value : Object.keys(state.value)[0]\n      if (currentStatus !== status) {\n        currentStatus = status\n        handler(status)\n      }\n    })\n    return unsubscribe\n  }\n\n  const post = (data: WithoutResponse<S>) => {\n    actor.send({type: 'post', data})\n  }\n\n  const fetch = (data: WithoutResponse<S>, options?: {signal?: AbortSignal}) => {\n    const resolvable = Promise.withResolvers<S['response']>()\n    actor.send({\n      type: 'post',\n      data,\n      resolvable,\n      signal: options?.signal,\n    })\n    return resolvable.promise as never\n  }\n\n  const stop = () => {\n    actor.stop()\n  }\n\n  const start = () => {\n    actor.start()\n    return stop\n  }\n\n  return {\n    actor,\n    fetch,\n    machine,\n    on,\n    onStatus,\n    post,\n    start,\n    stop,\n  }\n}\n"],"names":["Object","defineProperty","exports","value","uuid","require","xstate","rxjs","listenInputFromContext","config","context","count","include","exclude","responseType","domain","from","connectTo","Array","isArray","target","to","name","messageEvents$","defer","fromEvent","window","createListenLogic","compatMap","fromEventObservable","input","pipe","map","filter","event","data","length","includes","type","source","listenFilter","message","bufferCount","concatMap","arr","take","DOMAIN","MSG_RESPONSE","MSG_HEARTBEAT","MSG_DISCONNECT","MSG_HANDSHAKE_SYN","MSG_HANDSHAKE_SYN_ACK","MSG_HANDSHAKE_ACK","HANDSHAKE_MSG_TYPES","INTERNAL_MSG_TYPES","createRequestMachine","setup","types","actors","listen","abortSignal$","signal","requestId","Error","EMPTY","responseTo","sources","has","size","takeUntil","actions","params","targetOrigin","forEach","postMessage","sendTo","parentRef","self","response","resolvable","resolve","id","console","warn","reject","guards","expectsResponse","expectResponse","delays","initialTimeout","responseTimeout","createMachine","connectionId","v4","Set","initial","on","abort","states","idle","after","sending","entry","always","guard","awaiting","invoke","src","onError","assign","failed","success","aborted","output","sendBackAtInterval","fromCallback","sendBack","send","immediate","interval","setInterval","clearInterval","createChannelMachine","requestMachine","enqueueActions","enqueue","buffer","assertEvent","emit","requests","spawn","request","raise","messages","post","stopChild","respond","respondTo","heartbeat","connect","handshaking","syn","disconnect","exit","connected","checking","disconnected","createChannel","machine","actor","createActor","stop","handler","unsubscribe","async","onStatus","currentSnapshot","getSnapshot","currentStatus","keys","subscribe","state","status","setTarget","start","noop","createNodeMachine","handshakeBuffer","origin","hasSource","onDone","HANDSHAKE_INTERVAL","HEARTBEAT_INTERVAL","RESPONSE_TIMEOUT","createController","targets","connections","cleanupChannel","channel","setTimeout","addTarget","add","connection","channels","delete","targetChannels","subscribers","unsubscribers","push","internalEventSubscribers","statusSubscribers","createConnection","subscriber","unsub","onInternalEvent","destroy","createNode","fetch","options","Promise","withResolvers","promise","snapshot"],"mappings":"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"}