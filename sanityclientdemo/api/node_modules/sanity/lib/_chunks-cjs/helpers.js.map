{"version":3,"file":"helpers.js","sources":["../../src/_internal/cli/actions/deploy/helpers.ts"],"sourcesContent":["import fs from 'node:fs/promises'\nimport path from 'node:path'\nimport {PassThrough} from 'node:stream'\nimport {type Gzip} from 'node:zlib'\n\nimport {type CliCommandContext, type CliOutputter} from '@sanity/cli'\nimport {type SanityClient} from '@sanity/client'\nimport FormData from 'form-data'\nimport readPkgUp from 'read-pkg-up'\n\nimport {debug as debugIt} from '../../debug'\n\nexport const debug = debugIt.extend('deploy')\n\n// TODO: replace with `Promise.withResolvers()` once it lands in node\nfunction promiseWithResolvers<T>() {\n  let resolve!: (t: T) => void\n  let reject!: (err: unknown) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return {promise, resolve, reject}\n}\n\nexport interface ActiveDeployment {\n  deployedAt: string\n  deployedBy: string\n  isActiveDeployment: boolean\n  isAutoUpdating: boolean | null\n  size: string | null\n  createdAt: string\n  updatedAt: string\n  version: string\n}\n\nexport interface UserApplication {\n  id: string\n  projectId: string\n  title: string | null\n  appHost: string\n  urlType: 'internal' | 'external'\n  createdAt: string\n  updatedAt: string\n  type: 'studio'\n  activeDeployment?: ActiveDeployment | null\n}\n\nexport interface GetUserApplicationsOptions {\n  client: SanityClient\n}\n\nexport interface GetUserApplicationOptions extends GetUserApplicationsOptions {\n  appHost?: string\n}\n\nexport async function getUserApplication({\n  client,\n  appHost,\n}: GetUserApplicationOptions): Promise<UserApplication | null> {\n  try {\n    return await client.request({\n      uri: '/user-applications',\n      query: appHost ? {appHost} : {default: 'true'},\n    })\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user application', e)\n    throw e\n  }\n}\n\nexport async function getUserApplications({\n  client,\n}: GetUserApplicationsOptions): Promise<UserApplication[] | null> {\n  try {\n    return await client.request({\n      uri: '/user-applications',\n    })\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user application', e)\n    throw e\n  }\n}\n\nfunction createUserApplication(\n  client: SanityClient,\n  body: Pick<UserApplication, 'appHost' | 'urlType'> & {\n    title?: string\n  },\n): Promise<UserApplication> {\n  return client.request({uri: '/user-applications', method: 'POST', body})\n}\n\nexport interface GetOrCreateUserApplicationOptions {\n  client: SanityClient\n  context: Pick<CliCommandContext, 'output' | 'prompt'>\n  spinner: ReturnType<CliOutputter['spinner']>\n}\n\n/**\n * This function handles the logic for managing user applications when\n * studioHost is not provided in the CLI config.\n *\n * @internal\n *\n *    +-------------------------------+\n *    |   Fetch Existing user-app?   |\n *    +---------+--------------------+\n *              |\n *        +-----+-----+\n *        |           |\n *        v           v\n *   +---------+  +-------------------------+\n *   | Return  |  | Fetch all user apps     |\n *   | user-app|  +-------------------------+\n *   +---------+            |\n *                          v\n *           +---------------------------+\n *           |  User apps found?         |\n *           +-----------+---------------+\n *                       |\n *                +------v------+\n *                |             |\n *                v             v\n *   +--------------------+  +------------------------+\n *   | Show list and      |  | Prompt for hostname    |\n *   | prompt selection   |  | and create new app     |\n *   +--------------------+  +------------------------+\n */\nexport async function getOrCreateUserApplication({\n  client,\n  spinner,\n  context,\n}: GetOrCreateUserApplicationOptions): Promise<UserApplication> {\n  const {output, prompt} = context\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  const userApplications = await getUserApplications({client})\n\n  if (userApplications?.length) {\n    const choices = userApplications.map((app) => ({\n      value: app.appHost,\n      name: app.appHost,\n    }))\n\n    const selected = await prompt.single({\n      message: 'Select existing studio hostname',\n      type: 'list',\n      choices: [\n        {value: 'new', name: 'Create new studio hostname'},\n        new prompt.Separator(),\n        ...choices,\n      ],\n    })\n\n    // if the user selected an existing app, return it\n    if (selected !== 'new') {\n      return userApplications.find((app) => app.appHost === selected)!\n    }\n  }\n\n  // otherwise, prompt the user for a hostname\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print('To deploy your Sanity Studio to our hosted sanity.studio service,')\n  output.print('you will need one. Please enter the part you want to use.')\n\n  const {promise, resolve} = promiseWithResolvers<UserApplication>()\n\n  await prompt.single({\n    type: 'input',\n    filter: (inp: string) => inp.replace(/\\.sanity\\.studio$/i, ''),\n    message: 'Studio hostname (<value>.sanity.studio):',\n    // if a string is returned here, it is relayed to the user and prompt allows\n    // the user to try again until this function returns true\n    validate: async (appHost: string) => {\n      try {\n        const response = await createUserApplication(client, {\n          appHost,\n          urlType: 'internal',\n        })\n        resolve(response)\n        return true\n      } catch (e) {\n        // if the name is taken, it should return a 409 so we relay to the user\n        if ([402, 409].includes(e?.statusCode)) {\n          return e?.response?.body?.message || 'Bad request' // just in case\n        }\n\n        debug('Error creating user application', e)\n        // otherwise, it's a fatal error\n        throw e\n      }\n    },\n  })\n\n  return await promise\n}\n\n/**\n * This function handles the logic for managing user applications when\n * studioHost is provided in the CLI config.\n *\n * @internal\n */\nexport async function getOrCreateUserApplicationFromConfig({\n  client,\n  context,\n  spinner,\n  appHost,\n}: GetOrCreateUserApplicationOptions & {\n  appHost: string\n}): Promise<UserApplication> {\n  const {output} = context\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client, appHost})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print(`Creating https://${appHost}.sanity.studio`)\n  output.print('')\n  spinner.start('Creating studio hostname')\n\n  try {\n    const response = await createUserApplication(client, {\n      appHost,\n      urlType: 'internal',\n    })\n    spinner.succeed()\n\n    return response\n  } catch (e) {\n    spinner.fail()\n    // if the name is taken, it should return a 409 so we relay to the user\n    if ([402, 409].includes(e?.statusCode)) {\n      throw new Error(e?.response?.body?.message || 'Bad request') // just in case\n    }\n\n    debug('Error creating user application from config', e)\n    // otherwise, it's a fatal error\n    throw e\n  }\n}\n\nexport interface CreateDeploymentOptions {\n  client: SanityClient\n  applicationId: string\n  version: string\n  isAutoUpdating: boolean\n  tarball: Gzip\n}\n\nexport async function createDeployment({\n  client,\n  tarball,\n  applicationId,\n  isAutoUpdating,\n  version,\n}: CreateDeploymentOptions): Promise<{location: string}> {\n  const formData = new FormData()\n  formData.append('isAutoUpdating', isAutoUpdating.toString())\n  formData.append('version', version)\n  formData.append('tarball', tarball, {contentType: 'application/gzip', filename: 'app.tar.gz'})\n\n  return client.request({\n    uri: `/user-applications/${applicationId}/deployments`,\n    method: 'POST',\n    headers: formData.getHeaders(),\n    body: formData.pipe(new PassThrough()),\n  })\n}\n\nexport interface DeleteUserApplicationOptions {\n  client: SanityClient\n  applicationId: string\n}\n\nexport async function deleteUserApplication({\n  applicationId,\n  client,\n}: DeleteUserApplicationOptions): Promise<void> {\n  await client.request({uri: `/user-applications/${applicationId}`, method: 'DELETE'})\n}\n\nexport async function getInstalledSanityVersion(): Promise<string> {\n  const sanityPkgPath = (await readPkgUp({cwd: __dirname}))?.path\n  if (!sanityPkgPath) {\n    throw new Error('Unable to resolve `sanity` module root')\n  }\n\n  const pkg = JSON.parse(await fs.readFile(sanityPkgPath, 'utf-8'))\n  if (typeof pkg?.version !== 'string') {\n    throw new Error('Unable to find version of `sanity` module')\n  }\n  return pkg.version\n}\n\nexport async function dirIsEmptyOrNonExistent(sourceDir: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return true\n    }\n\n    throw err\n  }\n\n  const content = await fs.readdir(sourceDir)\n  return content.length === 0\n}\n\nexport async function checkDir(sourceDir: string): Promise<void> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    const error = err.code === 'ENOENT' ? new Error(`Directory \"${sourceDir}\" does not exist`) : err\n\n    throw error\n  }\n\n  try {\n    await fs.stat(path.join(sourceDir, 'index.html'))\n  } catch (err) {\n    const error =\n      err.code === 'ENOENT'\n        ? new Error(\n            [\n              `\"${sourceDir}/index.html\" does not exist -`,\n              '[SOURCE_DIR] must be a directory containing',\n              'a Sanity studio built using \"sanity build\"',\n            ].join(' '),\n          )\n        : err\n\n    throw error\n  }\n}\n"],"names":["debugIt","FormData","PassThrough","readPkgUp","fs","path"],"mappings":"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"}