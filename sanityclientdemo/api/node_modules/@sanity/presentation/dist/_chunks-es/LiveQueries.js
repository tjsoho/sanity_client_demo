import { jsx, Fragment } from "react/jsx-runtime";
import { createCompatibilityActors, getQueryCacheKey } from "./PresentationToolGrantsCheck.js";
import { useQueryParams, useRevalidate } from "./hooks.js";
import { createClient } from "@sanity/client";
import { applySourceDocuments, getPublishedId } from "@sanity/client/csm";
import { createChannelMachine } from "@sanity/comlink";
import isEqual from "fast-deep-equal";
import { useState, useEffect, useMemo, useDeferredValue, memo } from "react";
import { useProjectId, useDataset, useClient } from "sanity";
import { useEffectEvent } from "use-effect-event";
import { MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL } from "./index.js";
function LoaderQueries(props) {
  const {
    liveDocument: _liveDocument,
    controller,
    perspective: activePerspective,
    onLoadersConnection,
    onDocumentsOnPage
  } = props, [comlink, setComlink] = useState(), [liveQueries, setLiveQueries] = useState({}), projectId = useProjectId(), dataset = useDataset();
  useEffect(() => {
    const interval = setInterval(
      () => setLiveQueries((liveQueries2) => {
        if (Object.keys(liveQueries2).length < 1)
          return liveQueries2;
        const now = Date.now();
        if (!Object.values(liveQueries2).some(
          (liveQuery) => liveQuery.heartbeat !== !1 && now > liveQuery.receivedAt + liveQuery.heartbeat
        ))
          return liveQueries2;
        const next = {};
        for (const [key, value] of Object.entries(liveQueries2))
          value.heartbeat !== !1 && now > value.receivedAt + value.heartbeat || (next[key] = value);
        return next;
      }),
      MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL
    );
    return () => clearInterval(interval);
  }, []), useEffect(() => {
    if (controller) {
      const comlink2 = controller.createConnection(
        {
          name: "presentation",
          connectTo: "loaders",
          heartbeat: !0
        },
        createChannelMachine().provide({
          actors: createCompatibilityActors()
        })
      );
      return setComlink(comlink2), comlink2.onStatus(onLoadersConnection), comlink2.on("loader/documents", (data) => {
        data.projectId === projectId && data.dataset === dataset && onDocumentsOnPage(
          "loaders",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          data.perspective,
          data.documents
        );
      }), comlink2.on("loader/query-listen", (data) => {
        if (data.projectId === projectId && data.dataset === dataset) {
          if (typeof data.heartbeat == "number" && data.heartbeat < MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL)
            throw new Error(
              `Loader query listen heartbeat interval must be at least ${MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`
            );
          setLiveQueries((prev) => ({
            ...prev,
            [getQueryCacheKey(data.query, data.params)]: {
              perspective: data.perspective,
              query: data.query,
              params: data.params,
              receivedAt: Date.now(),
              heartbeat: data.heartbeat ?? !1
            }
          }));
        }
      }), comlink2.start();
    }
  }, [controller, dataset, onDocumentsOnPage, onLoadersConnection, projectId]);
  const [syncTagsInUse] = useState(() => /* @__PURE__ */ new Set()), [lastLiveEventId, setLastLiveEventId] = useState(null), studioClient = useClient({ apiVersion: "2023-10-16" }), clientConfig = useMemo(() => studioClient.config(), [studioClient]), client = useMemo(
    () => studioClient.withConfig({
      resultSourceMap: "withKeyArraySelector"
    }),
    [studioClient]
  );
  useEffect(() => {
    if (comlink) {
      const { projectId: projectId2, dataset: dataset2 } = clientConfig;
      comlink.post({
        type: "loader/perspective",
        data: {
          projectId: projectId2,
          dataset: dataset2,
          perspective: activePerspective
        }
      });
    }
  }, [comlink, clientConfig, activePerspective]);
  const handleSyncTags = useEffectEvent((event) => {
    const flattenedSyncTags = Array.from(syncTagsInUse).flat();
    event.tags.some((tag) => flattenedSyncTags.includes(tag)) ? setLastLiveEventId(event.id) : console.log("No matching tags found", event.tags, { flattenedSyncTags });
  });
  useEffect(() => {
    const subscription = createClient(client.config()).withConfig({
      // Necessary for the live drafts to work
      apiVersion: "vX"
    }).live.events({ includeDrafts: !0, tag: "presentation-loader" }).subscribe({
      next: (event) => {
        event.type === "message" ? handleSyncTags(event) : event.type === "restart" ? setLastLiveEventId(event.id) : event.type === "reconnect" && setLastLiveEventId(null);
      },
      // eslint-disable-next-line no-console
      error: (err) => console.error("Error validating EventSource URL:", err)
    });
    return () => subscription.unsubscribe();
  }, [client, handleSyncTags]);
  const liveDocument = useDeferredValue(_liveDocument);
  return /* @__PURE__ */ jsx(Fragment, { children: Object.entries(liveQueries).map(([key, { query, params, perspective }]) => /* @__PURE__ */ jsx(
    QuerySubscription,
    {
      projectId: clientConfig.projectId,
      dataset: clientConfig.dataset,
      perspective,
      query,
      params,
      comlink,
      client,
      liveDocument,
      lastLiveEventId,
      syncTagsInUse
    },
    `${key}${perspective}`
  )) });
}
function QuerySubscriptionComponent(props) {
  const {
    projectId,
    dataset,
    perspective,
    query,
    client,
    liveDocument,
    comlink,
    lastLiveEventId,
    syncTagsInUse
  } = props, params = useQueryParams(props.params), {
    result,
    resultSourceMap,
    syncTags: tags
  } = useQuerySubscription({
    client,
    liveDocument,
    params,
    perspective,
    query,
    lastLiveEventId
  }) || {}, handleQueryChange = useEffectEvent(
    (comlink2, perspective2, query2, params2, result2, resultSourceMap2, tags2) => {
      comlink2?.post({
        type: "loader/query-change",
        data: {
          projectId,
          dataset,
          perspective: perspective2,
          query: query2,
          params: params2,
          result: result2,
          resultSourceMap: resultSourceMap2,
          tags: tags2
        }
      });
    }
  );
  return useEffect(() => {
    if (resultSourceMap && handleQueryChange(comlink, perspective, query, params, result, resultSourceMap, tags), Array.isArray(tags))
      return syncTagsInUse.add(tags), () => {
        syncTagsInUse.delete(tags);
      };
  }, [
    comlink,
    handleQueryChange,
    params,
    perspective,
    query,
    result,
    resultSourceMap,
    syncTagsInUse,
    tags
  ]), null;
}
const QuerySubscription = memo(QuerySubscriptionComponent);
QuerySubscription.displayName = "Memo(QuerySubscription)";
function useQuerySubscription(props) {
  const { liveDocument, client, query, params, perspective, lastLiveEventId } = props, [snapshot, setSnapshot] = useState(null), [error, setError] = useState(null);
  if (error) throw error;
  const [revalidate, startRefresh] = useRevalidate({
    // Refresh interval is set to zero as we're using the Live Draft Content API to revalidate queries
    refreshInterval: 0
  }), shouldRefetch = revalidate === "refresh" || revalidate === "inflight" || lastLiveEventId !== snapshot?.lastLiveEventId;
  useEffect(() => {
    if (!shouldRefetch)
      return;
    let fulfilled = !1, fetching = !1;
    const controller = new AbortController();
    async function effect() {
      const { signal } = controller;
      fetching = !0;
      const { result: result2, resultSourceMap: resultSourceMap2, syncTags: syncTags2 } = await client.fetch(query, params, {
        lastLiveEventId,
        tag: "presentation-loader",
        signal,
        perspective,
        filterResponse: !1,
        returnQuery: !1
      });
      fetching = !1, signal.aborted || (setSnapshot((prev) => ({
        result: isEqual(prev?.result, result2) ? prev?.result : result2,
        resultSourceMap: isEqual(prev?.resultSourceMap, resultSourceMap2) ? prev?.resultSourceMap : resultSourceMap2,
        syncTags: isEqual(prev?.syncTags, syncTags2) ? prev?.syncTags : syncTags2,
        lastLiveEventId
      })), fulfilled = !0);
    }
    const onFinally = startRefresh();
    return effect().catch((error2) => {
      fetching = !1, error2.name !== "AbortError" && setError(error2);
    }).finally(onFinally), () => {
      !fulfilled && !fetching && controller.abort();
    };
  }, [client, lastLiveEventId, params, perspective, query, shouldRefetch, startRefresh]);
  const { result, resultSourceMap, syncTags } = snapshot ?? {};
  return useMemo(() => liveDocument && resultSourceMap ? {
    result: turboChargeResultIfSourceMap(liveDocument, result, perspective, resultSourceMap),
    resultSourceMap,
    syncTags
  } : { result, resultSourceMap, syncTags }, [liveDocument, perspective, result, resultSourceMap, syncTags]);
}
function turboChargeResultIfSourceMap(liveDocument, result, perspective, resultSourceMap) {
  if (perspective === "raw")
    throw new Error("turboChargeResultIfSourceMap does not support raw perspective");
  return applySourceDocuments(
    result,
    resultSourceMap,
    (sourceDocument) => {
      if (
        // If _projectId is set, it's a cross dataset reference and we should skip it
        !sourceDocument._projectId && liveDocument?._id && getPublishedId(liveDocument._id) === getPublishedId(sourceDocument._id)
      )
        return liveDocument;
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (changedValue, { previousValue }) => typeof changedValue == "number" && typeof previousValue == "string" ? `${changedValue}` : changedValue,
    perspective
  );
}
export {
  LoaderQueries as default,
  turboChargeResultIfSourceMap
};
//# sourceMappingURL=LiveQueries.js.map
