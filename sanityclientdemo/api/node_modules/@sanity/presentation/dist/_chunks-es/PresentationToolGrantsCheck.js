import { jsx, jsxs, Fragment } from "react/jsx-runtime";
import { fetchSharedAccessQuery, schemaIdSingleton, schemaTypeSingleton, schemaType } from "@sanity/preview-url-secret/constants";
import { Button, Card, Flex, Container as Container$1, Stack, Text, Inline, Box, Code, Label, ErrorBoundary, Tooltip, TextInput, Spinner, useToast, MenuButton, Menu, Grid, Switch, MenuDivider, MenuItem, usePrefersReducedMotion, TooltipDelayGroupProvider, BoundaryElementProvider } from "@sanity/ui";
import { uuid } from "@sanity/uuid";
import { createContext, useContext, useLayoutEffect, useMemo, useRef, useState, useCallback, useEffect, forwardRef, Suspense, memo, lazy, useImperativeHandle, createElement, startTransition, useReducer } from "react";
import { useTranslation, useUnique, getPublishedId, useDocumentPreviewStore, getPreviewStateObservable, useSchema, SanityDefaultPreview, getPreviewValueWithFallback, PreviewCard, Translate, CommentsIntentProvider, useActiveWorkspace, useClient, useCurrentUser, Hotkeys, useEditState, useProjectId, useDataset, useWorkspace, useGrantsStore } from "sanity";
import { presentationLocaleNamespace, usePresentationTool, PresentationSpinner, PresentationNavigateContext, PresentationParamsContext, PresentationContext, API_VERSION, MAX_TIME_TO_OVERLAYS_CONNECTION, COMMENTS_INSPECTOR_NAME, EDIT_INTENT_MODE, DEFAULT_TOOL_NAME } from "./index.js";
import { createListenLogic, createRequestMachine, DOMAIN, MSG_HANDSHAKE_SYN, MSG_HANDSHAKE_SYN_ACK, MSG_HANDSHAKE_ACK, MSG_RESPONSE, MSG_HEARTBEAT, MSG_DISCONNECT, createController, createChannelMachine } from "@sanity/comlink";
import { studioPath } from "@sanity/client/csm";
import { StateLink, useRouter, decodeJsonParams } from "sanity/router";
import { styled } from "styled-components";
import { WarningOutlineIcon, LaunchIcon, ResetIcon, ShareIcon, CopyIcon, PanelLeftIcon, RefreshIcon, ChevronDownIcon, CheckmarkIcon, MobileDeviceIcon, DesktopIcon, EditIcon, PublishIcon } from "@sanity/icons";
import { PaneRouterContext, PaneLayout, StructureToolProvider, DocumentListPane as DocumentListPane$1, DocumentPane as DocumentPane$1 } from "sanity/structure";
import { DisplayedDocumentBroadcasterProvider } from "./DisplayedDocumentBroadcaster.js";
import { setSecretSearchParams, withoutSecretSearchParams } from "@sanity/preview-url-secret/without-secret-search-params";
import { motion, AnimatePresence, MotionConfig } from "framer-motion";
import { SanityMonogram } from "@sanity/logos";
import { disablePreviewAccessSharing, enablePreviewAccessSharing } from "@sanity/preview-url-secret/toggle-preview-access-sharing";
import isEqual from "fast-deep-equal";
import { match } from "path-to-regexp";
import { createPreviewSecret } from "@sanity/preview-url-secret/create-secret";
import { definePreviewUrl } from "@sanity/preview-url-secret/define-preview-url";
import { suspend } from "suspend-react";
var store;
function getGlobalConfig(config2) {
  return {
    lang: config2?.lang ?? store?.lang,
    message: config2?.message,
    abortEarly: config2?.abortEarly ?? store?.abortEarly,
    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly,
    skipPipe: config2?.skipPipe
  };
}
var store2;
function getGlobalMessage(lang) {
  return store2?.get(lang);
}
var store3;
function getSchemaMessage(lang) {
  return store3?.get(lang);
}
var store4;
function getSpecificMessage(reference, lang) {
  return store4?.get(reference)?.get(lang);
}
function _stringify(input) {
  let type = typeof input;
  return type === "object" && (type = (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null"), type === "string" ? `"${input}"` : type === "number" || type === "bigint" || type === "boolean" ? `${input}` : type;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value, expected = other?.expected ?? context.expects, received = other?.received ?? _stringify(input), issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    // @ts-expect-error
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly,
    skipPipe: config2.skipPipe
  }, isSchema = context.kind === "schema", message = (
    // @ts-expect-error
    context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang)
  );
  message && (issue.message = typeof message == "function" ? message(issue) : message), isSchema && (dataset.typed = !1), dataset.issues ? dataset.issues.push(issue) : dataset.issues = [issue];
}
function _isAllowedObjectKey(key) {
  return key !== "__proto__" && key !== "prototype" && key !== "constructor";
}
var ValiError = class extends Error {
  /**
   * The error issues.
   */
  issues;
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message), this.name = "ValiError", this.issues = issues;
  }
};
function minLength(requirement, message) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${requirement}`,
    requirement,
    message,
    _run(dataset, config2) {
      return dataset.typed && dataset.value.length < this.requirement && _addIssue(this, "length", dataset, config2, {
        received: `${dataset.value.length}`
      }), dataset;
    }
  };
}
function getFallback(schema, dataset, config2) {
  return typeof schema.fallback == "function" ? (
    // @ts-expect-error
    schema.fallback(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.fallback
  );
}
function fallback(schema, fallback2) {
  return {
    ...schema,
    fallback: fallback2,
    _run(dataset, config2) {
      return schema._run(dataset, config2), dataset.issues ? { typed: !0, value: getFallback(this, dataset, config2) } : dataset;
    }
  };
}
function getDefault(schema, dataset, config2) {
  return typeof schema.default == "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message,
    _run(dataset, config2) {
      return typeof dataset.value == "boolean" ? dataset.typed = !0 : _addIssue(this, "type", dataset, config2), dataset;
    }
  };
}
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input == "object") {
        dataset.typed = !0, dataset.value = {};
        for (const key in this.entries) {
          const value2 = input[key], valueDataset = this.entries[key]._run(
            { typed: !1, value: value2 },
            config2
          );
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of valueDataset.issues)
              issue.path ? issue.path.unshift(pathItem) : issue.path = [pathItem], dataset.issues?.push(issue);
            if (dataset.issues || (dataset.issues = valueDataset.issues), config2.abortEarly) {
              dataset.typed = !1;
              break;
            }
          }
          valueDataset.typed || (dataset.typed = !1), (valueDataset.value !== void 0 || key in input) && (dataset.value[key] = valueDataset.value);
        }
      } else
        _addIssue(this, "type", dataset, config2);
      return dataset;
    }
  };
}
function optional(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `${wrapped.expects} | undefined`,
    async: !1,
    wrapped,
    _run(dataset, config2) {
      return dataset.value === void 0 && ("default" in this && (dataset.value = getDefault(
        this,
        dataset,
        config2
      )), dataset.value === void 0) ? (dataset.typed = !0, dataset) : this.wrapped._run(dataset, config2);
    }
  };
  return 0 in args && (schema.default = args[0]), schema;
}
function picklist(options, message) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: options.map(_stringify).join(" | ") || "never",
    async: !1,
    options,
    message,
    _run(dataset, config2) {
      return this.options.includes(dataset.value) ? dataset.typed = !0 : _addIssue(this, "type", dataset, config2), dataset;
    }
  };
}
function record(key, value2, message) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key,
    value: value2,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input == "object") {
        dataset.typed = !0, dataset.value = {};
        for (const entryKey in input)
          if (_isAllowedObjectKey(entryKey)) {
            const entryValue = input[entryKey], keyDataset = this.key._run(
              { typed: !1, value: entryKey },
              config2
            );
            if (keyDataset.issues) {
              const pathItem = {
                type: "record",
                origin: "key",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of keyDataset.issues)
                issue.path = [pathItem], dataset.issues?.push(issue);
              if (dataset.issues || (dataset.issues = keyDataset.issues), config2.abortEarly) {
                dataset.typed = !1;
                break;
              }
            }
            const valueDataset = this.value._run(
              { typed: !1, value: entryValue },
              config2
            );
            if (valueDataset.issues) {
              const pathItem = {
                type: "record",
                origin: "value",
                input,
                key: entryKey,
                value: entryValue
              };
              for (const issue of valueDataset.issues)
                issue.path ? issue.path.unshift(pathItem) : issue.path = [pathItem], dataset.issues?.push(issue);
              if (dataset.issues || (dataset.issues = valueDataset.issues), config2.abortEarly) {
                dataset.typed = !1;
                break;
              }
            }
            (!keyDataset.typed || !valueDataset.typed) && (dataset.typed = !1), keyDataset.typed && (dataset.value[keyDataset.value] = valueDataset.value);
          }
      } else
        _addIssue(this, "type", dataset, config2);
      return dataset;
    }
  };
}
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message,
    _run(dataset, config2) {
      return typeof dataset.value == "string" ? dataset.typed = !0 : _addIssue(this, "type", dataset, config2), dataset;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(dataset) {
      return dataset.typed = !0, dataset;
    }
  };
}
function parse(schema, input, config2) {
  const dataset = schema._run(
    { typed: !1, value: input },
    getGlobalConfig(config2)
  );
  if (dataset.issues)
    throw new ValiError(dataset.issues);
  return dataset.value;
}
function pipe(...pipe2) {
  return {
    ...pipe2[0],
    pipe: pipe2,
    _run(dataset, config2) {
      for (let index = 0; index < pipe2.length; index++) {
        dataset = pipe2[index]._run(dataset, config2);
        const nextAction = pipe2[index + 1];
        if (config2.skipPipe || dataset.issues && (config2.abortEarly || config2.abortPipeEarly || // TODO: This behavior must be documented!
        nextAction?.kind === "schema" || nextAction?.kind === "transformation")) {
          dataset.typed = !1;
          break;
        }
      }
      return dataset;
    }
  };
}
const RE_SEGMENT_WITH_INDEX = /^([A-Za-z]+):([0-9]+)$/, RE_SEGMENT_WITH_TUPLE = /^([A-Za-z]+):([0-9]+),([0-9]+)$/, RE_SEGMENT_WITH_KEY = /^([A-Za-z]+):([a-z0-9]+)$/;
function urlStringToPath(str) {
  const path = [];
  for (const segment of str.split(".")) {
    const withIndex = RE_SEGMENT_WITH_INDEX.exec(segment);
    if (withIndex) {
      path.push(withIndex[1], Number(withIndex[2]));
      continue;
    }
    const withTuple = RE_SEGMENT_WITH_TUPLE.exec(segment);
    if (withTuple) {
      path.push(withTuple[1], [Number(withTuple[2]), Number(withTuple[3])]);
      continue;
    }
    const withKey = RE_SEGMENT_WITH_KEY.exec(segment);
    if (withKey) {
      path.push(withKey[1], { _key: withKey[2] });
      continue;
    }
    path.push(segment);
  }
  return path;
}
const lengthyStr = pipe(string(), minLength(1)), optionalLengthyStr = optional(lengthyStr);
object({
  baseUrl: lengthyStr,
  dataset: optionalLengthyStr,
  id: lengthyStr,
  path: lengthyStr,
  projectId: optionalLengthyStr,
  tool: optionalLengthyStr,
  type: optionalLengthyStr,
  workspace: optionalLengthyStr,
  isDraft: optional(string())
});
object({
  origin: lengthyStr,
  href: lengthyStr,
  data: optional(record(string(), unknown()))
});
const channelsToComlinkMap = {
  "handshake/syn": MSG_HANDSHAKE_SYN,
  "handshake/syn-ack": MSG_HANDSHAKE_SYN_ACK,
  "handshake/ack": MSG_HANDSHAKE_ACK,
  "channel/response": MSG_RESPONSE,
  "channel/heartbeat": MSG_HEARTBEAT,
  "channel/disconnect": MSG_DISCONNECT,
  "overlay/focus": "visual-editing/focus",
  "overlay/navigate": "visual-editing/navigate",
  "overlay/toggle": "visual-editing/toggle",
  "presentation/toggleOverlay": "presentation/toggle-overlay"
}, comlinkToChannelsMap = {
  [MSG_HANDSHAKE_SYN]: "handshake/syn",
  [MSG_HANDSHAKE_SYN_ACK]: "handshake/syn-ack",
  [MSG_HANDSHAKE_ACK]: "handshake/ack",
  [MSG_RESPONSE]: "channel/response",
  [MSG_HEARTBEAT]: "channel/heartbeat",
  [MSG_DISCONNECT]: "channel/disconnect",
  "visual-editing/focus": "overlay/focus",
  "visual-editing/navigate": "overlay/navigate",
  "visual-editing/toggle": "overlay/toggle",
  "presentation/toggle-overlay": "presentation/toggleOverlay"
}, convertToComlinkEvent = (event) => {
  const { data } = event;
  return data && typeof data == "object" && "domain" in data && "type" in data && "from" in data && "to" in data && (data.domain === "sanity/channels" && (data.domain = DOMAIN), data.to === "overlays" && (data.to = "visual-editing"), data.from === "overlays" && (data.from = "visual-editing"), data.type = channelsToComlinkMap[data.type] ?? data.type), event;
}, convertToChannelsMessage = (message) => (message.domain === DOMAIN && (message.domain = "sanity/channels"), message.to === "visual-editing" && (message.to = "overlays"), message.from === "visual-editing" && (message.from = "overlays"), message.type = comlinkToChannelsMap[message.type] ?? message.type, message.type === "channel/response" && message.responseTo && !message.data && (message.data = { responseTo: message.responseTo }), message), sendAsChannelsMessage = ({ context }, params) => {
  const { sources, targetOrigin } = context, message = convertToChannelsMessage(params.message);
  sources.forEach((source) => {
    source.postMessage(message, { targetOrigin });
  });
}, createCompatibilityActors = () => ({
  listen: createListenLogic(convertToComlinkEvent),
  requestMachine: createRequestMachine().provide({
    actions: {
      "send message": sendAsChannelsMessage
    }
  })
});
function getQueryCacheKey(query, params) {
  return `${query}-${typeof params == "string" ? params : JSON.stringify(params)}`;
}
const IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), MODIFIERS = {
  alt: "altKey",
  ctrl: "ctrlKey",
  mod: IS_MAC ? "metaKey" : "ctrlKey",
  shift: "shiftKey"
};
function isHotkey(keys, event) {
  return keys.every((key) => MODIFIERS[key] ? event[MODIFIERS[key]] : event.key === key.toUpperCase());
}
function isAltKey(event) {
  return event.key === "Alt";
}
function debounce(fn, timeout) {
  let timer;
  return (...args) => {
    clearTimeout(timer), timer = setTimeout(() => {
      fn.apply(fn, args);
    }, timeout);
  };
}
const PanelsContext = createContext(null);
PanelsContext.displayName = "PanelsContext";
const Root$1 = styled.div`
  overflow: hidden;
  flex-basis: 0;
  flex-shrink: 1;
`, Panel = function({
  children,
  defaultSize = null,
  id,
  minWidth,
  maxWidth,
  order = 0
}) {
  const context = useContext(PanelsContext);
  if (context === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const { getPanelStyle, registerElement, unregisterElement } = context, style = getPanelStyle(id);
  return useLayoutEffect(() => (registerElement(id, {
    id,
    type: "panel",
    defaultSize,
    maxWidth: maxWidth ?? null,
    minWidth: minWidth ?? 0,
    order
  }), () => {
    unregisterElement(id);
  }), [id, defaultSize, order, maxWidth, minWidth, registerElement, unregisterElement]), /* @__PURE__ */ jsx(Root$1, { style, children });
}, itemKey = "presentation/panels", getStoredItem = () => JSON.parse(localStorage.getItem(itemKey) || "{}"), setStoredItem = (data) => {
  localStorage.setItem(itemKey, JSON.stringify(data));
}, getKeyForPanels = (panels) => panels.map((panel) => [panel.id, panel.order].join(":")).join(",");
function usePanelsStorage() {
  return useMemo(() => {
    const get = (panels) => {
      const stored = getStoredItem(), key = getKeyForPanels(panels);
      return Array.isArray(stored[key]) && stored[key].some((val) => val === null) ? void 0 : stored[key];
    }, set = (panels, widths) => {
      const stored = getStoredItem(), key = getKeyForPanels(panels), data = {
        ...stored,
        [key]: widths
      };
      setStoredItem(data);
    }, setDebounced = debounce(set, 100);
    return {
      get,
      set,
      setDebounced
    };
  }, []);
}
function getNextWidth(panel, nextWidth, containerWidth) {
  const { maxWidth: maxWidthPx, minWidth: minWidthPx } = panel, maxWidth = maxWidthPx == null ? 100 : maxWidthPx / containerWidth * 100, minWidth = minWidthPx / containerWidth * 100;
  return Math.min(maxWidth, Math.max(minWidth, nextWidth));
}
function getNextWidths(delta, containerWidth, panelBefore, panelAfter, panelsState, initialDragState) {
  const { panels, widths: prevWidths } = panelsState, { widths: initialWidths } = initialDragState, widths = initialWidths || prevWidths, nextWidths = [...widths];
  {
    const pivotPanel2 = delta < 0 ? panelAfter : panelBefore, index2 = panels.findIndex((panel) => panel.id === pivotPanel2.id), width = widths[index2], nextWidth = getNextWidth(pivotPanel2, width + Math.abs(delta), containerWidth);
    if (width === nextWidth)
      return widths;
    delta = delta < 0 ? width - nextWidth : nextWidth - width;
  }
  let deltaApplied = 0, pivotPanel = delta < 0 ? panelBefore : panelAfter, index = panels.findIndex((panel) => panel.id === pivotPanel.id);
  for (; ; ) {
    const panel = panels[index], width = widths[index], deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied), nextWidth = getNextWidth(panel, width - deltaRemaining, containerWidth);
    if (width !== nextWidth && (deltaApplied += width - nextWidth, nextWidths[index] = nextWidth, deltaApplied.toPrecision(10).localeCompare(Math.abs(delta).toPrecision(10), void 0, {
      numeric: !0
    }) >= 0))
      break;
    if (delta < 0) {
      if (--index < 0)
        break;
    } else if (++index >= panels.length)
      break;
  }
  return deltaApplied === 0 ? widths : (pivotPanel = delta < 0 ? panelAfter : panelBefore, index = panels.findIndex((panel) => panel.id === pivotPanel.id), nextWidths[index] = widths[index] + deltaApplied, nextWidths);
}
function getPanelWidth(panels, id, widths) {
  if (panels.length === 1) return "100";
  const index = panels.findIndex((panel) => panel.id === id), width = widths[index];
  return width == null ? "0" : width.toPrecision(10);
}
function getOffset(event, handleElement, initialOffset = 0, initialHandleElementRect = null) {
  const pointerOffset = event.clientX, elementOffset = (initialHandleElementRect || handleElement.getBoundingClientRect()).left;
  return pointerOffset - elementOffset - initialOffset;
}
function isPanel(element) {
  return element.type === "panel";
}
function isResizer(element) {
  return element.type === "resizer";
}
function getSortedElements(elements) {
  return Array.from(elements.values()).sort(({ order: a }, { order: b }) => a == null && b == null ? 0 : a == null ? -1 : b == null ? 1 : a - b);
}
function validateWidths(panels, widthsToValidate, containerWidth) {
  const total = widthsToValidate.reduce((total2, width) => total2 + width, 0), widths = [...widthsToValidate].map((width) => width / total * 100);
  let remainingWidth = 0;
  for (let index = 0; index < panels.length; index++) {
    const panel = panels[index], width = widths[index], nextWidth = getNextWidth(panel, width, containerWidth);
    width != nextWidth && (remainingWidth += width - nextWidth, widths[index] = nextWidth);
  }
  if (remainingWidth.toFixed(3) !== "0.000")
    for (let index = 0; index < panels.length; index++) {
      const panel = panels[index];
      let { maxWidth, minWidth } = panel;
      minWidth = minWidth / containerWidth * 100, maxWidth != null && (maxWidth = maxWidth / containerWidth * 100);
      const width = Math.min(
        maxWidth ?? 100,
        Math.max(minWidth, widths[index] + remainingWidth)
      );
      if (width !== widths[index] && (remainingWidth -= width - widths[index], widths[index] = width, Math.abs(remainingWidth).toFixed(3) === "0.000"))
        break;
    }
  return widths;
}
function getDefaultWidths(panels) {
  let panelsWithoutWidth = panels.length, remainingWidthTotal = 100;
  const widthsWithNulls = panels.map((panel) => panel.defaultSize ? (remainingWidthTotal = remainingWidthTotal - panel.defaultSize, panelsWithoutWidth = panelsWithoutWidth - 1, panel.defaultSize) : null), defaultWidth = remainingWidthTotal / panelsWithoutWidth;
  return widthsWithNulls.map((width) => width === null ? defaultWidth : width);
}
const PanelsWrapper = styled.div`
  display: flex;
  flex-direction: row;
  height: 100%;
  overflow: hidden;
  width: 100%;
`, Panels = function({ children }) {
  const panelsEl = useRef(null), [elements, setElements] = useState(/* @__PURE__ */ new Map()), panels = useMemo(() => getSortedElements(elements).filter(isPanel), [elements]), [widths, setWidths] = useState([]), [activeResizer, setActiveResizer] = useState(null), panelsRef = useRef({
    elements,
    panels,
    widths
  }), getPanelStyle = useCallback(
    (id) => ({
      flexGrow: getPanelWidth(panels, id, widths),
      pointerEvents: activeResizer === null ? void 0 : "none"
    }),
    [activeResizer, panels, widths]
  ), registerElement = useCallback((id, data) => {
    setElements((prev) => {
      if (prev.has(id)) return prev;
      const next = new Map(prev);
      return next.set(id, data), next;
    });
  }, []), unregisterElement = useCallback((id) => {
    setElements((prev) => {
      if (!prev.has(id)) return prev;
      const next = new Map(prev);
      return next.delete(id), next;
    });
  }, []), dragRef = useRef({
    containerWidth: window.innerWidth,
    dragOffset: 0,
    panelAfter: null,
    panelBefore: null,
    resizerIndex: -1,
    resizerRect: null,
    startX: 0,
    widths: []
  }), startDragging = useCallback(
    (id, event) => {
      const elementsArr = getSortedElements(elements), index = elementsArr.findIndex((el) => el.id === id), resizer = elements.get(id);
      if (!resizer || !isResizer(resizer)) return;
      const resizeElement = resizer.el.current;
      resizeElement && (dragRef.current = {
        resizerIndex: index,
        panelBefore: elementsArr.reduce(
          (acc, el, i) => isPanel(el) && i < index ? el : acc,
          null
        ),
        panelAfter: elementsArr.reduce(
          (acc, el, i) => acc === null && isPanel(el) && i > index ? el : acc,
          null
        ),
        containerWidth: window.innerWidth,
        startX: event.pageX,
        dragOffset: getOffset(event, resizeElement),
        resizerRect: resizeElement.getBoundingClientRect(),
        widths: panelsRef.current.widths
      }, setActiveResizer(id));
    },
    [elements]
  ), stopDragging = useCallback(() => {
    setActiveResizer(null);
  }, []), drag = useCallback(
    (id, event) => {
      event.preventDefault(), event.stopPropagation();
      const { containerWidth, dragOffset, panelBefore, panelAfter, resizerRect } = dragRef.current;
      if (panelBefore == null || panelAfter == null)
        return;
      const resizer = elements.get(id);
      if (!resizer || !isResizer(resizer)) return;
      const resizeElement = resizer.el.current;
      if (!resizeElement) return;
      const offset = getOffset(event, resizeElement, dragOffset, resizerRect);
      if (offset === 0)
        return;
      const { widths: prevWidths } = panelsRef.current, rect = panelsEl.current.getBoundingClientRect(), delta = offset / rect.width * 100, nextWidths = getNextWidths(
        delta,
        containerWidth,
        panelBefore,
        panelAfter,
        panelsRef.current,
        dragRef.current
      );
      prevWidths.some((prevWidth, i) => prevWidth !== nextWidths[i]) && setWidths(nextWidths);
    },
    [elements]
  );
  useLayoutEffect(() => {
    panelsRef.current.elements = elements, panelsRef.current.panels = panels, panelsRef.current.widths = widths;
  }, [elements, panels, widths]);
  const storage = usePanelsStorage();
  useLayoutEffect(() => {
    const { widths: widths2 } = panelsRef.current;
    if (widths2.length === panels.length)
      return;
    const storedWidths = storage.get(panels);
    if (storedWidths) {
      const validatedStoredWidths = validateWidths(panels, storedWidths, window.innerWidth);
      setWidths(validatedStoredWidths);
      return;
    }
    const defaultWidths = getDefaultWidths(panels);
    setWidths(defaultWidths);
  }, [storage, panels]), useEffect(() => {
    widths.length && storage.setDebounced(panels, widths);
  }, [storage, panels, widths]), useLayoutEffect(() => {
    const resizeObserver = new ResizeObserver(() => {
      const { panels: panels2, widths: prevWidths } = panelsRef.current, nextWidths = validateWidths(panels2, prevWidths, window.innerWidth);
      prevWidths.some((prevWidth, i) => prevWidth !== nextWidths[i]) && setWidths(nextWidths);
    });
    return resizeObserver.observe(panelsEl.current), () => {
      resizeObserver.disconnect();
    };
  }, []);
  const context = useMemo(
    () => ({
      activeResizer,
      drag,
      getPanelStyle,
      registerElement,
      startDragging,
      stopDragging,
      unregisterElement
    }),
    [
      activeResizer,
      drag,
      getPanelStyle,
      registerElement,
      startDragging,
      stopDragging,
      unregisterElement
    ]
  );
  return /* @__PURE__ */ jsx(PanelsContext.Provider, { value: context, children: /* @__PURE__ */ jsx(PanelsWrapper, { ref: panelsEl, children }) });
};
function ErrorCard(props) {
  const { children, message, onRetry, onContinueAnyway, ...restProps } = props, { t } = useTranslation(presentationLocaleNamespace), retryButton = /* @__PURE__ */ jsx(Button, { fontSize: 1, mode: "ghost", onClick: onRetry, text: t("error-card.retry-button.text") }), continueAnywayButton = /* @__PURE__ */ jsx(
    Button,
    {
      fontSize: 1,
      mode: "ghost",
      tone: "critical",
      onClick: onContinueAnyway,
      text: t("error-card.continue-button.text")
    }
  );
  return /* @__PURE__ */ jsx(Card, { height: "fill", ...restProps, children: /* @__PURE__ */ jsx(Flex, { align: "center", height: "fill", justify: "center", children: /* @__PURE__ */ jsx(Container$1, { padding: 4, sizing: "border", width: 0, children: /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
    /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
      /* @__PURE__ */ jsx(Text, { size: 1, weight: "semibold", children: t("error-card.title") }),
      /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: message })
    ] }),
    children,
    onRetry && onContinueAnyway ? /* @__PURE__ */ jsxs(Inline, { space: 2, children: [
      retryButton,
      continueAnywayButton
    ] }) : onRetry ? /* @__PURE__ */ jsx(Box, { children: retryButton }) : onContinueAnyway ? /* @__PURE__ */ jsx(Box, { children: continueAnywayButton }) : null
  ] }) }) }) });
}
function encodeQueryString(params = {}) {
  const parts = Object.entries(params).map(([key, value]) => `${key}=${value}`).join("&");
  return parts.length ? `?${parts}` : "";
}
function resolveQueryStringFromParams(nextParams) {
  const allowed = [
    "comment",
    "inspect",
    "instruction",
    "pathKey",
    "rev",
    "since",
    "template",
    "view"
  ], safeNextParams = Object.entries(nextParams).filter(([key]) => allowed.includes(key)).reduce((obj, [key, value]) => value == null ? obj : { ...obj, [key]: value }, {});
  return encodeQueryString(safeNextParams);
}
const BackLink = forwardRef(function(props, ref) {
  const { searchParams, ...restProps } = props;
  return /* @__PURE__ */ jsx(
    StateLink,
    {
      ...restProps,
      ref,
      state: {
        type: void 0,
        _searchParams: Object.entries(searchParams)
      },
      title: void 0
    }
  );
}), ReferenceChildLink = forwardRef(function(props, ref) {
  const {
    documentId,
    documentType,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    parentRefPath,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    template,
    searchParams,
    ...restProps
  } = props;
  return /* @__PURE__ */ jsx(
    StateLink,
    {
      ...restProps,
      ref,
      state: {
        id: documentId,
        type: documentType,
        _searchParams: Object.entries(searchParams)
      },
      title: void 0
    }
  );
});
function PresentationPaneRouterProvider(props) {
  const { children, onStructureParams, structureParams, searchParams, refs } = props, { state: routerState, resolvePathFromState } = useRouter(), routerSearchParams = useUnique(Object.fromEntries(routerState._searchParams || [])), createPathWithParams = useCallback(
    (nextParams) => {
      const path = resolvePathFromState(routerState), qs = resolveQueryStringFromParams({
        ...routerSearchParams,
        ...nextParams
      });
      return `${path}${qs}`;
    },
    [resolvePathFromState, routerSearchParams, routerState]
  ), context = useMemo(() => ({
    index: 0,
    groupIndex: 0,
    siblingIndex: 0,
    payload: {},
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    params: structureParams,
    hasGroupSiblings: !1,
    groupLength: 1,
    routerPanesState: [],
    ChildLink: (childLinkProps) => {
      const { childId, ...restProps } = childLinkProps, ref = refs?.find((r) => r._id === childId || getPublishedId(r._id) === childId);
      return ref ? /* @__PURE__ */ jsx(
        StateLink,
        {
          ...restProps,
          state: {
            id: childId,
            type: ref._type,
            _searchParams: Object.entries(searchParams)
          }
        }
      ) : /* @__PURE__ */ jsx("div", { ...restProps });
    },
    BackLink: (backLinkProps) => /* @__PURE__ */ jsx(BackLink, { ...backLinkProps, searchParams }),
    ReferenceChildLink: (childLinkProps) => /* @__PURE__ */ jsx(ReferenceChildLink, { ...childLinkProps, searchParams }),
    ParameterizedLink: () => /* @__PURE__ */ jsx(Fragment, { children: "ParameterizedLink" }),
    closeCurrentAndAfter: () => {
      console.warn("closeCurrentAndAfter");
    },
    handleEditReference: (options) => {
      console.warn("handleEditReference", options);
    },
    replaceCurrent: (pane) => {
      console.warn("replaceCurrent", pane);
    },
    closeCurrent: () => {
      console.warn("closeCurrent");
    },
    duplicateCurrent: (pane) => {
      console.warn("duplicateCurrent", pane);
    },
    setView: (viewId) => {
      console.warn("setView", viewId);
    },
    setParams: (nextParams) => {
      onStructureParams({
        ...nextParams,
        inspect: nextParams.inspect ?? void 0
      });
    },
    setPayload: (payload) => {
      console.warn("setPayload", payload);
    },
    navigateIntent: (intentName, intentParams, options) => {
      console.warn("navigateIntent", intentName, intentParams, options);
    },
    createPathWithParams
  }), [createPathWithParams, onStructureParams, refs, searchParams, structureParams]);
  return /* @__PURE__ */ jsx(PaneRouterContext.Provider, { value: context, children });
}
const RootLayout = styled(PaneLayout)`
  height: 100%;
`, Root = styled(Flex)`
  & > div {
    min-width: none !important;
    max-width: none !important;
  }
`, WrappedCode$1 = styled(Code)`
  white-space: pre-wrap;
`;
function DocumentListPane(props) {
  const { mainDocumentState, onStructureParams, searchParams, refs } = props, { t } = useTranslation(presentationLocaleNamespace), { devMode } = usePresentationTool(), ids = useMemo(
    () => refs.filter((r) => getPublishedId(r._id) !== mainDocumentState?.document?._id).map((r) => r._id),
    [mainDocumentState, refs]
  ), pane = useMemo(
    () => ({
      id: "$root",
      options: {
        filter: "_id in $ids",
        params: { ids }
        // defaultOrdering: [{field: '_updatedAt', direction: 'desc'}],
      },
      schemaTypeName: "",
      title: t("document-list-pane.document-list.title"),
      type: "documentList"
    }),
    [ids, t]
  ), [errorParams, setErrorParams] = useState(null), handleRetry = useCallback(() => setErrorParams(null), []), [structureParams] = useState(() => ({}));
  return useEffect(() => setErrorParams(null), [refs]), errorParams ? /* @__PURE__ */ jsx(ErrorCard, { flex: 1, message: t("document-list-pane.error.text"), onRetry: handleRetry, children: devMode && // show runtime error message in dev mode
  /* @__PURE__ */ jsx(Card, { overflow: "auto", padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
    /* @__PURE__ */ jsx(Label, { muted: !0, size: 0, children: t("presentation-error.label") }),
    /* @__PURE__ */ jsx(WrappedCode$1, { size: 1, children: errorParams.error.message })
  ] }) }) }) : /* @__PURE__ */ jsx(ErrorBoundary, { onCatch: setErrorParams, children: /* @__PURE__ */ jsx(RootLayout, { children: /* @__PURE__ */ jsx(StructureToolProvider, { children: /* @__PURE__ */ jsx(
    PresentationPaneRouterProvider,
    {
      onStructureParams,
      structureParams,
      searchParams,
      refs,
      children: /* @__PURE__ */ jsx(Root, { direction: "column", flex: 1, children: /* @__PURE__ */ jsx(DocumentListPane$1, { index: 0, itemId: "$root", pane, paneKey: "$root" }) })
    }
  ) }) }) });
}
const WrappedCode = styled(Code)`
  white-space: pre-wrap;
`;
function DocumentPane(props) {
  const { documentId, documentType, onFocusPath, onStructureParams, searchParams, structureParams } = props, { template, templateParams } = structureParams, { t } = useTranslation(presentationLocaleNamespace), { devMode } = usePresentationTool(), paneDocumentNode = useMemo(
    () => ({
      id: documentId,
      options: {
        id: documentId,
        type: documentType,
        template,
        templateParameters: decodeJsonParams(templateParams)
      },
      title: "",
      type: "document"
    }),
    [documentId, documentType, template, templateParams]
  ), [errorParams, setErrorParams] = useState(null), handleRetry = useCallback(() => setErrorParams(null), []);
  return useEffect(() => {
    setErrorParams(null);
  }, [documentId, documentType, structureParams]), errorParams ? /* @__PURE__ */ jsx(ErrorCard, { flex: 1, message: t("document-pane.error.text"), onRetry: handleRetry, children: devMode && // show runtime error message in dev mode
  /* @__PURE__ */ jsx(Card, { overflow: "auto", padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
    /* @__PURE__ */ jsx(Label, { muted: !0, size: 0, children: t("presentation-error.label") }),
    /* @__PURE__ */ jsx(WrappedCode, { size: 1, children: errorParams.error.message })
  ] }) }) }) : /* @__PURE__ */ jsx(ErrorBoundary, { onCatch: setErrorParams, children: /* @__PURE__ */ jsx(PaneLayout, { style: { height: "100%" }, children: /* @__PURE__ */ jsx(
    PresentationPaneRouterProvider,
    {
      searchParams,
      onStructureParams,
      structureParams,
      children: /* @__PURE__ */ jsx(Suspense, { fallback: /* @__PURE__ */ jsx(PresentationSpinner, {}), children: /* @__PURE__ */ jsx(
        DocumentPane$1,
        {
          paneKey: "document",
          index: 1,
          itemId: "document",
          pane: paneDocumentNode,
          onFocusPath
        }
      ) })
    }
  ) }) });
}
function DocumentPanel(props) {
  const { documentId, documentType, onFocusPath, onStructureParams, searchParams, structureParams } = props;
  return /* @__PURE__ */ jsx(StructureToolProvider, { children: /* @__PURE__ */ jsx(
    DocumentPane,
    {
      documentId,
      documentType,
      onFocusPath,
      onStructureParams,
      searchParams,
      structureParams
    }
  ) });
}
function usePreviewState(documentId, schemaType2) {
  const documentPreviewStore = useDocumentPreviewStore(), [preview, setPreview] = useState({});
  return useEffect(() => {
    if (!schemaType2)
      return;
    const subscription = getPreviewStateObservable(
      documentPreviewStore,
      schemaType2,
      documentId,
      ""
    ).subscribe((state) => {
      setPreview(state);
    });
    return () => {
      subscription?.unsubscribe();
    };
  }, [documentPreviewStore, schemaType2, documentId]), preview;
}
function ContentEditor(props) {
  const {
    documentId,
    documentType,
    mainDocumentState,
    onFocusPath,
    onStructureParams,
    refs,
    searchParams,
    structureParams
  } = props, { t } = useTranslation(presentationLocaleNamespace), schema = useSchema(), MainDocumentLink = useCallback(
    (props2) => /* @__PURE__ */ jsx(
      StateLink,
      {
        ...props2,
        state: {
          id: mainDocumentState.document._id,
          type: mainDocumentState.document._type,
          _searchParams: Object.entries(searchParams)
        }
      }
    ),
    [mainDocumentState, searchParams]
  ), schemaType2 = useMemo(
    () => schema.get(mainDocumentState?.document?._type || "shoe"),
    [mainDocumentState, schema]
  ), previewState = usePreviewState(mainDocumentState?.document?._id || "", schemaType2), preview = useMemo(() => mainDocumentState?.document ? /* @__PURE__ */ jsx(
    SanityDefaultPreview,
    {
      ...getPreviewValueWithFallback({
        value: mainDocumentState.document,
        published: previewState.published,
        draft: previewState.draft
      }),
      schemaType: schemaType2,
      status: /* @__PURE__ */ jsx(Card, { padding: 1, radius: 2, shadow: 1, children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 0, weight: "medium", children: t("main-document.label") }) })
    }
  ) : null, [mainDocumentState, schemaType2, t, previewState]);
  return documentId && documentType ? /* @__PURE__ */ jsx(
    DocumentPanel,
    {
      documentId,
      documentType,
      onFocusPath,
      onStructureParams,
      searchParams,
      structureParams
    }
  ) : /* @__PURE__ */ jsxs(Flex, { direction: "column", flex: 1, height: "fill", children: [
    mainDocumentState && /* @__PURE__ */ jsx(Card, { padding: 3, tone: mainDocumentState.document ? "inherit" : "caution", children: mainDocumentState.document ? /* @__PURE__ */ jsx(
      PreviewCard,
      {
        __unstable_focusRing: !0,
        as: MainDocumentLink,
        "data-as": "a",
        radius: 2,
        sizing: "border",
        tone: "inherit",
        children: preview
      }
    ) : /* @__PURE__ */ jsx(Card, { padding: 2, radius: 2, tone: "inherit", children: /* @__PURE__ */ jsxs(Flex, { gap: 3, children: [
      /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(WarningOutlineIcon, {}) }) }),
      /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(Text, { size: 1, children: /* @__PURE__ */ jsx(
        Translate,
        {
          t,
          i18nKey: "main-document.missing.text",
          components: { Code: "code" },
          values: { path: mainDocumentState.path }
        }
      ) }) })
    ] }) }) }),
    /* @__PURE__ */ jsx(
      DocumentListPane,
      {
        mainDocumentState,
        onStructureParams,
        searchParams,
        refs
      }
    )
  ] });
}
var byteToHex = [];
for (var i = 0; i < 256; ++i)
  byteToHex.push((i + 256).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
var randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options)
    return native.randomUUID();
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  return rnds[6] = rnds[6] & 15 | 64, rnds[8] = rnds[8] & 63 | 128, unsafeStringify(rnds);
}
function usePanelId(id) {
  return useRef(id || v4()).current;
}
const Resizer = styled.div`
  position: relative;
`, ResizerInner = styled.div`
  position: absolute;
  top: 0;
  bottom: 0;
  left: -5px;
  width: 9px;
  z-index: 10;
  cursor: ${({ $disabled }) => $disabled ? "auto" : "ew-resize"};

  /* Border */
  & > span:nth-child(1) {
    display: block;
    border-left: 1px solid var(--card-border-color);
    position: absolute;
    top: 0;
    left: 4px;
    bottom: 0;
    transition: opacity 200ms;
  }

  ${({ $disabled }) => !$disabled && `
    /* Hover effect */
    & > span:nth-child(2) {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 9px;
      bottom: 0;
      background-color: var(--card-border-color);
      opacity: 0;
      transition: opacity 150ms;
    }

    @media (hover: hover) {
      &:hover > span:nth-child(2) {
        opacity: 0.2;
      }
    }
  `}
`, PanelResizer = function({ id: propId, order, disabled = !1 }) {
  const el = useRef(null), context = useContext(PanelsContext);
  if (context === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const id = usePanelId(propId), { activeResizer, drag, startDragging, stopDragging, registerElement, unregisterElement } = context, isDragging = activeResizer === id;
  if (context === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const onMouseDown = useCallback(
    (event) => {
      startDragging(id, event.nativeEvent);
    },
    [id, startDragging]
  ), onDrag = useCallback(
    (e) => {
      drag(id, e);
    },
    [id, drag]
  ), onDragStop = useCallback(() => {
    el.current.blur(), stopDragging();
  }, [stopDragging]);
  return useEffect(() => {
    if (!isDragging || disabled) return;
    function setDocumentStyles() {
      const bodyStyle = document.body.style, documentStyle = document.documentElement.style, { cursor } = documentStyle, { userSelect } = bodyStyle;
      return documentStyle.cursor = "ew-resize", bodyStyle.userSelect = "none", () => {
        cursor ? documentStyle.cursor = cursor : documentStyle.removeProperty("cursor"), userSelect ? bodyStyle.userSelect = userSelect : bodyStyle.removeProperty("user-select");
      };
    }
    const resetDocumentStyles = setDocumentStyles();
    return window.addEventListener("mousemove", onDrag), window.addEventListener("mouseup", onDragStop), window.addEventListener("contextmenu", onDragStop), () => {
      resetDocumentStyles(), window.removeEventListener("mousemove", onDrag), window.removeEventListener("mouseup", onDragStop), window.removeEventListener("contextmenu", onDragStop);
    };
  }, [disabled, isDragging, onDrag, onDragStop]), useLayoutEffect(() => (registerElement(id, { id, order, type: "resizer", el }), () => {
    unregisterElement(id);
  }), [id, order, registerElement, unregisterElement]), /* @__PURE__ */ jsx(Resizer, { onMouseDown, ref: el, children: /* @__PURE__ */ jsxs(ResizerInner, { $disabled: disabled, children: [
    /* @__PURE__ */ jsx("span", {}),
    /* @__PURE__ */ jsx("span", {})
  ] }) });
}, PresentationContentWrapper = (props) => {
  const { documentId, setDisplayedDocument, getCommentIntent } = props;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(PanelResizer, { order: 4 }),
    /* @__PURE__ */ jsx(Panel, { id: "content", minWidth: 325, order: 5, children: /* @__PURE__ */ jsx(
      DisplayedDocumentBroadcasterProvider,
      {
        documentId,
        setDisplayedDocument,
        children: /* @__PURE__ */ jsx(CommentsIntentProvider, { getIntent: getCommentIntent, children: props.children })
      }
    ) })
  ] });
}, PresentationContent = (props) => {
  const {
    documentId,
    documentsOnPage,
    documentType,
    getCommentIntent,
    mainDocumentState,
    onFocusPath,
    onStructureParams,
    searchParams,
    setDisplayedDocument,
    structureParams
  } = props;
  return /* @__PURE__ */ jsx(
    PresentationContentWrapper,
    {
      documentId,
      getCommentIntent,
      setDisplayedDocument,
      children: /* @__PURE__ */ jsx(
        ContentEditor,
        {
          documentId,
          documentType,
          mainDocumentState,
          onFocusPath,
          onStructureParams,
          refs: documentsOnPage,
          searchParams,
          structureParams
        }
      )
    }
  );
}, PresentationNavigateProvider = function(props) {
  const { children, navigate: _navigate } = props, navigate = useCallback(
    (preview, document2 = void 0) => {
      _navigate(document2 || {}, preview ? { preview } : {});
    },
    [_navigate]
  );
  return /* @__PURE__ */ jsx(PresentationNavigateContext.Provider, { value: navigate, children });
};
function useLocalState(key, defaultValue) {
  const [value, setValue] = useState(
    () => JSON.parse(localStorage.getItem(key) ?? JSON.stringify(defaultValue))
  );
  return useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]), [value, setValue];
}
function usePresentationNavigator(props) {
  const { unstable_navigator } = props, navigatorProvided = !!unstable_navigator?.component, [_navigatorEnabled, setNavigatorEnabled] = useLocalState(
    "presentation/navigator",
    navigatorProvided
  ), navigatorEnabled = navigatorProvided ? _navigatorEnabled : !1, toggleNavigator = useMemo(() => {
    if (navigatorProvided)
      return () => setNavigatorEnabled((enabled) => !enabled);
  }, [navigatorProvided, setNavigatorEnabled]), Component = useCallback(
    function() {
      return /* @__PURE__ */ jsx(Fragment, { children: navigatorEnabled && /* @__PURE__ */ jsx(Navigator, { ...unstable_navigator }) });
    },
    [navigatorEnabled, unstable_navigator]
  );
  return [{ navigatorEnabled, toggleNavigator }, Component];
}
function NavigatorComponent(props) {
  const { minWidth, maxWidth, component: NavigatorComponent2 } = props, navigatorDisabled = minWidth != null && maxWidth != null && minWidth === maxWidth;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Panel, { id: "navigator", minWidth, maxWidth, order: 1, children: /* @__PURE__ */ jsx(NavigatorComponent2, {}) }),
    /* @__PURE__ */ jsx(PanelResizer, { order: 2, disabled: navigatorDisabled })
  ] });
}
const Navigator = memo(NavigatorComponent), PresentationParamsProvider = function(props) {
  const { children, params } = props, context = useMemo(() => params, [params]);
  return /* @__PURE__ */ jsx(PresentationParamsContext.Provider, { value: context, children });
}, PresentationProvider = function(props) {
  const { children, devMode, name, navigate, params, searchParams, structureParams } = props, context = useMemo(
    () => ({
      devMode,
      name,
      navigate,
      params,
      searchParams,
      structureParams
    }),
    [devMode, name, navigate, params, searchParams, structureParams]
  );
  return /* @__PURE__ */ jsx(PresentationContext.Provider, { value: context, children });
}, ACTION_IFRAME_LOADED = "ACTION_IFRAME_LOADED", ACTION_IFRAME_REFRESH = "ACTION_IFRAME_REFRESH", ACTION_IFRAME_RELOAD = "ACTION_IFRAME_RELOAD", ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE = "ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE", presentationReducer = (state, action) => {
  switch (action.type) {
    case ACTION_IFRAME_LOADED:
      return state.iframe.status === "loaded" ? state : {
        ...state,
        iframe: {
          ...state.iframe,
          status: "loaded"
        }
      };
    case ACTION_IFRAME_REFRESH:
      return state.iframe.status === "refreshing" ? state : {
        ...state,
        iframe: {
          ...state.iframe,
          status: "refreshing"
        }
      };
    case ACTION_IFRAME_RELOAD:
      return state.iframe.status === "reloading" ? state : {
        ...state,
        iframe: {
          ...state.iframe,
          status: "reloading"
        }
      };
    case ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE:
      return toggleVisualEditingOverlays(state, action);
    default:
      return state;
  }
}, toggleVisualEditingOverlays = (state, action) => state.visualEditing.overlaysEnabled === action.enabled ? state : {
  ...state,
  visualEditing: {
    ...state.visualEditing,
    overlaysEnabled: action.enabled
  }
}, mainDocumentSchema = fallback(boolean(), !1), iframeStatusSchema = picklist(["loading", "loaded", "refreshing", "reloading"]), initStateSchema = object({
  mainDocument: mainDocumentSchema,
  iframe: object({
    status: iframeStatusSchema
  }),
  visualEditing: object({ overlaysEnabled: boolean() })
}), INITIAL_PRESENTATION_STATE = {
  mainDocument: !1,
  iframe: {
    status: "loading"
  },
  visualEditing: {
    overlaysEnabled: !1
  }
};
function presentationReducerInit(state) {
  return parse(initStateSchema, { ...INITIAL_PRESENTATION_STATE, ...state });
}
const IFrameElement = motion(styled.iframe`
  box-shadow: 0 0 0 1px var(--card-border-color);
  border-top: 1px solid transparent;
  border-bottom: 0;
  border-right: 0;
  border-left: 0;
  max-height: 100%;
  width: 100%;
`), IFrameOverlay = styled(Box)`
  position: absolute;
  inset: 0;
  background: transparent;
`, IFrame = forwardRef(function(props, ref) {
  const { animate, initial, onLoad, preventClick, src, variants } = props;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      IFrameElement,
      {
        animate,
        initial,
        onLoad,
        ref,
        src,
        variants
      }
    ),
    preventClick && /* @__PURE__ */ jsx(IFrameOverlay, {})
  ] });
});
function OpenPreviewButton(props) {
  const { openPopup, previewLocationOrigin, previewLocationRoute } = props, { t } = useTranslation(presentationLocaleNamespace), handleOpenPopup = useCallback(
    (event) => {
      event.preventDefault(), openPopup(event.currentTarget.href);
    },
    [openPopup]
  );
  return /* @__PURE__ */ jsx(
    Tooltip,
    {
      animate: !0,
      content: /* @__PURE__ */ jsx(Text, { size: 1, children: t("share-url.menu-item.open.text") }),
      fallbackPlacements: ["bottom-start"],
      padding: 2,
      placement: "bottom",
      portal: !0,
      children: /* @__PURE__ */ jsx(
        Button,
        {
          as: "a",
          "aria-label": t("share-url.menu-item.open.text"),
          fontSize: 1,
          icon: LaunchIcon,
          mode: "bleed",
          padding: 2,
          href: `${previewLocationOrigin}${previewLocationRoute}`,
          onClick: handleOpenPopup,
          rel: "opener",
          target: "_blank"
        }
      )
    }
  );
}
const PreviewLocationInput = function(props) {
  const { fontSize = 1, onChange, origin, padding = 3, prefix, suffix, value } = props, { t } = useTranslation(presentationLocaleNamespace), { basePath = "/" } = useActiveWorkspace()?.activeWorkspace || {}, inputRef = useRef(null), [sessionValue, setSessionValue] = useState(void 0), [customValidity, setCustomValidity] = useState(void 0), handleChange = useCallback((event) => {
    setSessionValue(event.currentTarget.value);
  }, []), handleKeyDown = useCallback(
    (event) => {
      if (event.key === "Enter") {
        if (sessionValue === void 0)
          return;
        const absoluteValue = sessionValue.startsWith("/") || sessionValue === "" ? `${origin}${sessionValue}` : sessionValue;
        if (!absoluteValue.startsWith(origin + "/") && absoluteValue !== origin) {
          setCustomValidity(t("preview-location-input.error", { origin, context: "missing-origin" }));
          return;
        }
        if (!origin && (absoluteValue.startsWith(`${basePath}/`) || absoluteValue === basePath)) {
          setCustomValidity(
            t("preview-location-input.error", { basePath, context: "same-base-path" })
          );
          return;
        }
        const nextValue = absoluteValue === origin ? origin + "/" : absoluteValue;
        setCustomValidity(void 0), setSessionValue(void 0), onChange(nextValue.slice(origin.length)), inputRef.current?.blur();
      }
      event.key === "Escape" && (setCustomValidity(void 0), setSessionValue(void 0));
    },
    [basePath, onChange, origin, sessionValue, t]
  ), handleBlur = useCallback(() => {
    setCustomValidity(void 0), setSessionValue(void 0);
  }, []);
  useEffect(() => {
    setCustomValidity(void 0), setSessionValue(void 0);
  }, [origin, value]);
  const resetButton = useMemo(() => ({ icon: ResetIcon }), []);
  return /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx(
    TextInput,
    {
      clearButton: customValidity ? resetButton : void 0,
      customValidity,
      fontSize,
      onBlur: handleBlur,
      onClear: () => {
        setCustomValidity(void 0), setSessionValue(origin + value);
      },
      onChange: handleChange,
      onKeyDownCapture: handleKeyDown,
      padding,
      prefix,
      style: { zIndex: 1 },
      radius: 2,
      ref: inputRef,
      space: padding,
      suffix,
      value: sessionValue === void 0 ? `${origin}${value}` : sessionValue
    }
  ) });
}, QRCodeSVG = lazy(() => import("./QRCodeSVG.js")), QrCodeLogoSize = 24, QrCodeLogoPadding = 16, QrSize = 224, StyledSanityMonogram = styled(SanityMonogram)`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  height: ${QrCodeLogoSize}px;
  width: ${QrCodeLogoSize}px;
`, MotionSpinner = motion(Spinner), MotionText = motion(Text), MotionMonogram = motion(StyledSanityMonogram), SharePreviewMenu = memo(function(props) {
  const {
    canToggleSharePreviewAccess,
    canUseSharedPreviewAccess,
    initialUrl,
    previewLocationRoute,
    perspective
  } = props, { t } = useTranslation(presentationLocaleNamespace), { push: pushToast } = useToast(), client = useClient({ apiVersion: API_VERSION }), currentUser = useCurrentUser(), [loading, setLoading] = useState(!0), [enabling, setEnabling] = useState(!1), [disabling, setDisabling] = useState(!1), [secret, setSecret] = useState(null), busy = enabling || disabling || loading, url = useMemo(
    () => secret ? setSecretSearchParams(initialUrl, secret, previewLocationRoute, perspective) : null,
    [initialUrl, perspective, previewLocationRoute, secret]
  ), [error, setError] = useState(null);
  if (error)
    throw error;
  const handleUnableToToggle = useCallback(() => {
    pushToast({
      closable: !0,
      status: "warning",
      title: t("share-preview-menu.error_toggle-sharing", { context: "toggle-sharing" })
    });
  }, [pushToast, t]), handleDisableSharing = useCallback(async () => {
    try {
      setDisabling(!0), await disablePreviewAccessSharing(
        client,
        "@sanity/presentation",
        typeof window > "u" ? "" : location.href,
        currentUser?.id
      ), setSecret(null);
    } catch (error2) {
      setError(error2);
    } finally {
      setDisabling(!1);
    }
  }, [client, currentUser?.id]), handleEnableSharing = useCallback(async () => {
    try {
      setEnabling(!0);
      const previewUrlSecret = await enablePreviewAccessSharing(
        client,
        "@sanity/presentation",
        typeof window > "u" ? "" : location.href,
        currentUser?.id
      );
      setSecret(previewUrlSecret.secret);
    } catch (error2) {
      setError(error2);
    } finally {
      setEnabling(!1);
    }
  }, [client, currentUser?.id]), handleCopyUrl = useCallback(() => {
    try {
      if (!url)
        throw new Error("No URL to copy");
      navigator.clipboard.writeText(url.toString()), pushToast({
        closable: !0,
        status: "success",
        title: t("share-url.clipboard.status", { context: "success" })
      });
    } catch (error2) {
      setError(error2);
    }
  }, [pushToast, t, url]);
  return useEffect(() => {
    let controller = new AbortController(), usedTags = [];
    async function fetchShareSecret(lastLiveEventId, signal) {
      const { result, syncTags } = await client.fetch(
        fetchSharedAccessQuery,
        {},
        { filterResponse: !1, lastLiveEventId, tag: "presentation.fetch-shared-access-secret" }
      );
      Array.isArray(syncTags) && (usedTags = syncTags), signal.aborted || setSecret(result);
    }
    const subscription = client.live.events().subscribe({
      next: (event) => {
        event.type === "message" && (controller.abort(), controller = new AbortController(), event.tags.some((tag) => usedTags.includes(tag)) && fetchShareSecret(event.id, controller.signal));
      },
      error: setError
    });
    return fetchShareSecret(null, controller.signal).finally(() => setLoading(!1)), () => {
      subscription.unsubscribe(), controller.abort();
    };
  }, [client]), /* @__PURE__ */ jsx(
    MenuButton,
    {
      button: /* @__PURE__ */ jsx(
        Button,
        {
          "aria-label": t("preview-frame.share-button.aria-label"),
          fontSize: 1,
          icon: ShareIcon,
          mode: "bleed",
          padding: 2
        }
      ),
      id: "share-menu",
      menu: /* @__PURE__ */ jsx(Menu, { style: { maxWidth: 248 }, padding: canUseSharedPreviewAccess ? void 0 : 0, children: canUseSharedPreviewAccess ? /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx("label", { style: { cursor: "pointer" }, children: /* @__PURE__ */ jsxs(
          Grid,
          {
            columns: 2,
            rows: 2,
            gapX: 3,
            gapY: 1,
            style: {
              justifyContent: "center",
              alignItems: "center",
              gridTemplateColumns: "min-content 1fr",
              gridTemplateRows: "min-content"
            },
            paddingTop: 3,
            paddingX: 3,
            children: [
              /* @__PURE__ */ jsx(
                Tooltip,
                {
                  animate: !0,
                  content: /* @__PURE__ */ jsx(Text, { size: 1, children: t("share-preview-menu.toggle-button.tooltip", {
                    context: url ? "disable" : "enable"
                  }) }),
                  fallbackPlacements: ["bottom-start"],
                  padding: 1,
                  placement: "bottom",
                  portal: !0,
                  children: /* @__PURE__ */ jsx(
                    Switch,
                    {
                      checked: enabling || url !== null && !disabling,
                      readOnly: enabling || disabling,
                      indeterminate: loading,
                      onChange: canToggleSharePreviewAccess ? url ? handleDisableSharing : handleEnableSharing : handleUnableToToggle
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t("share-preview-menu.toggle-button.label", { context: "first-line" }) }),
              /* @__PURE__ */ jsx("span", {}),
              /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("share-preview-menu.toggle-button.label", { context: "second-line" }) })
            ]
          }
        ) }),
        /* @__PURE__ */ jsx(Box, { padding: 3, paddingTop: 2, children: /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
          /* @__PURE__ */ jsx(
            Card,
            {
              tone: busy || !url ? "transparent" : void 0,
              style: {
                position: "relative",
                aspectRatio: "1 / 1",
                display: "flex",
                alignItems: "center",
                justifyContent: "center"
              },
              children: /* @__PURE__ */ jsx(AnimatePresence, { children: busy ? /* @__PURE__ */ jsx(
                MotionSpinner,
                {
                  muted: !0,
                  initial: { opacity: 0 },
                  animate: { opacity: 1 },
                  exit: { opacity: 0 }
                }
              ) : url ? /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsxs(Suspense, { fallback: /* @__PURE__ */ jsx(Spinner, {}), children: [
                /* @__PURE__ */ jsx(
                  QRCodeSVG,
                  {
                    title: t("share-preview-menu.qr-code.title", { url: url.toString() }),
                    value: url.toString(),
                    size: QrSize,
                    color: "var(--card-fg-color)",
                    logoSize: QrCodeLogoSize + QrCodeLogoPadding
                  }
                ),
                /* @__PURE__ */ jsx(
                  MotionMonogram,
                  {
                    initial: { opacity: -0.5 },
                    animate: { opacity: 1.5 },
                    exit: { opacity: 0 }
                  }
                )
              ] }) }) : /* @__PURE__ */ jsx(
                MotionText,
                {
                  muted: !0,
                  size: 1,
                  style: { maxWidth: "100px", textWrap: "pretty", textAlign: "center" },
                  initial: { opacity: 0 },
                  animate: { opacity: 1 },
                  exit: { opacity: 0 },
                  children: t("share-preview-menu.qr-code.placeholder")
                }
              ) })
            }
          ),
          /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("share-preview-menu.qr-code.instructions") })
        ] }) }),
        /* @__PURE__ */ jsx(MenuDivider, {}),
        /* @__PURE__ */ jsx(
          MenuItem,
          {
            disabled: !url || disabling,
            icon: CopyIcon,
            onClick: handleCopyUrl,
            fontSize: 1,
            padding: 3,
            text: t("share-preview-menu.copy-url.text")
          }
        )
      ] }) : /* @__PURE__ */ jsx(Card, { padding: 2, tone: "caution", radius: 3, children: /* @__PURE__ */ jsx(Text, { style: { textWrap: "pretty" }, children: t("share-preview-menu.error", { context: "missing-grants" }) }) }) }),
      popover: {
        animate: !0,
        constrainSize: !0,
        placement: "bottom",
        portal: !0
      }
    }
  );
});
SharePreviewMenu.displayName = "Memo(SharePreviewMenu)";
const MotionFlex = motion(Flex), PERSPECTIVE_TITLE_KEY = {
  previewDrafts: "preview-frame.perspective.previewDrafts.title",
  published: "preview-frame.perspective.published.title"
}, PERSPECTIVE_TONES = {
  previewDrafts: "caution",
  published: "positive"
}, PERSPECTIVE_ICONS = {
  previewDrafts: EditIcon,
  published: PublishIcon
}, PreviewFrame = memo(
  forwardRef(
    function(props, forwardedRef) {
      const {
        canSharePreviewAccess,
        canToggleSharePreviewAccess,
        canUseSharedPreviewAccess,
        dispatch,
        iframe,
        initialUrl,
        loadersConnection,
        navigatorEnabled,
        onPathChange,
        onRefresh,
        openPopup,
        overlaysConnection,
        perspective,
        previewUrl,
        setPerspective,
        setViewport,
        targetOrigin,
        toggleNavigator,
        toggleOverlay,
        viewport,
        visualEditing: { overlaysEnabled }
      } = props, { t } = useTranslation(presentationLocaleNamespace), { devMode } = usePresentationTool(), prefersReducedMotion = usePrefersReducedMotion(), ref = useRef(null);
      useImperativeHandle(
        forwardedRef,
        () => ref.current
      );
      const toggleViewportSize = useCallback(
        () => setViewport(viewport === "desktop" ? "mobile" : "desktop"),
        [setViewport, viewport]
      ), loading = iframe.status === "loading" || iframe.status === "reloading", [timedOut, setTimedOut] = useState(!1), refreshing = iframe.status === "refreshing", [somethingIsWrong, setSomethingIsWrong] = useState(!1), iframeIsBusy = loading || refreshing || overlaysConnection === "connecting", previewLocationOrigin = useMemo(() => targetOrigin === location.origin ? "" : targetOrigin, [targetOrigin]), handleRefresh = useCallback(() => {
        onRefresh(() => {
          ref.current && (dispatch({ type: ACTION_IFRAME_RELOAD }), ref.current.src = `${targetOrigin}${previewUrl || "/"}`);
        });
      }, [dispatch, onRefresh, previewUrl, targetOrigin]), handleRetry = useCallback(() => {
        ref.current && (ref.current.src = initialUrl.toString(), dispatch({ type: ACTION_IFRAME_RELOAD }));
      }, [dispatch, initialUrl]), handleContinueAnyway = useCallback(() => {
        setContinueAnyway(!0);
      }, []), [continueAnyway, setContinueAnyway] = useState(!1), [showOverlaysConnectionStatus, setShowOverlaysConnectionState] = useState(!1);
      useEffect(() => {
        if (!(loading || refreshing) && (overlaysConnection === "connecting" || overlaysConnection === "reconnecting")) {
          const timeout = setTimeout(() => {
            setShowOverlaysConnectionState(!0);
          }, 5e3);
          return () => clearTimeout(timeout);
        }
      }, [overlaysConnection, loading, refreshing]), useEffect(() => {
        if (!(loading || refreshing || !showOverlaysConnectionStatus)) {
          if (overlaysConnection === "connected" && (setSomethingIsWrong(!1), setShowOverlaysConnectionState(!1), setTimedOut(!1), setContinueAnyway(!1)), overlaysConnection === "connecting") {
            const timeout = setTimeout(() => {
              setTimedOut(!0), console.error(
                "Unable to connect to visual editing. Make sure you've setup '@sanity/visual-editing' correctly"
              );
            }, MAX_TIME_TO_OVERLAYS_CONNECTION);
            return () => clearTimeout(timeout);
          }
          if (overlaysConnection === "reconnecting") {
            const timeout = setTimeout(() => {
              setTimedOut(!0), setSomethingIsWrong(!0);
            }, MAX_TIME_TO_OVERLAYS_CONNECTION);
            return () => clearTimeout(timeout);
          }
          overlaysConnection === "disconnected" && setSomethingIsWrong(!0);
        }
      }, [loading, overlaysConnection, refreshing, showOverlaysConnectionStatus]);
      const previewLocationRoute = useMemo(() => {
        const previewURL = new URL(previewUrl || "/", targetOrigin), { pathname, search } = withoutSecretSearchParams(previewURL);
        return `${pathname}${search}`;
      }, [previewUrl, targetOrigin]), onIFrameLoad = useCallback(() => {
        dispatch({ type: ACTION_IFRAME_LOADED });
      }, [dispatch]);
      useEffect(() => {
        if (!ref.current)
          return;
        const instance = ref.current;
        function handleBlur() {
          instance === document.activeElement && instance.dispatchEvent(new MouseEvent("mousedown", { bubbles: !0, cancelable: !0 }));
        }
        return window.addEventListener("blur", handleBlur), () => {
          window.removeEventListener("blur", handleBlur);
        };
      }, []);
      const preventIframeInteraction = useMemo(() => (loading || overlaysConnection === "connecting" && iframe.status !== "refreshing") && !continueAnyway, [continueAnyway, iframe.status, loading, overlaysConnection]), iframeAnimations = useMemo(() => [
        preventIframeInteraction ? "background" : "active",
        loading ? "reloading" : "idle",
        viewport,
        showOverlaysConnectionStatus && !continueAnyway ? "timedOut" : ""
      ], [
        continueAnyway,
        loading,
        preventIframeInteraction,
        showOverlaysConnectionStatus,
        viewport
      ]);
      return /* @__PURE__ */ jsx(MotionConfig, { transition: prefersReducedMotion ? { duration: 0 } : void 0, children: /* @__PURE__ */ jsxs(TooltipDelayGroupProvider, { delay: 1e3, children: [
        /* @__PURE__ */ jsx(Card, { flex: "none", padding: 2, shadow: 1, style: { position: "relative" }, children: /* @__PURE__ */ jsxs(Flex, { align: "center", style: { minHeight: 0 }, children: [
          toggleNavigator && /* @__PURE__ */ jsx(Box, { flex: "none", marginRight: 1, padding: 1, children: /* @__PURE__ */ jsx(
            Tooltip,
            {
              animate: !0,
              content: /* @__PURE__ */ jsx(Text, { size: 1, children: t("preview-frame.navigator.toggle-button.tooltip") }),
              fallbackPlacements: ["bottom-start"],
              padding: 2,
              placement: "bottom",
              portal: !0,
              children: /* @__PURE__ */ jsx(
                Button,
                {
                  "aria-label": t("preview-frame.navigator.toggle-button.aria-label"),
                  fontSize: 1,
                  icon: PanelLeftIcon,
                  mode: "bleed",
                  onClick: toggleNavigator,
                  padding: 2,
                  selected: navigatorEnabled
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsx(
            Tooltip,
            {
              animate: !0,
              content: /* @__PURE__ */ jsxs(Flex, { align: "center", style: { whiteSpace: "nowrap" }, children: [
                /* @__PURE__ */ jsx(Box, { padding: 1, children: /* @__PURE__ */ jsx(Text, { size: 1, children: t("preview-frame.overlay.toggle-button.tooltip", {
                  context: overlaysEnabled ? "disable" : "enable"
                }) }) }),
                /* @__PURE__ */ jsx(Box, { paddingY: 1, children: /* @__PURE__ */ jsx(Hotkeys, { keys: ["Alt"], style: { marginTop: -4, marginBottom: -4 } }) })
              ] }),
              fallbackPlacements: ["bottom-start"],
              padding: 1,
              placement: "bottom",
              portal: !0,
              children: /* @__PURE__ */ jsx(
                Card,
                {
                  as: "label",
                  flex: "none",
                  marginRight: 1,
                  padding: 3,
                  style: {
                    lineHeight: 0,
                    borderRadius: 999,
                    userSelect: "none"
                  },
                  tone: overlaysEnabled ? "transparent" : void 0,
                  children: /* @__PURE__ */ jsxs(Flex, { align: "center", gap: 3, children: [
                    /* @__PURE__ */ jsx("div", { style: { margin: -4 }, children: /* @__PURE__ */ jsx(
                      Switch,
                      {
                        checked: overlaysEnabled,
                        onChange: toggleOverlay,
                        disabled: iframe.status === "loading" || overlaysConnection !== "connected"
                      }
                    ) }),
                    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text, { muted: !overlaysEnabled, size: 1, weight: "medium", children: t("preview-frame.overlay.toggle-button.text") }) })
                  ] })
                }
              )
            }
          ),
          /* @__PURE__ */ jsx(Box, { flex: 1, marginX: 1, children: /* @__PURE__ */ jsx(
            PreviewLocationInput,
            {
              prefix: /* @__PURE__ */ jsx(Box, { padding: 1, children: /* @__PURE__ */ jsx(
                Tooltip,
                {
                  animate: !0,
                  content: /* @__PURE__ */ jsx(Text, { size: 1, children: iframe.status === "loaded" ? t("preview-frame.refresh-button.tooltip") : t("preview-frame.status", { context: iframe.status }) }),
                  fallbackPlacements: ["bottom-end"],
                  padding: 2,
                  placement: "bottom",
                  portal: !0,
                  children: /* @__PURE__ */ jsx(
                    Button,
                    {
                      "aria-label": t("preview-frame.refresh-button.aria-label"),
                      fontSize: 1,
                      icon: RefreshIcon,
                      mode: "bleed",
                      loading: iframe.status === "reloading" || iframe.status === "refreshing",
                      onClick: handleRefresh,
                      padding: 2
                    }
                  )
                }
              ) }),
              onChange: onPathChange,
              origin: previewLocationOrigin,
              suffix: /* @__PURE__ */ jsx(Box, { padding: 1, children: /* @__PURE__ */ jsx(
                OpenPreviewButton,
                {
                  openPopup,
                  previewLocationOrigin,
                  previewLocationRoute
                }
              ) }),
              value: previewLocationRoute
            }
          ) }),
          /* @__PURE__ */ jsx(Flex, { align: "center", flex: "none", gap: 1, padding: 1, children: /* @__PURE__ */ jsx(
            MenuButton,
            {
              button: /* @__PURE__ */ jsx(
                Button,
                {
                  fontSize: 1,
                  iconRight: ChevronDownIcon,
                  mode: "bleed",
                  padding: 2,
                  space: 2,
                  text: t(
                    PERSPECTIVE_TITLE_KEY[loadersConnection === "connected" ? perspective : "previewDrafts"]
                  ),
                  loading: loadersConnection === "reconnecting" && iframe.status !== "loaded",
                  disabled: loadersConnection !== "connected"
                }
              ),
              id: "perspective-menu",
              menu: /* @__PURE__ */ jsxs(Menu, { style: { maxWidth: 240 }, children: [
                /* @__PURE__ */ jsx(
                  MenuItem,
                  {
                    fontSize: 1,
                    onClick: () => setPerspective("previewDrafts"),
                    padding: 3,
                    pressed: perspective === "previewDrafts",
                    tone: PERSPECTIVE_TONES.previewDrafts,
                    children: /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 3, children: [
                      /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: createElement(PERSPECTIVE_ICONS.previewDrafts) }) }),
                      /* @__PURE__ */ jsxs(Stack, { flex: 1, space: 2, children: [
                        /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t(PERSPECTIVE_TITLE_KEY.previewDrafts) }),
                        /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("preview-frame.perspective.previewDrafts.text") })
                      ] }),
                      /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(
                        Text,
                        {
                          muted: !0,
                          size: 1,
                          style: {
                            opacity: perspective === "previewDrafts" ? 1 : 0
                          },
                          children: /* @__PURE__ */ jsx(CheckmarkIcon, {})
                        }
                      ) })
                    ] })
                  }
                ),
                /* @__PURE__ */ jsx(
                  MenuItem,
                  {
                    fontSize: 1,
                    onClick: () => setPerspective("published"),
                    padding: 3,
                    pressed: perspective === "published",
                    tone: PERSPECTIVE_TONES.published,
                    children: /* @__PURE__ */ jsxs(Flex, { align: "flex-start", gap: 3, children: [
                      /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(Text, { size: 1, children: createElement(PERSPECTIVE_ICONS.published) }) }),
                      /* @__PURE__ */ jsxs(Stack, { flex: 1, space: 2, children: [
                        /* @__PURE__ */ jsx(Text, { size: 1, weight: "medium", children: t(PERSPECTIVE_TITLE_KEY.published) }),
                        /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("preview-frame.perspective.published.text") })
                      ] }),
                      /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(
                        Text,
                        {
                          muted: !0,
                          size: 1,
                          style: {
                            opacity: perspective === "published" ? 1 : 0
                          },
                          children: /* @__PURE__ */ jsx(CheckmarkIcon, {})
                        }
                      ) })
                    ] })
                  }
                )
              ] }),
              popover: {
                animate: !0,
                constrainSize: !0,
                placement: "bottom",
                portal: !0
              }
            }
          ) }),
          /* @__PURE__ */ jsx(Flex, { align: "center", flex: "none", gap: 1, children: /* @__PURE__ */ jsx(
            Tooltip,
            {
              animate: !0,
              content: /* @__PURE__ */ jsx(Text, { size: 1, children: t("preview-frame.viewport-button.tooltip", {
                context: viewport === "desktop" ? "narrow" : "full"
              }) }),
              fallbackPlacements: ["bottom-start"],
              padding: 2,
              placement: "bottom",
              portal: !0,
              children: /* @__PURE__ */ jsx(
                Button,
                {
                  "aria-label": t("preview-frame.viewport-button.aria-label"),
                  fontSize: 1,
                  icon: viewport === "desktop" ? MobileDeviceIcon : DesktopIcon,
                  mode: "bleed",
                  onClick: toggleViewportSize,
                  padding: 2
                }
              )
            }
          ) }),
          canSharePreviewAccess && /* @__PURE__ */ jsx(Flex, { align: "center", flex: "none", gap: 1, paddingX: 1, children: /* @__PURE__ */ jsx(
            SharePreviewMenu,
            {
              canToggleSharePreviewAccess,
              canUseSharedPreviewAccess,
              previewLocationRoute,
              initialUrl,
              perspective
            }
          ) })
        ] }) }),
        /* @__PURE__ */ jsx(Card, { flex: 1, tone: "transparent", children: /* @__PURE__ */ jsxs(
          Flex,
          {
            align: "center",
            height: "fill",
            justify: "center",
            padding: viewport === "desktop" ? 0 : 2,
            sizing: "border",
            style: {
              position: "relative",
              cursor: iframeIsBusy ? "wait" : void 0
            },
            children: [
              /* @__PURE__ */ jsx(AnimatePresence, { children: !somethingIsWrong && !loading && !refreshing && showOverlaysConnectionStatus && !continueAnyway ? /* @__PURE__ */ jsx(
                MotionFlex,
                {
                  initial: "initial",
                  animate: "animate",
                  exit: "exit",
                  variants: spinnerVariants,
                  justify: "center",
                  align: "center",
                  style: {
                    inset: "0",
                    position: "absolute",
                    backdropFilter: timedOut ? "blur(16px) saturate(0.5) grayscale(0.5)" : "blur(2px)",
                    transition: "backdrop-filter 0.2s ease-in-out",
                    // @TODO Because of Safari we have to do this
                    WebkitBackdropFilter: timedOut ? "blur(16px) saturate(0.5) grayscale(0.5)" : "blur(2px)",
                    WebkitTransition: "-webkit-backdrop-filter 0.2s ease-in-out",
                    zIndex: 1
                  },
                  children: /* @__PURE__ */ jsxs(
                    Flex,
                    {
                      style: { ...sizes[viewport] },
                      justify: "center",
                      align: "center",
                      direction: "column",
                      gap: 4,
                      children: [
                        timedOut && /* @__PURE__ */ jsx(
                          Button,
                          {
                            disabled: !0,
                            fontSize: 1,
                            mode: "ghost",
                            text: t("preview-frame.continue-button.text"),
                            style: { opacity: 0 }
                          }
                        ),
                        /* @__PURE__ */ jsx(
                          Card,
                          {
                            radius: 2,
                            tone: timedOut ? "caution" : "inherit",
                            padding: 4,
                            shadow: 1,
                            children: /* @__PURE__ */ jsxs(Flex, { justify: "center", align: "center", direction: "column", gap: 4, children: [
                              /* @__PURE__ */ jsx(Spinner, { muted: !0 }),
                              /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: timedOut ? t("preview-frame.status", { context: "timeout" }) : t("preview-frame.status", { context: "connecting" }) })
                            ] })
                          }
                        ),
                        timedOut && /* @__PURE__ */ jsx(
                          Button,
                          {
                            fontSize: 1,
                            tone: "critical",
                            onClick: handleContinueAnyway,
                            text: t("preview-frame.continue-button.text")
                          }
                        )
                      ]
                    }
                  )
                }
              ) : (loading || overlaysConnection === "connecting" && iframe.status !== "refreshing") && !continueAnyway ? /* @__PURE__ */ jsx(
                MotionFlex,
                {
                  initial: "initial",
                  animate: "animate",
                  exit: "exit",
                  variants: spinnerVariants,
                  justify: "center",
                  align: "center",
                  style: {
                    inset: "0",
                    position: "absolute"
                    // boxShadow: '0 0 0 1px var(--card-shadow-outline-color)',
                  },
                  children: /* @__PURE__ */ jsxs(
                    Flex,
                    {
                      style: { ...sizes[viewport] },
                      justify: "center",
                      align: "center",
                      direction: "column",
                      gap: 4,
                      children: [
                        /* @__PURE__ */ jsx(Spinner, { muted: !0 }),
                        /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: t("preview-frame.status", { context: "loading" }) })
                      ]
                    }
                  )
                }
              ) : somethingIsWrong && !continueAnyway ? /* @__PURE__ */ jsx(
                MotionFlex,
                {
                  initial: "initial",
                  animate: "animate",
                  exit: "exit",
                  variants: errorVariants,
                  justify: "center",
                  align: "center",
                  style: {
                    background: "var(--card-bg-color)",
                    inset: "0",
                    position: "absolute",
                    borderTop: "1px solid transparent",
                    boxShadow: "0 0 0 1px var(--card-border-color)"
                  },
                  children: /* @__PURE__ */ jsx(
                    ErrorCard,
                    {
                      flex: 1,
                      message: t("preview-frame.connection.error.text"),
                      onRetry: handleRetry,
                      onContinueAnyway: handleContinueAnyway,
                      children: devMode && /* @__PURE__ */ jsxs(Fragment, { children: [
                        overlaysConnection !== "connected" && /* @__PURE__ */ jsx(Card, { padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
                          /* @__PURE__ */ jsx(Label, { muted: !0, size: 0, children: t("preview-frame.overlay.connection-status.label") }),
                          /* @__PURE__ */ jsx(Code, { size: 1, children: t("channel.status", { context: overlaysConnection }) })
                        ] }) }),
                        loadersConnection !== "connected" && /* @__PURE__ */ jsx(Card, { padding: 3, radius: 2, tone: "critical", children: /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
                          /* @__PURE__ */ jsx(Label, { muted: !0, size: 0, children: t("preview-frame.loader.connection-status.label") }),
                          /* @__PURE__ */ jsx(Code, { size: 1, children: t("channel.status", { context: loadersConnection }) })
                        ] }) })
                      ] })
                    }
                  )
                }
              ) : null }),
              /* @__PURE__ */ jsx(
                IFrame,
                {
                  animate: iframeAnimations,
                  initial: ["background"],
                  onLoad: onIFrameLoad,
                  preventClick: preventIframeInteraction,
                  ref,
                  src: initialUrl.toString(),
                  variants: iframeVariants
                }
              )
            ]
          }
        ) })
      ] }) });
    }
  )
);
PreviewFrame.displayName = "Memo(ForwardRef(PreviewFrame))";
const sizes = {
  desktop: {
    width: "100%",
    height: "100%"
  },
  mobile: {
    width: 375,
    height: 650
  }
}, spinnerVariants = {
  initial: { opacity: 1 },
  animate: { opacity: [0, 0, 1] },
  exit: { opacity: [1, 0, 0] }
}, errorVariants = {
  initial: { opacity: 1 },
  animate: { opacity: [0, 0, 1] },
  exit: { opacity: [1, 0, 0] }
}, iframeVariants = {
  desktop: {
    ...sizes.desktop,
    boxShadow: "0 0 0 0px var(--card-border-color)"
  },
  mobile: {
    ...sizes.mobile,
    boxShadow: "0 0 0 1px var(--card-border-color)"
  },
  background: {
    opacity: 0,
    scale: 1
  },
  idle: {
    scale: 1
  },
  reloading: {
    scale: [1, 1, 1, 0.98]
  },
  active: {
    opacity: [0, 0, 1],
    scale: 1
  },
  timedOut: {
    opacity: [0, 0, 1]
  }
};
function useEffectOnChange(value, callback, dependencies, initialValue, comparator) {
  const previousValueRef = useRef(initialValue), _callback = useCallback(callback, dependencies);
  useEffect(() => {
    const prev = previousValueRef.current;
    if (previousValueRef.current = value, value !== prev)
      return _callback(value, prev);
  }, [_callback, comparator, value]);
}
const RevisionSwitcher = function(props) {
  const { documentId, documentType, navigate, perspective, documentRevision } = props, editState = useEditState(documentId, documentType);
  return useEffectOnChange(
    perspective,
    (value) => {
      let rev;
      if (value === "published" && editState.published) {
        const { _updatedAt, _rev } = editState.published;
        rev = `${_updatedAt}/${_rev}`;
      }
      documentRevision !== rev && navigate({}, { rev }, !0);
    },
    [editState, navigate, documentRevision]
  ), null;
};
let warnedAboutCrossDatasetReference = !1;
function useDocumentsOnPage(perspective, frameStateRef) {
  if (perspective !== "published" && perspective !== "previewDrafts")
    throw new Error(`Invalid perspective: ${perspective}`);
  const [published, setPublished] = useState({}), [previewDrafts, setPreviewDrafts] = useState({}), urlRef = useRef(""), setDocumentsOnPage = useCallback(
    (key, perspective2, sourceDocuments = []) => {
      const documents = sourceDocuments.filter((sourceDocument) => "_projectId" in sourceDocument && sourceDocument._projectId ? (warnedAboutCrossDatasetReference || (console.warn(
        "Cross dataset references are not supported yet, ignoring source document",
        sourceDocument
      ), warnedAboutCrossDatasetReference = !0), !1) : sourceDocument);
      (perspective2 === "published" ? setPublished : setPreviewDrafts)((cache) => {
        const next = {};
        for (const document2 of documents)
          next[document2._id] = document2;
        if (urlRef.current !== frameStateRef.current.url)
          return urlRef.current = frameStateRef.current.url, { [key]: next };
        const prev = cache[key];
        return isEqual(prev, next) ? cache : { ...cache, [key]: next };
      });
    },
    [frameStateRef]
  );
  return [useMemo(() => {
    const uniqueDocuments = Object.values(perspective === "published" ? published : previewDrafts).reduce((acc, cache) => (Object.values(cache).forEach((doc) => {
      acc[doc._id] = doc;
    }), acc), {});
    return Object.values(uniqueDocuments);
  }, [perspective, previewDrafts, published]), setDocumentsOnPage];
}
function fnOrObj(arg, context) {
  return arg instanceof Function ? arg(context) : arg;
}
function getQueryFromResult(resolver, context) {
  if (resolver.resolve) {
    const filter = resolver.resolve(context)?.filter;
    return filter ? `*[${filter}][0]{_id, _type}` : void 0;
  }
  return "type" in resolver ? `*[_type == "${resolver.type}"][0]{_id, _type}` : `*[${fnOrObj(resolver.filter, context)}][0]{_id, _type}`;
}
function getParamsFromResult(resolver, context) {
  return resolver.resolve ? resolver.resolve(context)?.params ?? context.params : "type" in resolver ? {} : fnOrObj(resolver.params, context) ?? context.params;
}
function getRouteContext(route, url) {
  const routes = Array.isArray(route) ? route : [route];
  for (route of routes) {
    let origin, path = route;
    if (typeof route == "string")
      try {
        const absolute = new URL(route);
        origin = absolute.origin, path = absolute.pathname;
      } catch {
      }
    if (!(origin && url.origin !== origin))
      try {
        const result = match(path, { decode: decodeURIComponent })(url.pathname);
        if (result) {
          const { params, path: path2 } = result;
          return { origin, params, path: path2 };
        }
      } catch {
        throw new Error(`"${route}" is not a valid route pattern`);
      }
  }
}
function useMainDocument(props) {
  const { navigate, navigationHistory, path, previewUrl, resolvers = [] } = props, { state: routerState } = useRouter(), client = useClient({ apiVersion: API_VERSION }), [mainDocumentState, setMainDocumentState] = useState(
    void 0
  ), mainDocumentIdRef = useRef(void 0), url = useMemo(() => {
    const relativeUrl = path || routerState._searchParams?.find(([key]) => key === "preview")?.[1] || "", base = typeof previewUrl == "string" ? previewUrl : typeof previewUrl == "object" && previewUrl?.origin || location.origin;
    return new URL(relativeUrl, base);
  }, [path, previewUrl, routerState._searchParams]), clearState = useCallback(() => {
    setMainDocumentState(void 0), mainDocumentIdRef.current = void 0;
  }, []);
  return useEffect(() => {
    if (resolvers.length && url) {
      let result;
      for (const resolver of resolvers) {
        const context = getRouteContext(resolver.route, url);
        if (context) {
          result = { context, resolver };
          break;
        }
      }
      if (result) {
        const query = getQueryFromResult(result.resolver, result.context), params = getParamsFromResult(result.resolver, result.context);
        if (query) {
          const controller = new AbortController(), options = {
            perspective: "previewDrafts",
            signal: controller.signal
          };
          return client.fetch(query, params, options).then((doc) => {
            (!doc || mainDocumentIdRef.current !== doc._id) && (setMainDocumentState({
              document: doc,
              path: url.pathname
            }), mainDocumentIdRef.current = doc?._id, navigationHistory.at(-1)?.id === navigationHistory.at(-2)?.id && navigate?.({
              id: doc?._id,
              type: doc?._type
            }));
          }).catch((e) => {
            e instanceof Error && e.name === "AbortError" || (setMainDocumentState({ document: void 0, path: url.pathname }), mainDocumentIdRef.current = void 0);
          }), () => {
            controller.abort();
          };
        }
      }
    }
    clearState();
  }, [client, clearState, navigate, navigationHistory, resolvers, url]), mainDocumentState;
}
function parseId(rawId) {
  if (rawId === void 0)
    return;
  const segments = decodeURIComponent(rawId)?.split(".");
  return segments[0] === "drafts" && segments.shift(), segments.join(".");
}
function parsePath(rawPath) {
  if (rawPath !== void 0)
    return studioPath.toString(urlStringToPath(decodeURIComponent(rawPath)));
}
function parseRouterState(state) {
  return {
    id: parseId(state.id),
    path: parsePath(state.path),
    type: state.type
  };
}
function pruneObject(obj) {
  return Object.fromEntries(
    Object.entries(obj).filter(
      ([, value]) => value !== void 0 && value !== "" && value !== null
    )
  );
}
function useParams({
  initialPreviewUrl,
  routerNavigate,
  routerState,
  routerSearchParams,
  frameStateRef
}) {
  const params = useMemo(() => {
    const { id, path, type } = parseRouterState(routerState);
    return {
      id,
      type,
      path,
      preview: routerSearchParams.preview || `${initialPreviewUrl.pathname}${initialPreviewUrl.search}`,
      perspective: routerSearchParams.perspective,
      viewport: routerSearchParams.viewport,
      inspect: routerSearchParams.inspect,
      rev: routerSearchParams.rev,
      since: routerSearchParams.since,
      template: routerSearchParams.template,
      templateParams: routerSearchParams.templateParams,
      view: routerSearchParams.view,
      // assist
      pathKey: routerSearchParams.pathKey,
      instruction: routerSearchParams.instruction,
      // comments
      comment: routerSearchParams.comment
    };
  }, [routerState, routerSearchParams, initialPreviewUrl]), structureParams = useMemo(() => pruneObject({
    inspect: params.inspect,
    path: params.path,
    rev: params.rev,
    since: params.since,
    template: params.template,
    templateParams: params.templateParams,
    view: params.view,
    // assist
    pathKey: params.pathKey,
    instruction: params.instruction,
    // comments
    comment: params.comment
  }), [
    params.comment,
    params.inspect,
    params.instruction,
    params.path,
    params.pathKey,
    params.rev,
    params.since,
    params.template,
    params.templateParams,
    params.view
  ]), searchParams = useMemo(() => pruneObject({
    perspective: params.perspective,
    preview: params.preview,
    viewport: params.viewport
  }), [params.perspective, params.preview, params.viewport]), routerStateRef = useRef(routerState);
  useEffect(() => {
    routerStateRef.current = routerState;
  }, [routerState]);
  const [navigationHistory, setNavigationHistory] = useState([routerState]);
  return {
    navigate: useCallback(
      (nextState, nextSearchState = {}, forceReplace) => {
        nextState.id && (nextState.id = getPublishedId(nextState.id));
        const { _searchParams: routerSearchParams2, ...routerState2 } = routerStateRef.current, routerSearchState = (routerSearchParams2 || []).reduce(
          (acc, [key, value]) => (acc[key] = value, acc),
          {}
        ), state = pruneObject({
          ...routerState2,
          ...nextState
        }), searchState = pruneObject({
          ...routerSearchState,
          ...nextSearchState
        });
        routerState2.id !== state.id && (delete searchState.template, delete searchState.templateParams), state._searchParams = Object.entries(searchState).reduce(
          (acc, [key, value]) => [...acc, [key, value]],
          []
        );
        const replace = forceReplace ?? searchState.preview === frameStateRef.current.url;
        setNavigationHistory((prev) => [...prev, state]), routerNavigate(state, { replace });
      },
      [routerNavigate, frameStateRef]
    ),
    navigationHistory,
    params,
    searchParams,
    structureParams
  };
}
function usePreviewUrl(previewUrl, toolName, studioPreviewPerspective, previewSearchParam, canCreateUrlPreviewSecrets) {
  const client = useClient({ apiVersion: API_VERSION }), workspace = useActiveWorkspace(), basePath = workspace?.activeWorkspace?.basePath || "/", workspaceName = workspace?.activeWorkspace?.name || "default", deps = useSuspendCacheKeys(toolName, basePath, workspaceName, previewSearchParam), previewUrlSecret = usePreviewUrlSecret(
    canCreateUrlPreviewSecrets && typeof previewUrl == "object" || typeof previewUrl == "function",
    deps
  );
  return suspend(async () => {
    if (typeof previewUrl == "string") {
      const resolvedUrl2 = new URL(previewUrl, location.origin);
      let resultUrl = resolvedUrl2;
      try {
        if (previewSearchParam) {
          const restoredUrl = new URL(previewSearchParam, resolvedUrl2);
          restoredUrl.origin === resolvedUrl2.origin && (resultUrl = restoredUrl);
        }
      } catch {
      }
      return location.origin === resultUrl.origin && (resultUrl.pathname.startsWith(`${basePath}/`) || resultUrl.pathname === basePath) ? resolvedUrl2 : resultUrl;
    }
    const resolvedUrl = await (typeof previewUrl == "object" ? definePreviewUrl(previewUrl) : previewUrl)({
      client,
      previewUrlSecret,
      studioPreviewPerspective,
      previewSearchParam,
      studioBasePath: basePath
    });
    return new URL(resolvedUrl, location.origin);
  }, [...deps, previewUrlSecret]);
}
const resolveUUID = Symbol();
function useSuspendCacheKeys(toolName, basePath, workspaceName, previewSearchParam) {
  const [cachedPreviewSearchParam, setCachedPreviewSearchParam] = useState(
    () => previewSearchParam || ""
  ), timeoutRef = useRef(0);
  useEffect(() => {
    if (cachedPreviewSearchParam && previewSearchParam)
      return window.clearTimeout(timeoutRef.current), () => {
        timeoutRef.current = window.setTimeout(() => {
          setCachedPreviewSearchParam("");
        }, 100);
      };
  }, [cachedPreviewSearchParam, previewSearchParam]);
  const currentUser = useCurrentUser();
  return useMemo(
    () => [
      // Cache based on a few specific conditions
      "@sanity/presentation",
      basePath,
      workspaceName,
      toolName,
      currentUser?.id,
      resolveUUID,
      cachedPreviewSearchParam
    ],
    [basePath, currentUser?.id, toolName, workspaceName, cachedPreviewSearchParam]
  );
}
function usePreviewUrlSecret(enabled, deps) {
  const client = useClient({ apiVersion: API_VERSION }), currentUser = useCurrentUser(), [secretLastExpiredAt, setSecretLastExpiredAt] = useState(""), previewUrlSecret = enabled ? suspend(async () => await createPreviewSecret(
    client,
    "@sanity/presentation",
    typeof window > "u" ? "" : location.href,
    currentUser?.id
  ), [...deps, secretLastExpiredAt]) : null;
  return useEffect(() => {
    if (!previewUrlSecret) return;
    const timeout = setTimeout(() => {
      startTransition(() => setSecretLastExpiredAt(previewUrlSecret.expiresAt.toString()));
    }, previewUrlSecret.expiresAt.getTime() - Date.now());
    return () => clearTimeout(timeout);
  }, [previewUrlSecret]), previewUrlSecret?.secret || null;
}
function useStatus() {
  const [statusMap, setStatusMap] = useState(
    /* @__PURE__ */ new Map()
  ), status = useMemo(() => {
    const values = Array.from(statusMap.values()), handshaking = values.filter(({ status: status2 }) => status2 === "handshaking");
    return handshaking.length ? handshaking.some(({ hasConnected }) => !hasConnected) ? "connecting" : "reconnecting" : values.find(({ status: status2 }) => status2 === "connected") ? "connected" : "idle";
  }, [statusMap]), setStatusFromEvent = useCallback((event) => {
    setStatusMap((prev) => {
      const next = new Map(prev);
      if (event.status === "disconnected")
        next.delete(event.channel);
      else {
        const hasConnected = next.get(event.channel)?.hasConnected || event.status === "connected";
        next.set(event.channel, { status: event.status, hasConnected });
      }
      return next;
    });
  }, []);
  return [status, setStatusFromEvent];
}
const LoaderQueries = lazy(() => import("./LoaderQueries.js"));
lazy(() => import("./LiveQueries.js"));
const PostMessageDocuments = lazy(() => import("./PostMessageDocuments.js")), PostMessageFeatures = lazy(() => import("./PostMessageFeatures.js")), PostMessageRefreshMutations = lazy(() => import("./PostMessageRefreshMutations.js")), PostMessagePerspective = lazy(() => import("./PostMessagePerspective.js")), PostMessagePreviewSnapshots = lazy(() => import("./PostMessagePreviewSnapshots.js")), PostMessageSchema = lazy(() => import("./PostMessageSchema.js")), Container = styled(Flex)`
  overflow-x: auto;
`;
function PresentationTool(props) {
  const { canCreateUrlPreviewSecrets, canToggleSharePreviewAccess, canUseSharedPreviewAccess, tool } = props, components = tool.options?.components, _previewUrl = tool.options?.previewUrl, name = tool.name || DEFAULT_TOOL_NAME, { unstable_navigator } = components || {}, { navigate: routerNavigate, state: routerState } = useRouter(), routerSearchParams = useUnique(Object.fromEntries(routerState._searchParams || [])), initialPreviewUrl = usePreviewUrl(
    _previewUrl || "/",
    name,
    routerSearchParams.perspective === "published" ? "published" : "previewDrafts",
    routerSearchParams.preview || null,
    canCreateUrlPreviewSecrets
  ), canSharePreviewAccess = useMemo(() => _previewUrl && typeof _previewUrl == "object" && "previewMode" in _previewUrl && _previewUrl.previewMode ? _previewUrl.previewMode.shareAccess !== !1 : !1, [_previewUrl]), [devMode] = useState(() => {
    const option = tool.options?.devMode;
    return typeof option == "function" ? option() : typeof option == "boolean" ? option : typeof window < "u" && window.location.hostname === "localhost";
  }), targetOrigin = useMemo(() => initialPreviewUrl.origin, [initialPreviewUrl.origin]), iframeRef = useRef(null), [controller, setController] = useState(), [visualEditingComlink, setVisualEditingComlink] = useState(
    null
  ), frameStateRef = useRef({
    title: void 0,
    url: void 0
  }), {
    navigate: _navigate,
    navigationHistory,
    params,
    searchParams,
    structureParams
  } = useParams({
    initialPreviewUrl,
    routerNavigate,
    routerState,
    routerSearchParams,
    frameStateRef
  }), navigate = useMemo(() => debounce(_navigate, 50), [_navigate]), [state, dispatch] = useReducer(presentationReducer, {}, presentationReducerInit), perspective = useMemo(
    () => params.perspective ? "published" : "previewDrafts",
    [params.perspective]
  ), viewport = useMemo(() => params.viewport ? "mobile" : "desktop", [params.viewport]), [documentsOnPage, setDocumentsOnPage] = useDocumentsOnPage(perspective, frameStateRef), projectId = useProjectId(), dataset = useDataset(), mainDocumentState = useMainDocument({
    // Prevent flash of content by using immediate navigation
    navigate: _navigate,
    navigationHistory,
    path: params.preview,
    previewUrl: tool.options?.previewUrl,
    resolvers: tool.options?.resolve?.mainDocuments
  }), [overlaysConnection, setOverlaysConnection] = useStatus(), [loadersConnection, setLoadersConnection] = useStatus(), [previewKitConnection, setPreviewKitConnection] = useStatus(), [popups, setPopups] = useState(() => /* @__PURE__ */ new Set()), handleOpenPopup = useCallback((url) => {
    const source = window.open(url, "_blank");
    source && setPopups((prev) => new Set(prev).add(source));
  }, []);
  useEffect(() => {
    const target = iframeRef.current?.contentWindow;
    if (!target || state.iframe.status === "loading") return;
    const controller2 = createController({ targetOrigin });
    return controller2.addTarget(target), setController(controller2), () => {
      controller2.destroy(), setController(void 0);
    };
  }, [targetOrigin, state.iframe.status]), useEffect(() => {
    const unsubs = [];
    if (popups.size && controller)
      for (const source of popups)
        source && "closed" in source && !source.closed && unsubs.push(controller.addTarget(source));
    return () => {
      unsubs.forEach((unsub) => unsub());
    };
  }, [controller, popups]), useEffect(() => {
    if (!controller) return;
    const comlink = controller.createConnection(
      {
        name: "presentation",
        heartbeat: !0,
        connectTo: "visual-editing"
      },
      createChannelMachine().provide({
        actors: createCompatibilityActors()
      })
    );
    comlink.on("visual-editing/focus", (data) => {
      "id" in data && navigate({
        type: data.type,
        id: data.id,
        path: data.path
      });
    }), comlink.on("visual-editing/navigate", (data) => {
      const { title, url } = data;
      frameStateRef.current.url !== url && navigate({}, { preview: url }), frameStateRef.current = { title, url };
    }), comlink.on("visual-editing/meta", (data) => {
      frameStateRef.current.title = data.title;
    }), comlink.on("visual-editing/toggle", (data) => {
      dispatch({
        type: ACTION_VISUAL_EDITING_OVERLAYS_TOGGLE,
        enabled: data.enabled
      });
    }), comlink.on("visual-editing/documents", (data) => {
      setDocumentsOnPage(
        "visual-editing",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        data.perspective,
        data.documents
      );
    }), comlink.on("visual-editing/refreshing", (data) => {
      data.source === "manual" ? clearTimeout(refreshRef.current) : data.source === "mutation" && dispatch({ type: ACTION_IFRAME_REFRESH });
    }), comlink.on("visual-editing/refreshed", () => {
      dispatch({ type: ACTION_IFRAME_LOADED });
    }), comlink.onStatus(setOverlaysConnection);
    const stop = comlink.start();
    return setVisualEditingComlink(comlink), () => {
      stop(), setVisualEditingComlink(null);
    };
  }, [controller, navigate, setDocumentsOnPage, setOverlaysConnection, targetOrigin]), useEffect(() => {
    if (!controller) return;
    const comlink = controller.createConnection(
      {
        name: "presentation",
        connectTo: "preview-kit",
        heartbeat: !0
      },
      createChannelMachine().provide({
        actors: createCompatibilityActors()
      })
    );
    return comlink.onStatus(setPreviewKitConnection), comlink.on("preview-kit/documents", (data) => {
      data.projectId === projectId && data.dataset === dataset && setDocumentsOnPage(
        "preview-kit",
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        data.perspective,
        data.documents
      );
    }), comlink.start();
  }, [controller, dataset, projectId, setDocumentsOnPage, setPreviewKitConnection, targetOrigin]);
  const handleFocusPath = useCallback(
    (nextPath) => {
      navigate({ path: studioPath.toString(nextPath) }, {}, !0);
    },
    [navigate]
  ), handlePreviewPath = useCallback(
    (nextPath) => {
      const url = new URL(nextPath, initialPreviewUrl.origin), preview = url.pathname + url.search;
      url.origin === initialPreviewUrl.origin && preview !== params.preview && navigate({}, { preview });
    },
    [initialPreviewUrl, params, navigate]
  ), handleStructureParams = useCallback(
    (structureParams2) => {
      navigate({}, structureParams2);
    },
    [navigate]
  );
  useEffect(() => {
    params.id && params.path ? visualEditingComlink?.post({
      type: "presentation/focus",
      data: { id: params.id, path: params.path }
    }) : visualEditingComlink?.post({ type: "presentation/blur", data: void 0 });
  }, [params.id, params.path, visualEditingComlink]), useEffect(() => {
    frameStateRef.current.url && params.preview && frameStateRef.current.url !== params.preview && (frameStateRef.current.url = params.preview, overlaysConnection !== "connected" && iframeRef.current ? iframeRef.current.src = `${targetOrigin}${params.preview}` : visualEditingComlink?.post({
      type: "presentation/navigate",
      data: {
        url: params.preview,
        type: "replace"
      }
    }));
  }, [overlaysConnection, targetOrigin, params.preview, visualEditingComlink]);
  const toggleOverlay = useCallback(
    () => visualEditingComlink?.post({ type: "presentation/toggle-overlay", data: void 0 }),
    [visualEditingComlink]
  ), [displayedDocument, setDisplayedDocument] = useState(null);
  useEffect(() => {
    const handleKeyUp = (e) => {
      isAltKey(e) && toggleOverlay();
    }, handleKeydown = (e) => {
      isAltKey(e) && toggleOverlay(), isHotkey(["mod", "\\"], e) && toggleOverlay();
    };
    return window.addEventListener("keydown", handleKeydown), window.addEventListener("keyup", handleKeyUp), () => {
      window.removeEventListener("keydown", handleKeydown), window.removeEventListener("keyup", handleKeyUp);
    };
  }, [toggleOverlay]);
  const [boundaryElement, setBoundaryElement] = useState(null), [{ navigatorEnabled, toggleNavigator }, PresentationNavigator] = usePresentationNavigator({
    unstable_navigator
  }), idRef = useRef(params.id);
  useEffect(() => {
    params.rev && idRef.current && params.id !== idRef.current && navigate({}, { rev: void 0 }), idRef.current = params.id;
  });
  const refreshRef = useRef(), handleRefresh = useCallback(
    (fallback2) => {
      if (dispatch({ type: ACTION_IFRAME_REFRESH }), visualEditingComlink) {
        refreshRef.current = window.setTimeout(fallback2, 300), visualEditingComlink.post({
          type: "presentation/refresh",
          data: {
            source: "manual",
            livePreviewEnabled: previewKitConnection === "connected" || loadersConnection === "connected"
          }
        });
        return;
      }
      fallback2();
    },
    [loadersConnection, previewKitConnection, visualEditingComlink]
  ), workspace = useWorkspace(), getCommentIntent = useCallback(
    ({ id, type, path }) => {
      if (frameStateRef.current.url)
        return {
          title: frameStateRef.current.title || frameStateRef.current.url,
          name: "edit",
          params: {
            id,
            path,
            type,
            inspect: COMMENTS_INSPECTOR_NAME,
            workspace: workspace.name,
            mode: EDIT_INTENT_MODE,
            preview: params.preview
          }
        };
    },
    [params.preview, workspace.name]
  ), setViewport = useCallback(
    (next) => {
      navigate({}, { viewport: next === "desktop" ? void 0 : "mobile" }, !0);
    },
    [navigate]
  ), setPerspective = useCallback(
    (next) => {
      navigate({}, { perspective: next === "previewDrafts" ? void 0 : next });
    },
    [navigate]
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      PresentationProvider,
      {
        devMode,
        name,
        navigate,
        params,
        searchParams,
        structureParams,
        children: /* @__PURE__ */ jsx(PresentationNavigateProvider, { navigate, children: /* @__PURE__ */ jsx(PresentationParamsProvider, { params, children: /* @__PURE__ */ jsx(Container, { height: "fill", children: /* @__PURE__ */ jsxs(Panels, { children: [
          /* @__PURE__ */ jsx(PresentationNavigator, {}),
          /* @__PURE__ */ jsx(
            Panel,
            {
              id: "preview",
              minWidth: 325,
              defaultSize: navigatorEnabled ? 50 : 75,
              order: 3,
              children: /* @__PURE__ */ jsx(Flex, { direction: "column", flex: 1, height: "fill", ref: setBoundaryElement, children: /* @__PURE__ */ jsx(BoundaryElementProvider, { element: boundaryElement, children: /* @__PURE__ */ jsx(
                PreviewFrame,
                {
                  canSharePreviewAccess,
                  canToggleSharePreviewAccess,
                  canUseSharedPreviewAccess,
                  dispatch,
                  iframe: state.iframe,
                  initialUrl: initialPreviewUrl,
                  loadersConnection,
                  navigatorEnabled,
                  onPathChange: handlePreviewPath,
                  onRefresh: handleRefresh,
                  openPopup: handleOpenPopup,
                  overlaysConnection,
                  previewUrl: params.preview,
                  perspective,
                  ref: iframeRef,
                  setPerspective,
                  setViewport,
                  targetOrigin,
                  toggleNavigator,
                  toggleOverlay,
                  viewport,
                  visualEditing: state.visualEditing
                }
              ) }) })
            }
          ),
          /* @__PURE__ */ jsx(
            PresentationContent,
            {
              documentId: params.id,
              documentsOnPage,
              documentType: params.type,
              getCommentIntent,
              mainDocumentState,
              onFocusPath: handleFocusPath,
              onStructureParams: handleStructureParams,
              searchParams,
              setDisplayedDocument,
              structureParams
            }
          )
        ] }) }) }) })
      }
    ),
    controller && /* @__PURE__ */ jsx(Suspense, { children: /* @__PURE__ */ jsx(
      LoaderQueries,
      {
        controller,
        perspective,
        liveDocument: displayedDocument,
        onDocumentsOnPage: setDocumentsOnPage,
        onLoadersConnection: setLoadersConnection,
        documentsOnPage
      }
    ) }),
    visualEditingComlink && params.id && params.type && /* @__PURE__ */ jsx(Suspense, { children: /* @__PURE__ */ jsx(
      PostMessageRefreshMutations,
      {
        comlink: visualEditingComlink,
        id: params.id,
        type: params.type,
        loadersConnection,
        previewKitConnection
      }
    ) }),
    visualEditingComlink && /* @__PURE__ */ jsx(Suspense, { children: /* @__PURE__ */ jsx(PostMessageSchema, { comlink: visualEditingComlink, perspective }) }),
    visualEditingComlink && documentsOnPage.length > 0 && /* @__PURE__ */ jsx(Suspense, { children: /* @__PURE__ */ jsx(
      PostMessagePreviewSnapshots,
      {
        comlink: visualEditingComlink,
        perspective,
        refs: documentsOnPage
      }
    ) }),
    visualEditingComlink && /* @__PURE__ */ jsx(Suspense, { children: /* @__PURE__ */ jsx(PostMessageDocuments, { comlink: visualEditingComlink }) }),
    visualEditingComlink && /* @__PURE__ */ jsx(Suspense, { children: /* @__PURE__ */ jsx(PostMessageFeatures, { comlink: visualEditingComlink }) }),
    visualEditingComlink && /* @__PURE__ */ jsx(Suspense, { children: /* @__PURE__ */ jsx(PostMessagePerspective, { comlink: visualEditingComlink, perspective }) }),
    params.id && params.type && /* @__PURE__ */ jsx(
      RevisionSwitcher,
      {
        documentId: params.id,
        documentRevision: params.rev,
        documentType: params.type,
        navigate,
        perspective
      }
    )
  ] });
}
function PresentationToolGrantsCheck(props) {
  const { t } = useTranslation(presentationLocaleNamespace), { previewUrl } = props.tool.options ?? {}, { push: pushToast } = useToast(), willGeneratePreviewUrlSecret = typeof previewUrl == "object" || typeof previewUrl == "function", grantsStore = useGrantsStore(), [previewAccessSharingCreatePermission, setCreateAccessSharingPermission] = useState(null), [previewAccessSharingUpdatePermission, setUpdateAccessSharingPermission] = useState(null), [previewAccessSharingReadPermission, setReadAccessSharingPermission] = useState(null), [previewUrlSecretPermission, setPreviewUrlSecretPermission] = useState(null);
  useEffect(() => {
    if (!willGeneratePreviewUrlSecret) return;
    const previewCreateAccessSharingPermissionSubscription = grantsStore.checkDocumentPermission("create", { _id: schemaIdSingleton, _type: schemaTypeSingleton }).subscribe(setCreateAccessSharingPermission), previewUpdateAccessSharingPermissionSubscription = grantsStore.checkDocumentPermission("update", { _id: schemaIdSingleton, _type: schemaTypeSingleton }).subscribe(setUpdateAccessSharingPermission), previewReadAccessSharingPermissionSubscription = grantsStore.checkDocumentPermission("read", { _id: schemaIdSingleton, _type: schemaTypeSingleton }).subscribe(setReadAccessSharingPermission), previewUrlSecretPermissionSubscription = grantsStore.checkDocumentPermission("create", { _id: `drafts.${uuid()}`, _type: schemaType }).subscribe(setPreviewUrlSecretPermission);
    return () => {
      previewCreateAccessSharingPermissionSubscription.unsubscribe(), previewUpdateAccessSharingPermissionSubscription.unsubscribe(), previewReadAccessSharingPermissionSubscription.unsubscribe(), previewUrlSecretPermissionSubscription.unsubscribe();
    };
  }, [grantsStore, willGeneratePreviewUrlSecret]);
  const canCreateUrlPreviewSecrets = previewUrlSecretPermission?.granted;
  return useEffect(() => {
    if (!willGeneratePreviewUrlSecret || canCreateUrlPreviewSecrets !== !1) return;
    const raf = requestAnimationFrame(
      () => pushToast({
        closable: !0,
        status: "error",
        duration: 3e4,
        title: t("preview-url-secret.missing-grants")
      })
    );
    return () => cancelAnimationFrame(raf);
  }, [canCreateUrlPreviewSecrets, pushToast, t, willGeneratePreviewUrlSecret]), willGeneratePreviewUrlSecret && (!previewAccessSharingCreatePermission || typeof previewAccessSharingCreatePermission.granted > "u" || !previewAccessSharingUpdatePermission || typeof previewAccessSharingUpdatePermission.granted > "u" || !previewUrlSecretPermission || !previewAccessSharingReadPermission || typeof previewAccessSharingReadPermission.granted > "u" || typeof previewUrlSecretPermission.granted > "u") ? /* @__PURE__ */ jsx(PresentationSpinner, {}) : /* @__PURE__ */ jsx(
    PresentationTool,
    {
      ...props,
      canCreateUrlPreviewSecrets: canCreateUrlPreviewSecrets === !0,
      canToggleSharePreviewAccess: previewAccessSharingCreatePermission?.granted === !0 && previewAccessSharingUpdatePermission?.granted === !0,
      canUseSharedPreviewAccess: previewAccessSharingReadPermission?.granted === !0
    }
  );
}
var PresentationToolGrantsCheck$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: PresentationToolGrantsCheck
});
export {
  PresentationToolGrantsCheck$1 as PresentationToolGrantsCheck,
  createCompatibilityActors,
  getQueryCacheKey
};
//# sourceMappingURL=PresentationToolGrantsCheck.js.map
