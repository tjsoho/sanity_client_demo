"use strict";
var node_crypto = require("node:crypto"), fs = require("node:fs/promises"), path = require("node:path"), node_worker_threads = require("node:worker_threads"), dateFns = require("date-fns"), readPkgUp = require("read-pkg-up"), timing = require("./timing.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var readPkgUp__default = /* @__PURE__ */ _interopDefaultCompat(readPkgUp);
const MANIFEST_FILENAME = "create-manifest.json", SCHEMA_FILENAME_SUFFIX = ".create-schema.json", FEATURE_ENABLED_ENV_NAME = "SANITY_CLI_EXTRACT_MANIFEST_ENABLED", EXTRACT_MANIFEST_ENABLED = process.env[FEATURE_ENABLED_ENV_NAME] !== "false", EXTRACT_MANIFEST_LOG_ERRORS = process.env.SANITY_CLI_EXTRACT_MANIFEST_LOG_ERRORS === "true", CREATE_TIMER = "create-manifest", EXTRACT_TASK_TIMEOUT_MS = dateFns.minutesToMilliseconds(2), EXTRACT_FAILURE_MESSAGE = `Couldn't extract manifest file. Sanity Create will not be available for the studio.
Disable this message with ${FEATURE_ENABLED_ENV_NAME}=false`;
async function extractManifestSafe(args, context) {
  if (EXTRACT_MANIFEST_ENABLED)
    try {
      await extractManifest(args, context);
      return;
    } catch (err) {
      return EXTRACT_MANIFEST_LOG_ERRORS && context.output.error(err), err;
    }
}
async function extractManifest(args, context) {
  const { output, workDir } = context, flags = args.extOptions, defaultOutputDir = path.resolve(path.join(workDir, "dist")), outputDir = path.resolve(defaultOutputDir), defaultStaticPath = path.join(outputDir, "static"), staticPath = flags.path ?? defaultStaticPath, path$1 = path.join(staticPath, MANIFEST_FILENAME), rootPkgPath = readPkgUp__default.default.sync({ cwd: __dirname })?.path;
  if (!rootPkgPath)
    throw new Error("Could not find root directory for `sanity` package");
  const timer = timing.getTimer();
  timer.start(CREATE_TIMER);
  const spinner = output.spinner({}).start("Extracting manifest");
  try {
    const workspaceManifests = await getWorkspaceManifests({ rootPkgPath, workDir });
    await fs.mkdir(staticPath, { recursive: !0 });
    const workspaceFiles = await writeWorkspaceFiles(workspaceManifests, staticPath), manifest = {
      version: 1,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      workspaces: workspaceFiles
    };
    await fs.writeFile(path$1, JSON.stringify(manifest, null, 2));
    const manifestDuration = timer.end(CREATE_TIMER);
    spinner.succeed(`Extracted manifest (${manifestDuration.toFixed()}ms)`);
  } catch (err) {
    throw spinner.info(EXTRACT_FAILURE_MESSAGE), err;
  }
}
async function getWorkspaceManifests({
  rootPkgPath,
  workDir
}) {
  const workerPath = path.join(
    path.dirname(rootPkgPath),
    "lib",
    "_internal",
    "cli",
    "threads",
    "extractManifest.js"
  ), worker = new node_worker_threads.Worker(workerPath, {
    workerData: { workDir },
    // eslint-disable-next-line no-process-env
    env: process.env
  });
  let timeout = !1;
  const timeoutId = setTimeout(() => {
    timeout = !0, worker.terminate();
  }, EXTRACT_TASK_TIMEOUT_MS);
  try {
    return await new Promise((resolveWorkspaces, reject) => {
      const buffer = [];
      worker.addListener("message", (message) => buffer.push(message)), worker.addListener("exit", (exitCode) => {
        exitCode === 0 ? resolveWorkspaces(buffer) : timeout && reject(new Error(`Extract manifest was aborted after ${EXTRACT_TASK_TIMEOUT_MS}ms`));
      }), worker.addListener("error", reject);
    });
  } finally {
    clearTimeout(timeoutId);
  }
}
function writeWorkspaceFiles(manifestWorkspaces, staticPath) {
  const output = manifestWorkspaces.reduce(
    (workspaces, workspace) => [...workspaces, writeWorkspaceSchemaFile(workspace, staticPath)],
    []
  );
  return Promise.all(output);
}
async function writeWorkspaceSchemaFile(workspace, staticPath) {
  const schemaString = JSON.stringify(workspace.schema, null, 2), filename = `${node_crypto.createHash("sha1").update(schemaString).digest("hex").slice(0, 8)}${SCHEMA_FILENAME_SUFFIX}`;
  return await fs.writeFile(path.join(staticPath, filename), schemaString), {
    ...workspace,
    schema: filename
  };
}
exports.extractManifestSafe = extractManifestSafe;
//# sourceMappingURL=extractManifestAction.js.map
