"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var jsxRuntime = require("react/jsx-runtime"), icons = require("@sanity/icons"), ui = require("@sanity/ui"), startCase = require("lodash.startcase"), react = require("react"), reactIs = require("react-is");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var startCase__default = /* @__PURE__ */ _interopDefaultCompat(startCase);
function getSchemaTypeIcon(schemaType) {
  const referenceIcon = isReferenceSchemaType(schemaType) && (schemaType.to ?? []).length === 1 ? schemaType.to[0].icon : void 0;
  return schemaType.icon ?? schemaType.type?.icon ?? referenceIcon;
}
function isReferenceSchemaType(type) {
  return isRecord(type) && (type.name === "reference" || isReferenceSchemaType(type.type));
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function fullInsertMenuReducer(state, event) {
  return {
    query: event.type === "change query" ? event.query : state.query,
    groups: event.type === "select group" ? state.groups.map((group) => ({ ...group, selected: event.name === group.name })) : state.groups,
    views: event.type === "toggle view" ? state.views.map((view) => ({ ...view, selected: event.name === view.name })) : state.views
  };
}
const ALL_ITEMS_GROUP_NAME = "all-items", gridStyle = {
  gridTemplateColumns: "repeat(auto-fill, minmax(118px, 1fr))"
};
function InsertMenu(props) {
  const showIcons = props.showIcons === void 0 ? !0 : props.showIcons, showFilter = props.filter === void 0 || props.filter === "auto" ? props.schemaTypes.length > 5 : props.filter, [state, send] = react.useReducer(fullInsertMenuReducer, {
    query: "",
    groups: props.groups ? [
      {
        name: ALL_ITEMS_GROUP_NAME,
        title: props.labels["insert-menu.filter.all-items"],
        selected: !0
      },
      ...props.groups.map((group) => ({ ...group, selected: !1 }))
    ] : [],
    views: (props.views ?? [{ name: "list" }]).map((view, index) => ({
      ...view,
      selected: index === 0
    }))
  }), filteredSchemaTypes = filterSchemaTypes(props.schemaTypes, state.query, state.groups), selectedView = state.views.find((view) => view.selected), showingFilterOrViews = showFilter || state.views.length > 1, showingTabs = state.groups && state.groups.length > 0;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { padding: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", height: "fill", children: [
    /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Box,
      {
        ...showingFilterOrViews || showingTabs ? {
          style: { borderBottom: "1px solid var(--card-border-color)" },
          paddingBottom: 1
        } : {},
        children: [
          showingFilterOrViews ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: "none", align: "center", paddingTop: 1, paddingX: 1, gap: 1, children: [
            showFilter ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
              ui.TextInput,
              {
                autoFocus: !0,
                border: !1,
                fontSize: 1,
                icon: icons.SearchIcon,
                onChange: (event) => {
                  send({ type: "change query", query: event.target.value });
                },
                placeholder: props.labels["insert-menu.search.placeholder"],
                value: state.query
              }
            ) }) : null,
            state.views.length > 1 ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(
              ViewToggle,
              {
                views: state.views,
                onToggle: (name) => {
                  send({ type: "toggle view", name });
                },
                labels: props.labels
              }
            ) }) : null
          ] }) : null,
          showingTabs ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { paddingTop: 1, paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.TabList, { space: 1, children: state.groups.map((group) => /* @__PURE__ */ jsxRuntime.jsx(
            ui.Tab,
            {
              id: `${group.name}-tab`,
              "aria-controls": `${group.name}-panel`,
              label: group.title ?? startCase__default.default(group.name),
              selected: group.selected,
              onClick: () => {
                send({ type: "select group", name: group.name });
              }
            },
            group.name
          )) }) }) : null
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 1, children: filteredSchemaTypes.length === 0 ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: props.labels["insert-menu.search.no-results"] }) }) : selectedView ? selectedView.name === "grid" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Grid, { autoRows: "auto", flex: 1, gap: 1, style: gridStyle, children: filteredSchemaTypes.map((schemaType) => /* @__PURE__ */ jsxRuntime.jsx(
      GridMenuItem,
      {
        icon: showIcons ? getSchemaTypeIcon(schemaType) : void 0,
        onClick: () => {
          props.onSelect(schemaType);
        },
        previewImageUrl: selectedView.previewImageUrl?.(schemaType.name),
        schemaType
      },
      schemaType.name
    )) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, space: 1, children: filteredSchemaTypes.map((schemaType) => /* @__PURE__ */ jsxRuntime.jsx(
      ui.MenuItem,
      {
        icon: showIcons ? getSchemaTypeIcon(schemaType) : void 0,
        onClick: () => {
          props.onSelect(schemaType);
        },
        text: schemaType.title ?? startCase__default.default(schemaType.name)
      },
      schemaType.name
    )) }) : null })
  ] }) });
}
const viewToggleIcon = {
  grid: icons.ThLargeIcon,
  list: icons.UlistIcon
}, viewToggleTooltip = {
  grid: "insert-menu.toggle-grid-view.tooltip",
  list: "insert-menu.toggle-list-view.tooltip"
};
function ViewToggle(props) {
  const viewIndex = props.views.findIndex((view) => view.selected), nextView = props.views[viewIndex + 1] ?? props.views[0];
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: props.labels[viewToggleTooltip[nextView.name]] }),
      placement: "top",
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Button,
        {
          mode: "bleed",
          icon: viewToggleIcon[nextView.name],
          onClick: () => {
            props.onToggle(nextView.name);
          }
        }
      )
    }
  );
}
function GridMenuItem(props) {
  const [failedToLoad, setFailedToLoad] = react.useState(!1);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.MenuItem, { padding: 0, radius: 2, onClick: props.onClick, style: { overflow: "hidden" }, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", gap: 1, padding: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(
      ui.Box,
      {
        flex: "none",
        style: {
          backgroundColor: "var(--card-muted-bg-color)",
          paddingBottom: "66.6%",
          position: "relative"
        },
        children: [
          reactIs.isValidElementType(props.icon) ? /* @__PURE__ */ jsxRuntime.jsx(
            ui.Flex,
            {
              align: "center",
              justify: "center",
              style: {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%"
              },
              children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: react.createElement(props.icon) })
            }
          ) : null,
          !props.previewImageUrl || failedToLoad ? null : /* @__PURE__ */ jsxRuntime.jsx(
            "img",
            {
              src: props.previewImageUrl,
              style: {
                objectFit: "contain",
                width: "100%",
                height: "100%",
                position: "absolute",
                inset: 0
              },
              onError: () => {
                setFailedToLoad(!0);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntime.jsx(
            "div",
            {
              style: {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                boxShadow: "inset 0 0 0 0.5px var(--card-fg-color)",
                opacity: 0.1
              }
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: props.schemaType.title ?? props.schemaType.name }) })
  ] }) });
}
function filterSchemaTypes(schemaTypes, query, groups) {
  return schemaTypes.filter(
    (schemaType) => passesGroupFilter(schemaType, groups) && passesQueryFilter(schemaType, query)
  );
}
function passesQueryFilter(schemaType, query) {
  const sanitizedQuery = query.trim().toLowerCase();
  return schemaType.title ? schemaType.title?.toLowerCase().includes(sanitizedQuery) : schemaType.name.includes(sanitizedQuery);
}
function passesGroupFilter(schemaType, groups) {
  const selectedGroup = groups.find((group) => group.selected);
  return selectedGroup ? selectedGroup.name === ALL_ITEMS_GROUP_NAME ? !0 : selectedGroup.of?.includes(schemaType.name) : !0;
}
exports.InsertMenu = InsertMenu;
//# sourceMappingURL=index.cjs.map
