import { apiVersion, urlSearchParamPreviewSecret, urlSearchParamPreviewPerspective, urlSearchParamPreviewPathname, fetchSecretQuery, fetchSharedAccessSecretQuery, tag, isDev } from './constants.js';

function createClientWithConfig(client) {
  if (!client) {
    throw new TypeError("`client` is required");
  }
  if (!client.config().token) {
    throw new TypeError("`client` must have a `token` specified");
  }
  return client.withConfig({
    perspective: "raw",
    // Userland might be using an API version that's too old to use perspectives
    apiVersion,
    // We can't use the CDN, the secret is typically validated right after it's created
    useCdn: false,
    // Don't waste time returning a source map, we don't need it
    resultSourceMap: false,
    // @ts-expect-error - If stega is enabled, make sure it's disabled
    stega: false
  });
}

function parsePreviewUrl(unsafeUrl) {
  const url = new URL(unsafeUrl, "http://localhost");
  const secret = url.searchParams.get(urlSearchParamPreviewSecret);
  if (!secret) {
    throw new Error("Missing secret");
  }
  const studioPreviewPerspective = url.searchParams.get(urlSearchParamPreviewPerspective);
  let redirectTo = void 0;
  const unsafeRedirectTo = url.searchParams.get(urlSearchParamPreviewPathname);
  if (unsafeRedirectTo) {
    const { pathname, search, hash } = new URL(unsafeRedirectTo, "http://localhost");
    redirectTo = `${pathname}${search}${hash}`;
  }
  return { secret, redirectTo, studioPreviewPerspective };
}

async function validateSecret(client, secret, disableCacheNoStore) {
  if (typeof EdgeRuntime !== "undefined") {
    await new Promise((resolve) => setTimeout(resolve, 300));
  }
  if (!secret || !secret.trim()) {
    return { isValid: false, studioUrl: null };
  }
  const { private: privateSecret, public: publicSecret } = await client.fetch(
    `{
      "private": ${fetchSecretQuery},
      "public": ${fetchSharedAccessSecretQuery}
    }`,
    { secret },
    {
      tag,
      // In CloudFlare Workers we can't pass the cache header
      ...!disableCacheNoStore ? { cache: "no-store" } : void 0
    }
  );
  if (privateSecret) {
    if (!privateSecret?._id || !privateSecret?._updatedAt || !privateSecret?.secret) {
      return { isValid: false, studioUrl: null };
    }
    return { isValid: secret === privateSecret.secret, studioUrl: privateSecret.studioUrl };
  }
  if (!publicSecret?.secret) {
    return { isValid: false, studioUrl: null };
  }
  return { isValid: secret === publicSecret.secret, studioUrl: publicSecret.studioUrl };
}

async function validatePreviewUrl(_client, previewUrl, disableCacheNoStore = globalThis.navigator?.userAgent === "Cloudflare-Workers") {
  const client = createClientWithConfig(_client);
  let parsedPreviewUrl;
  try {
    parsedPreviewUrl = parsePreviewUrl(previewUrl);
  } catch (error) {
    if (isDev) {
      console.error("Failed to parse preview URL", error, {
        previewUrl,
        client
      });
    }
    return { isValid: false };
  }
  const { isValid, studioUrl } = await validateSecret(
    client,
    parsedPreviewUrl.secret,
    disableCacheNoStore
  );
  const redirectTo = isValid ? parsedPreviewUrl.redirectTo : void 0;
  const studioPreviewPerspective = isValid ? parsedPreviewUrl.studioPreviewPerspective : void 0;
  let studioOrigin;
  if (isValid) {
    try {
      studioOrigin = new URL(studioUrl).origin;
    } catch (error) {
      if (isDev) {
        console.error("Failed to parse studioUrl", error, {
          previewUrl,
          studioUrl
        });
      }
    }
  }
  return { isValid, redirectTo, studioOrigin, studioPreviewPerspective };
}

export { urlSearchParamPreviewPathname, urlSearchParamPreviewSecret, validatePreviewUrl };
//# sourceMappingURL=index.js.map
