"use strict";
var jsxRuntime = require("react/jsx-runtime"), PresentationToolGrantsCheck = require("./PresentationToolGrantsCheck.cjs"), hooks = require("./hooks.cjs"), csm = require("@sanity/client/csm"), comlink = require("@sanity/comlink"), mendoza = require("mendoza"), LRUCache = require("mnemonist/lru-cache-with-delete"), react = require("react"), sanity = require("sanity"), index = require("./index.cjs");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var LRUCache__default = /* @__PURE__ */ _interopDefaultCompat(LRUCache);
function LoaderQueries(props) {
  const {
    liveDocument,
    controller,
    perspective: activePerspective,
    documentsOnPage,
    onLoadersConnection,
    onDocumentsOnPage
  } = props, [comlink$1, setComlink] = react.useState(), [liveQueries, setLiveQueries] = react.useState({}), projectId = sanity.useProjectId(), dataset = sanity.useDataset();
  react.useEffect(() => {
    const interval = setInterval(
      () => setLiveQueries((liveQueries2) => {
        if (Object.keys(liveQueries2).length < 1)
          return liveQueries2;
        const now = Date.now();
        if (!Object.values(liveQueries2).some(
          (liveQuery) => liveQuery.heartbeat !== !1 && now > liveQuery.receivedAt + liveQuery.heartbeat
        ))
          return liveQueries2;
        const next = {};
        for (const [key, value] of Object.entries(liveQueries2))
          value.heartbeat !== !1 && now > value.receivedAt + value.heartbeat || (next[key] = value);
        return next;
      }),
      index.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL
    );
    return () => clearInterval(interval);
  }, []), react.useEffect(() => {
    if (controller) {
      const comlink2 = controller.createConnection(
        {
          name: "presentation",
          connectTo: "loaders",
          heartbeat: !0
        },
        comlink.createChannelMachine().provide({
          actors: PresentationToolGrantsCheck.createCompatibilityActors()
        })
      );
      return setComlink(comlink2), comlink2.onStatus(onLoadersConnection), comlink2.on("loader/documents", (data) => {
        data.projectId === projectId && data.dataset === dataset && onDocumentsOnPage(
          "loaders",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          data.perspective,
          data.documents
        );
      }), comlink2.on("loader/query-listen", (data) => {
        if (data.projectId === projectId && data.dataset === dataset) {
          if (typeof data.heartbeat == "number" && data.heartbeat < index.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL)
            throw new Error(
              `Loader query listen heartbeat interval must be at least ${index.MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL}ms`
            );
          setLiveQueries((prev) => ({
            ...prev,
            [PresentationToolGrantsCheck.getQueryCacheKey(data.query, data.params)]: {
              perspective: data.perspective,
              query: data.query,
              params: data.params,
              receivedAt: Date.now(),
              heartbeat: data.heartbeat ?? !1
            }
          }));
        }
      }), comlink2.start();
    }
  }, [controller, dataset, onDocumentsOnPage, onLoadersConnection, projectId]);
  const [cache] = react.useState(() => new LRUCache__default.default(index.LIVE_QUERY_CACHE_SIZE)), studioClient = sanity.useClient({ apiVersion: "2023-10-16" }), clientConfig = react.useMemo(() => studioClient.config(), [studioClient]), client = react.useMemo(
    () => studioClient.withConfig({
      resultSourceMap: "withKeyArraySelector"
    }),
    [studioClient]
  );
  react.useEffect(() => {
    if (comlink$1) {
      const { projectId: projectId2, dataset: dataset2 } = clientConfig;
      comlink$1.post({
        type: "loader/perspective",
        data: {
          projectId: projectId2,
          dataset: dataset2,
          perspective: activePerspective
        }
      });
    }
  }, [comlink$1, clientConfig, activePerspective]);
  const turboIds = react.useMemo(() => {
    const documentsActuallyInUse = documentsOnPage.map(({ _id }) => _id), ids = [...new Set(documentsActuallyInUse)], max = cache.capacity;
    return ids.length >= max && (ids.length = max), ids;
  }, [cache.capacity, documentsOnPage]), [documentsCacheLastUpdated, setDocumentsCacheLastUpdated] = react.useState(0);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Turbo,
      {
        cache,
        client,
        turboIds,
        setDocumentsCacheLastUpdated
      }
    ),
    Object.entries(liveQueries).map(([key, { query, params, perspective }]) => /* @__PURE__ */ jsxRuntime.jsx(
      QuerySubscription,
      {
        cache,
        projectId: clientConfig.projectId,
        dataset: clientConfig.dataset,
        perspective,
        query,
        params,
        comlink: comlink$1,
        client,
        refreshInterval: activePerspective ? 2e3 : 0,
        liveDocument,
        documentsCacheLastUpdated
      },
      `${key}${perspective}`
    ))
  ] });
}
const Turbo = react.memo(function(props) {
  const { cache, client, turboIds, setDocumentsCacheLastUpdated } = props, [batch, setBatch] = react.useState([]);
  return react.useEffect(() => {
    const batchSet = new Set(batch.flat()), nextBatch = /* @__PURE__ */ new Set();
    for (const turboId of turboIds)
      !batchSet.has(turboId) && !cache.has(turboId) && nextBatch.add(turboId);
    const nextBatchSlice = [...nextBatch].slice(0, index.LIVE_QUERY_CACHE_BATCH_SIZE);
    nextBatchSlice.length !== 0 && setBatch((prevBatch) => [...prevBatch.slice(-index.LIVE_QUERY_CACHE_BATCH_SIZE), nextBatchSlice]);
  }, [batch, cache, turboIds]), react.useEffect(() => {
    const subscription = client.listen(
      "*",
      {},
      {
        events: ["mutation"],
        effectFormat: "mendoza",
        includePreviousRevision: !1,
        includeResult: !1,
        tag: "presentation-loader"
      }
    ).subscribe((update) => {
      if (update.type === "mutation" && update.transition === "disappear" && cache.delete(update.documentId) && setDocumentsCacheLastUpdated(Date.now()), update.type !== "mutation" || !update.effects?.apply?.length) return;
      const cachedDocument = cache.peek(update.documentId);
      if (cachedDocument) {
        const patchDoc = { ...cachedDocument };
        delete patchDoc._rev;
        const patchedDocument = mendoza.applyPatch(patchDoc, update.effects.apply);
        cache.set(update.documentId, patchedDocument), setDocumentsCacheLastUpdated(Date.now());
      }
    });
    return () => subscription.unsubscribe();
  }, [cache, client, setDocumentsCacheLastUpdated]), /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: batch.map((ids) => /* @__PURE__ */ jsxRuntime.jsx(
    GetDocuments,
    {
      cache,
      client,
      ids,
      setDocumentsCacheLastUpdated
    },
    JSON.stringify(ids)
  )) });
}), GetDocuments = react.memo(function(props) {
  const { client, cache, ids, setDocumentsCacheLastUpdated } = props;
  return react.useEffect(() => {
    const missingIds = ids.filter((id) => !cache.has(id));
    missingIds.length !== 0 && client.getDocuments(missingIds).then((documents) => {
      for (const doc of documents)
        doc && doc?._id && (cache.set(doc._id, doc), setDocumentsCacheLastUpdated(Date.now()));
    }, console.error);
  }, [cache, client, ids, setDocumentsCacheLastUpdated]), null;
});
GetDocuments.displayName = "GetDocuments";
function QuerySubscription(props) {
  const {
    cache,
    projectId,
    dataset,
    perspective,
    query,
    client,
    refreshInterval,
    liveDocument,
    comlink: comlink2,
    documentsCacheLastUpdated
  } = props, params = hooks.useQueryParams(props.params), data = useQuerySubscription({
    cache,
    client,
    liveDocument,
    params,
    perspective,
    query,
    refreshInterval,
    documentsCacheLastUpdated
  }), result = data?.result, resultSourceMap = data?.resultSourceMap, tags = data?.tags;
  return react.useEffect(() => {
    resultSourceMap && comlink2?.post({
      type: "loader/query-change",
      data: {
        projectId,
        dataset,
        perspective,
        query,
        params,
        result,
        resultSourceMap,
        tags
      }
    });
  }, [comlink2, dataset, params, perspective, projectId, query, result, resultSourceMap, tags]), null;
}
function useQuerySubscription(props) {
  const {
    cache,
    liveDocument,
    client,
    refreshInterval,
    query,
    params,
    perspective,
    documentsCacheLastUpdated
  } = props, [snapshot, setSnapshot] = react.useState(null), { projectId, dataset } = react.useMemo(() => {
    const { projectId: projectId2, dataset: dataset2 } = client.config();
    return { projectId: projectId2, dataset: dataset2 };
  }, [client]), [error, setError] = react.useState(null);
  if (error) throw error;
  const [revalidate, startRefresh] = hooks.useRevalidate({ refreshInterval }), shouldRefetch = revalidate === "refresh" || revalidate === "inflight";
  return react.useEffect(() => {
    if (!shouldRefetch)
      return;
    let fulfilled = !1, fetching = !1;
    const controller = new AbortController();
    async function effect() {
      const { signal } = controller;
      fetching = !0;
      const { result, resultSourceMap, syncTags } = await client.fetch(query, params, {
        tag: "presentation-loader",
        signal,
        perspective,
        filterResponse: !1
      });
      fetching = !1, signal.aborted || (setSnapshot({ result, resultSourceMap, tags: syncTags }), fulfilled = !0);
    }
    const onFinally = startRefresh();
    return effect().catch((error2) => {
      fetching = !1, error2.name !== "AbortError" && setError(error2);
    }).finally(onFinally), () => {
      !fulfilled && !fetching && controller.abort();
    };
  }, [
    client,
    dataset,
    liveDocument,
    params,
    perspective,
    projectId,
    query,
    shouldRefetch,
    startRefresh
  ]), react.useMemo(() => documentsCacheLastUpdated && snapshot?.resultSourceMap ? {
    result: turboChargeResultIfSourceMap(
      cache,
      liveDocument,
      snapshot.result,
      perspective,
      snapshot.resultSourceMap
    ),
    resultSourceMap: snapshot.resultSourceMap
  } : snapshot, [cache, documentsCacheLastUpdated, liveDocument, perspective, snapshot]);
}
let warnedAboutCrossDatasetReference = !1;
function turboChargeResultIfSourceMap(cache, liveDocument, result, perspective, resultSourceMap) {
  if (perspective === "raw")
    throw new Error("turboChargeResultIfSourceMap does not support raw perspective");
  return csm.applySourceDocuments(
    result,
    resultSourceMap,
    (sourceDocument) => {
      if (sourceDocument._projectId) {
        warnedAboutCrossDatasetReference || (console.warn(
          "Cross dataset references are not supported yet, ignoring source document",
          sourceDocument
        ), warnedAboutCrossDatasetReference = !0);
        return;
      }
      return liveDocument?._id && csm.getPublishedId(liveDocument._id) === csm.getPublishedId(sourceDocument._id) ? liveDocument : cache.get(sourceDocument._id);
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (changedValue, { previousValue }) => typeof changedValue == "number" && typeof previousValue == "string" ? `${changedValue}` : changedValue,
    perspective
  );
}
exports.default = LoaderQueries;
exports.turboChargeResultIfSourceMap = turboChargeResultIfSourceMap;
//# sourceMappingURL=LoaderQueries.cjs.map
